        -:    0:Source:../../lib/regex_internal.h
        -:    0:Programs:50
        -:    1:/* Extended regular expression matching and search library.
        -:    2:   Copyright (C) 2002-2020 Free Software Foundation, Inc.
        -:    3:   This file is part of the GNU C Library.
        -:    4:   Contributed by Isamu Hasegawa <isamu@yamato.ibm.com>.
        -:    5:
        -:    6:   The GNU C Library is free software; you can redistribute it and/or
        -:    7:   modify it under the terms of the GNU General Public
        -:    8:   License as published by the Free Software Foundation; either
        -:    9:   version 3 of the License, or (at your option) any later version.
        -:   10:
        -:   11:   The GNU C Library is distributed in the hope that it will be useful,
        -:   12:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:   14:   General Public License for more details.
        -:   15:
        -:   16:   You should have received a copy of the GNU General Public
        -:   17:   License along with the GNU C Library; if not, see
        -:   18:   <https://www.gnu.org/licenses/>.  */
        -:   19:
        -:   20:#ifndef _REGEX_INTERNAL_H
        -:   21:#define _REGEX_INTERNAL_H 1
        -:   22:
        -:   23:#include <ctype.h>
        -:   24:#include <stdio.h>
        -:   25:#include <stdlib.h>
        -:   26:#include <string.h>
        -:   27:
        -:   28:#include <langinfo.h>
        -:   29:#include <locale.h>
        -:   30:#include <wchar.h>
        -:   31:#include <wctype.h>
        -:   32:#include <stdbool.h>
        -:   33:#include <stdint.h>
        -:   34:
        -:   35:#include <intprops.h>
        -:   36:#include <verify.h>
        -:   37:
        -:   38:#if defined DEBUG && DEBUG != 0
        -:   39:# include <assert.h>
        -:   40:# define DEBUG_ASSERT(x) assert (x)
        -:   41:#else
        -:   42:# define DEBUG_ASSERT(x) assume (x)
        -:   43:#endif
        -:   44:
        -:   45:#ifdef _LIBC
        -:   46:# include <libc-lock.h>
        -:   47:# define lock_define(name) __libc_lock_define (, name)
        -:   48:# define lock_init(lock) (__libc_lock_init (lock), 0)
        -:   49:# define lock_fini(lock) ((void) 0)
        -:   50:# define lock_lock(lock) __libc_lock_lock (lock)
        -:   51:# define lock_unlock(lock) __libc_lock_unlock (lock)
        -:   52:#elif defined GNULIB_LOCK && !defined USE_UNLOCKED_IO
        -:   53:# include "glthread/lock.h"
        -:   54:# define lock_define(name) gl_lock_define (, name)
        -:   55:# define lock_init(lock) glthread_lock_init (&(lock))
        -:   56:# define lock_fini(lock) glthread_lock_destroy (&(lock))
        -:   57:# define lock_lock(lock) glthread_lock_lock (&(lock))
        -:   58:# define lock_unlock(lock) glthread_lock_unlock (&(lock))
        -:   59:#elif defined GNULIB_PTHREAD && !defined USE_UNLOCKED_IO
        -:   60:# include <pthread.h>
        -:   61:# define lock_define(name) pthread_mutex_t name;
        -:   62:# define lock_init(lock) pthread_mutex_init (&(lock), 0)
        -:   63:# define lock_fini(lock) pthread_mutex_destroy (&(lock))
        -:   64:# define lock_lock(lock) pthread_mutex_lock (&(lock))
        -:   65:# define lock_unlock(lock) pthread_mutex_unlock (&(lock))
        -:   66:#else
        -:   67:# define lock_define(name)
        -:   68:# define lock_init(lock) 0
        -:   69:# define lock_fini(lock) ((void) 0)
        -:   70:  /* The 'dfa' avoids an "unused variable 'dfa'" warning from GCC.  */
        -:   71:# define lock_lock(lock) ((void) dfa)
        -:   72:# define lock_unlock(lock) ((void) 0)
        -:   73:#endif
        -:   74:
        -:   75:/* In case that the system doesn't have isblank().  */
        -:   76:#if !defined _LIBC && ! (defined isblank || (HAVE_ISBLANK && HAVE_DECL_ISBLANK))
        -:   77:# define isblank(ch) ((ch) == ' ' || (ch) == '\t')
        -:   78:#endif
        -:   79:
        -:   80:/* regex code assumes isascii has its usual numeric meaning,
        -:   81:   even if the portable character set uses EBCDIC encoding,
        -:   82:   and even if wint_t is wider than int.  */
        -:   83:#ifndef _LIBC
        -:   84:# undef isascii
        -:   85:# define isascii(c) (((c) & ~0x7f) == 0)
        -:   86:#endif
        -:   87:
        -:   88:#ifdef _LIBC
        -:   89:# ifndef _RE_DEFINE_LOCALE_FUNCTIONS
        -:   90:#  define _RE_DEFINE_LOCALE_FUNCTIONS 1
        -:   91:#   include <locale/localeinfo.h>
        -:   92:#   include <locale/coll-lookup.h>
        -:   93:# endif
        -:   94:#endif
        -:   95:
        -:   96:/* This is for other GNU distributions with internationalized messages.  */
        -:   97:#if (HAVE_LIBINTL_H && ENABLE_NLS) || defined _LIBC
        -:   98:# include <libintl.h>
        -:   99:# ifdef _LIBC
        -:  100:#  undef gettext
        -:  101:#  define gettext(msgid) \
        -:  102:  __dcgettext (_libc_intl_domainname, msgid, LC_MESSAGES)
        -:  103:# endif
        -:  104:#else
        -:  105:# undef gettext
        -:  106:# define gettext(msgid) (msgid)
        -:  107:#endif
        -:  108:
        -:  109:#ifndef gettext_noop
        -:  110:/* This define is so xgettext can find the internationalizable
        -:  111:   strings.  */
        -:  112:# define gettext_noop(String) String
        -:  113:#endif
        -:  114:
        -:  115:#if (defined MB_CUR_MAX && HAVE_WCTYPE_H && HAVE_ISWCTYPE) || _LIBC
        -:  116:# define RE_ENABLE_I18N
        -:  117:#endif
        -:  118:
        -:  119:/* Number of ASCII characters.  */
        -:  120:#define ASCII_CHARS 0x80
        -:  121:
        -:  122:/* Number of single byte characters.  */
        -:  123:#define SBC_MAX (UCHAR_MAX + 1)
        -:  124:
        -:  125:#define COLL_ELEM_LEN_MAX 8
        -:  126:
        -:  127:/* The character which represents newline.  */
        -:  128:#define NEWLINE_CHAR '\n'
        -:  129:#define WIDE_NEWLINE_CHAR L'\n'
        -:  130:
        -:  131:/* Rename to standard API for using out of glibc.  */
        -:  132:#ifndef _LIBC
        -:  133:# undef __wctype
        -:  134:# undef __iswalnum
        -:  135:# undef __iswctype
        -:  136:# undef __towlower
        -:  137:# undef __towupper
        -:  138:# define __wctype wctype
        -:  139:# define __iswalnum iswalnum
        -:  140:# define __iswctype iswctype
        -:  141:# define __towlower towlower
        -:  142:# define __towupper towupper
        -:  143:# define __btowc btowc
        -:  144:# define __mbrtowc mbrtowc
        -:  145:# define __wcrtomb wcrtomb
        -:  146:# define __regfree regfree
        -:  147:#endif /* not _LIBC */
        -:  148:
        -:  149:#ifndef SSIZE_MAX
        -:  150:# define SSIZE_MAX ((ssize_t) (SIZE_MAX / 2))
        -:  151:#endif
        -:  152:#ifndef ULONG_WIDTH
        -:  153:# define ULONG_WIDTH REGEX_UINTEGER_WIDTH (ULONG_MAX)
        -:  154:/* The number of usable bits in an unsigned integer type with maximum
        -:  155:   value MAX, as an int expression suitable in #if.  Cover all known
        -:  156:   practical hosts.  This implementation exploits the fact that MAX is
        -:  157:   1 less than a power of 2, and merely counts the number of 1 bits in
        -:  158:   MAX; "COBn" means "count the number of 1 bits in the low-order n bits".  */
        -:  159:# define REGEX_UINTEGER_WIDTH(max) REGEX_COB128 (max)
        -:  160:# define REGEX_COB128(n) (REGEX_COB64 ((n) >> 31 >> 31 >> 2) + REGEX_COB64 (n))
        -:  161:# define REGEX_COB64(n) (REGEX_COB32 ((n) >> 31 >> 1) + REGEX_COB32 (n))
        -:  162:# define REGEX_COB32(n) (REGEX_COB16 ((n) >> 16) + REGEX_COB16 (n))
        -:  163:# define REGEX_COB16(n) (REGEX_COB8 ((n) >> 8) + REGEX_COB8 (n))
        -:  164:# define REGEX_COB8(n) (REGEX_COB4 ((n) >> 4) + REGEX_COB4 (n))
        -:  165:# define REGEX_COB4(n) (!!((n) & 8) + !!((n) & 4) + !!((n) & 2) + ((n) & 1))
        -:  166:# if ULONG_MAX / 2 + 1 != 1ul << (ULONG_WIDTH - 1)
        -:  167:#  error "ULONG_MAX out of range"
        -:  168:# endif
        -:  169:#endif
        -:  170:
        -:  171:/* The type of indexes into strings.  This is signed, not size_t,
        -:  172:   since the API requires indexes to fit in regoff_t anyway, and using
        -:  173:   signed integers makes the code a bit smaller and presumably faster.
        -:  174:   The traditional GNU regex implementation uses int for indexes.
        -:  175:   The POSIX-compatible implementation uses a possibly-wider type.
        -:  176:   The name 'Idx' is three letters to minimize the hassle of
        -:  177:   reindenting a lot of regex code that formerly used 'int'.  */
        -:  178:typedef regoff_t Idx;
        -:  179:#ifdef _REGEX_LARGE_OFFSETS
        -:  180:# define IDX_MAX SSIZE_MAX
        -:  181:#else
        -:  182:# define IDX_MAX INT_MAX
        -:  183:#endif
        -:  184:
        -:  185:/* A hash value, suitable for computing hash tables.  */
        -:  186:typedef __re_size_t re_hashval_t;
        -:  187:
        -:  188:/* An integer used to represent a set of bits.  It must be unsigned,
        -:  189:   and must be at least as wide as unsigned int.  */
        -:  190:typedef unsigned long int bitset_word_t;
        -:  191:/* All bits set in a bitset_word_t.  */
        -:  192:#define BITSET_WORD_MAX ULONG_MAX
        -:  193:/* Number of bits in a bitset_word_t.  */
        -:  194:#define BITSET_WORD_BITS ULONG_WIDTH
        -:  195:
        -:  196:/* Number of bitset_word_t values in a bitset_t.  */
        -:  197:#define BITSET_WORDS ((SBC_MAX + BITSET_WORD_BITS - 1) / BITSET_WORD_BITS)
        -:  198:
        -:  199:typedef bitset_word_t bitset_t[BITSET_WORDS];
        -:  200:typedef bitset_word_t *re_bitset_ptr_t;
        -:  201:typedef const bitset_word_t *re_const_bitset_ptr_t;
        -:  202:
        -:  203:#define PREV_WORD_CONSTRAINT 0x0001
        -:  204:#define PREV_NOTWORD_CONSTRAINT 0x0002
        -:  205:#define NEXT_WORD_CONSTRAINT 0x0004
        -:  206:#define NEXT_NOTWORD_CONSTRAINT 0x0008
        -:  207:#define PREV_NEWLINE_CONSTRAINT 0x0010
        -:  208:#define NEXT_NEWLINE_CONSTRAINT 0x0020
        -:  209:#define PREV_BEGBUF_CONSTRAINT 0x0040
        -:  210:#define NEXT_ENDBUF_CONSTRAINT 0x0080
        -:  211:#define WORD_DELIM_CONSTRAINT 0x0100
        -:  212:#define NOT_WORD_DELIM_CONSTRAINT 0x0200
        -:  213:
        -:  214:typedef enum
        -:  215:{
        -:  216:  INSIDE_WORD = PREV_WORD_CONSTRAINT | NEXT_WORD_CONSTRAINT,
        -:  217:  WORD_FIRST = PREV_NOTWORD_CONSTRAINT | NEXT_WORD_CONSTRAINT,
        -:  218:  WORD_LAST = PREV_WORD_CONSTRAINT | NEXT_NOTWORD_CONSTRAINT,
        -:  219:  INSIDE_NOTWORD = PREV_NOTWORD_CONSTRAINT | NEXT_NOTWORD_CONSTRAINT,
        -:  220:  LINE_FIRST = PREV_NEWLINE_CONSTRAINT,
        -:  221:  LINE_LAST = NEXT_NEWLINE_CONSTRAINT,
        -:  222:  BUF_FIRST = PREV_BEGBUF_CONSTRAINT,
        -:  223:  BUF_LAST = NEXT_ENDBUF_CONSTRAINT,
        -:  224:  WORD_DELIM = WORD_DELIM_CONSTRAINT,
        -:  225:  NOT_WORD_DELIM = NOT_WORD_DELIM_CONSTRAINT
        -:  226:} re_context_type;
        -:  227:
        -:  228:typedef struct
        -:  229:{
        -:  230:  Idx alloc;
        -:  231:  Idx nelem;
        -:  232:  Idx *elems;
        -:  233:} re_node_set;
        -:  234:
        -:  235:typedef enum
        -:  236:{
        -:  237:  NON_TYPE = 0,
        -:  238:
        -:  239:  /* Node type, These are used by token, node, tree.  */
        -:  240:  CHARACTER = 1,
        -:  241:  END_OF_RE = 2,
        -:  242:  SIMPLE_BRACKET = 3,
        -:  243:  OP_BACK_REF = 4,
        -:  244:  OP_PERIOD = 5,
        -:  245:#ifdef RE_ENABLE_I18N
        -:  246:  COMPLEX_BRACKET = 6,
        -:  247:  OP_UTF8_PERIOD = 7,
        -:  248:#endif /* RE_ENABLE_I18N */
        -:  249:
        -:  250:  /* We define EPSILON_BIT as a macro so that OP_OPEN_SUBEXP is used
        -:  251:     when the debugger shows values of this enum type.  */
        -:  252:#define EPSILON_BIT 8
        -:  253:  OP_OPEN_SUBEXP = EPSILON_BIT | 0,
        -:  254:  OP_CLOSE_SUBEXP = EPSILON_BIT | 1,
        -:  255:  OP_ALT = EPSILON_BIT | 2,
        -:  256:  OP_DUP_ASTERISK = EPSILON_BIT | 3,
        -:  257:  ANCHOR = EPSILON_BIT | 4,
        -:  258:
        -:  259:  /* Tree type, these are used only by tree. */
        -:  260:  CONCAT = 16,
        -:  261:  SUBEXP = 17,
        -:  262:
        -:  263:  /* Token type, these are used only by token.  */
        -:  264:  OP_DUP_PLUS = 18,
        -:  265:  OP_DUP_QUESTION,
        -:  266:  OP_OPEN_BRACKET,
        -:  267:  OP_CLOSE_BRACKET,
        -:  268:  OP_CHARSET_RANGE,
        -:  269:  OP_OPEN_DUP_NUM,
        -:  270:  OP_CLOSE_DUP_NUM,
        -:  271:  OP_NON_MATCH_LIST,
        -:  272:  OP_OPEN_COLL_ELEM,
        -:  273:  OP_CLOSE_COLL_ELEM,
        -:  274:  OP_OPEN_EQUIV_CLASS,
        -:  275:  OP_CLOSE_EQUIV_CLASS,
        -:  276:  OP_OPEN_CHAR_CLASS,
        -:  277:  OP_CLOSE_CHAR_CLASS,
        -:  278:  OP_WORD,
        -:  279:  OP_NOTWORD,
        -:  280:  OP_SPACE,
        -:  281:  OP_NOTSPACE,
        -:  282:  BACK_SLASH
        -:  283:
        -:  284:} re_token_type_t;
        -:  285:
        -:  286:#ifdef RE_ENABLE_I18N
        -:  287:typedef struct
        -:  288:{
        -:  289:  /* Multibyte characters.  */
        -:  290:  wchar_t *mbchars;
        -:  291:
        -:  292:  /* Collating symbols.  */
        -:  293:# ifdef _LIBC
        -:  294:  int32_t *coll_syms;
        -:  295:# endif
        -:  296:
        -:  297:  /* Equivalence classes. */
        -:  298:# ifdef _LIBC
        -:  299:  int32_t *equiv_classes;
        -:  300:# endif
        -:  301:
        -:  302:  /* Range expressions. */
        -:  303:# ifdef _LIBC
        -:  304:  uint32_t *range_starts;
        -:  305:  uint32_t *range_ends;
        -:  306:# else /* not _LIBC */
        -:  307:  wchar_t *range_starts;
        -:  308:  wchar_t *range_ends;
        -:  309:# endif /* not _LIBC */
        -:  310:
        -:  311:  /* Character classes. */
        -:  312:  wctype_t *char_classes;
        -:  313:
        -:  314:  /* If this character set is the non-matching list.  */
        -:  315:  unsigned int non_match : 1;
        -:  316:
        -:  317:  /* # of multibyte characters.  */
        -:  318:  Idx nmbchars;
        -:  319:
        -:  320:  /* # of collating symbols.  */
        -:  321:  Idx ncoll_syms;
        -:  322:
        -:  323:  /* # of equivalence classes. */
        -:  324:  Idx nequiv_classes;
        -:  325:
        -:  326:  /* # of range expressions. */
        -:  327:  Idx nranges;
        -:  328:
        -:  329:  /* # of character classes. */
        -:  330:  Idx nchar_classes;
        -:  331:} re_charset_t;
        -:  332:#endif /* RE_ENABLE_I18N */
        -:  333:
        -:  334:typedef struct
        -:  335:{
        -:  336:  union
        -:  337:  {
        -:  338:    unsigned char c;		/* for CHARACTER */
        -:  339:    re_bitset_ptr_t sbcset;	/* for SIMPLE_BRACKET */
        -:  340:#ifdef RE_ENABLE_I18N
        -:  341:    re_charset_t *mbcset;	/* for COMPLEX_BRACKET */
        -:  342:#endif /* RE_ENABLE_I18N */
        -:  343:    Idx idx;			/* for BACK_REF */
        -:  344:    re_context_type ctx_type;	/* for ANCHOR */
        -:  345:  } opr;
        -:  346:#if (__GNUC__ >= 2 || defined __clang__) && !defined __STRICT_ANSI__
        -:  347:  re_token_type_t type : 8;
        -:  348:#else
        -:  349:  re_token_type_t type;
        -:  350:#endif
        -:  351:  unsigned int constraint : 10;	/* context constraint */
        -:  352:  unsigned int duplicated : 1;
        -:  353:  unsigned int opt_subexp : 1;
        -:  354:#ifdef RE_ENABLE_I18N
        -:  355:  unsigned int accept_mb : 1;
        -:  356:  /* These 2 bits can be moved into the union if needed (e.g. if running out
        -:  357:     of bits; move opr.c to opr.c.c and move the flags to opr.c.flags).  */
        -:  358:  unsigned int mb_partial : 1;
        -:  359:#endif
        -:  360:  unsigned int word_char : 1;
        -:  361:} re_token_t;
        -:  362:
        -:  363:#define IS_EPSILON_NODE(type) ((type) & EPSILON_BIT)
        -:  364:
        -:  365:struct re_string_t
        -:  366:{
        -:  367:  /* Indicate the raw buffer which is the original string passed as an
        -:  368:     argument of regexec(), re_search(), etc..  */
        -:  369:  const unsigned char *raw_mbs;
        -:  370:  /* Store the multibyte string.  In case of "case insensitive mode" like
        -:  371:     REG_ICASE, upper cases of the string are stored, otherwise MBS points
        -:  372:     the same address that RAW_MBS points.  */
        -:  373:  unsigned char *mbs;
        -:  374:#ifdef RE_ENABLE_I18N
        -:  375:  /* Store the wide character string which is corresponding to MBS.  */
        -:  376:  wint_t *wcs;
        -:  377:  Idx *offsets;
        -:  378:  mbstate_t cur_state;
        -:  379:#endif
        -:  380:  /* Index in RAW_MBS.  Each character mbs[i] corresponds to
        -:  381:     raw_mbs[raw_mbs_idx + i].  */
        -:  382:  Idx raw_mbs_idx;
        -:  383:  /* The length of the valid characters in the buffers.  */
        -:  384:  Idx valid_len;
        -:  385:  /* The corresponding number of bytes in raw_mbs array.  */
        -:  386:  Idx valid_raw_len;
        -:  387:  /* The length of the buffers MBS and WCS.  */
        -:  388:  Idx bufs_len;
        -:  389:  /* The index in MBS, which is updated by re_string_fetch_byte.  */
        -:  390:  Idx cur_idx;
        -:  391:  /* length of RAW_MBS array.  */
        -:  392:  Idx raw_len;
        -:  393:  /* This is RAW_LEN - RAW_MBS_IDX + VALID_LEN - VALID_RAW_LEN.  */
        -:  394:  Idx len;
        -:  395:  /* End of the buffer may be shorter than its length in the cases such
        -:  396:     as re_match_2, re_search_2.  Then, we use STOP for end of the buffer
        -:  397:     instead of LEN.  */
        -:  398:  Idx raw_stop;
        -:  399:  /* This is RAW_STOP - RAW_MBS_IDX adjusted through OFFSETS.  */
        -:  400:  Idx stop;
        -:  401:
        -:  402:  /* The context of mbs[0].  We store the context independently, since
        -:  403:     the context of mbs[0] may be different from raw_mbs[0], which is
        -:  404:     the beginning of the input string.  */
        -:  405:  unsigned int tip_context;
        -:  406:  /* The translation passed as a part of an argument of re_compile_pattern.  */
        -:  407:  RE_TRANSLATE_TYPE trans;
        -:  408:  /* Copy of re_dfa_t's word_char.  */
        -:  409:  re_const_bitset_ptr_t word_char;
        -:  410:  /* true if REG_ICASE.  */
        -:  411:  unsigned char icase;
        -:  412:  unsigned char is_utf8;
        -:  413:  unsigned char map_notascii;
        -:  414:  unsigned char mbs_allocated;
        -:  415:  unsigned char offsets_needed;
        -:  416:  unsigned char newline_anchor;
        -:  417:  unsigned char word_ops_used;
        -:  418:  int mb_cur_max;
        -:  419:};
        -:  420:typedef struct re_string_t re_string_t;
        -:  421:
        -:  422:
        -:  423:struct re_dfa_t;
        -:  424:typedef struct re_dfa_t re_dfa_t;
        -:  425:
        -:  426:#ifndef _LIBC
        -:  427:# define IS_IN(libc) false
        -:  428:#endif
        -:  429:
        -:  430:#define re_string_peek_byte(pstr, offset) \
        -:  431:  ((pstr)->mbs[(pstr)->cur_idx + offset])
        -:  432:#define re_string_fetch_byte(pstr) \
        -:  433:  ((pstr)->mbs[(pstr)->cur_idx++])
        -:  434:#define re_string_first_byte(pstr, idx) \
        -:  435:  ((idx) == (pstr)->valid_len || (pstr)->wcs[idx] != WEOF)
        -:  436:#define re_string_is_single_byte_char(pstr, idx) \
        -:  437:  ((pstr)->wcs[idx] != WEOF && ((pstr)->valid_len == (idx) + 1 \
        -:  438:				|| (pstr)->wcs[(idx) + 1] != WEOF))
        -:  439:#define re_string_eoi(pstr) ((pstr)->stop <= (pstr)->cur_idx)
        -:  440:#define re_string_cur_idx(pstr) ((pstr)->cur_idx)
        -:  441:#define re_string_get_buffer(pstr) ((pstr)->mbs)
        -:  442:#define re_string_length(pstr) ((pstr)->len)
        -:  443:#define re_string_byte_at(pstr,idx) ((pstr)->mbs[idx])
        -:  444:#define re_string_skip_bytes(pstr,idx) ((pstr)->cur_idx += (idx))
        -:  445:#define re_string_set_index(pstr,idx) ((pstr)->cur_idx = (idx))
        -:  446:
        -:  447:#if defined _LIBC || HAVE_ALLOCA
        -:  448:# include <alloca.h>
        -:  449:#endif
        -:  450:
        -:  451:#ifndef _LIBC
        -:  452:# if HAVE_ALLOCA
        -:  453:/* The OS usually guarantees only one guard page at the bottom of the stack,
        -:  454:   and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  455:   allocate anything larger than 4096 bytes.  Also care for the possibility
        -:  456:   of a few compiler-allocated temporary stack slots.  */
        -:  457:#  define __libc_use_alloca(n) ((n) < 4032)
        -:  458:# else
        -:  459:/* alloca is implemented with malloc, so just use malloc.  */
        -:  460:#  define __libc_use_alloca(n) 0
        -:  461:#  undef alloca
        -:  462:#  define alloca(n) malloc (n)
        -:  463:# endif
        -:  464:#endif
        -:  465:
        -:  466:#ifdef _LIBC
        -:  467:# define MALLOC_0_IS_NONNULL 1
        -:  468:#elif !defined MALLOC_0_IS_NONNULL
        -:  469:# define MALLOC_0_IS_NONNULL 0
        -:  470:#endif
        -:  471:
        -:  472:#ifndef MAX
        -:  473:# define MAX(a,b) ((a) < (b) ? (b) : (a))
        -:  474:#endif
        -:  475:#ifndef MIN
        -:  476:# define MIN(a,b) ((a) < (b) ? (a) : (b))
        -:  477:#endif
        -:  478:
        -:  479:#define re_malloc(t,n) ((t *) malloc ((n) * sizeof (t)))
        -:  480:#define re_realloc(p,t,n) ((t *) realloc (p, (n) * sizeof (t)))
        -:  481:#define re_free(p) free (p)
        -:  482:
        -:  483:struct bin_tree_t
        -:  484:{
        -:  485:  struct bin_tree_t *parent;
        -:  486:  struct bin_tree_t *left;
        -:  487:  struct bin_tree_t *right;
        -:  488:  struct bin_tree_t *first;
        -:  489:  struct bin_tree_t *next;
        -:  490:
        -:  491:  re_token_t token;
        -:  492:
        -:  493:  /* 'node_idx' is the index in dfa->nodes, if 'type' == 0.
        -:  494:     Otherwise 'type' indicate the type of this node.  */
        -:  495:  Idx node_idx;
        -:  496:};
        -:  497:typedef struct bin_tree_t bin_tree_t;
        -:  498:
        -:  499:#define BIN_TREE_STORAGE_SIZE \
        -:  500:  ((1024 - sizeof (void *)) / sizeof (bin_tree_t))
        -:  501:
        -:  502:struct bin_tree_storage_t
        -:  503:{
        -:  504:  struct bin_tree_storage_t *next;
        -:  505:  bin_tree_t data[BIN_TREE_STORAGE_SIZE];
        -:  506:};
        -:  507:typedef struct bin_tree_storage_t bin_tree_storage_t;
        -:  508:
        -:  509:#define CONTEXT_WORD 1
        -:  510:#define CONTEXT_NEWLINE (CONTEXT_WORD << 1)
        -:  511:#define CONTEXT_BEGBUF (CONTEXT_NEWLINE << 1)
        -:  512:#define CONTEXT_ENDBUF (CONTEXT_BEGBUF << 1)
        -:  513:
        -:  514:#define IS_WORD_CONTEXT(c) ((c) & CONTEXT_WORD)
        -:  515:#define IS_NEWLINE_CONTEXT(c) ((c) & CONTEXT_NEWLINE)
        -:  516:#define IS_BEGBUF_CONTEXT(c) ((c) & CONTEXT_BEGBUF)
        -:  517:#define IS_ENDBUF_CONTEXT(c) ((c) & CONTEXT_ENDBUF)
        -:  518:#define IS_ORDINARY_CONTEXT(c) ((c) == 0)
        -:  519:
        -:  520:#define IS_WORD_CHAR(ch) (isalnum (ch) || (ch) == '_')
        -:  521:#define IS_NEWLINE(ch) ((ch) == NEWLINE_CHAR)
        -:  522:#define IS_WIDE_WORD_CHAR(ch) (__iswalnum (ch) || (ch) == L'_')
        -:  523:#define IS_WIDE_NEWLINE(ch) ((ch) == WIDE_NEWLINE_CHAR)
        -:  524:
        -:  525:#define NOT_SATISFY_PREV_CONSTRAINT(constraint,context) \
        -:  526: ((((constraint) & PREV_WORD_CONSTRAINT) && !IS_WORD_CONTEXT (context)) \
        -:  527:  || ((constraint & PREV_NOTWORD_CONSTRAINT) && IS_WORD_CONTEXT (context)) \
        -:  528:  || ((constraint & PREV_NEWLINE_CONSTRAINT) && !IS_NEWLINE_CONTEXT (context))\
        -:  529:  || ((constraint & PREV_BEGBUF_CONSTRAINT) && !IS_BEGBUF_CONTEXT (context)))
        -:  530:
        -:  531:#define NOT_SATISFY_NEXT_CONSTRAINT(constraint,context) \
        -:  532: ((((constraint) & NEXT_WORD_CONSTRAINT) && !IS_WORD_CONTEXT (context)) \
        -:  533:  || (((constraint) & NEXT_NOTWORD_CONSTRAINT) && IS_WORD_CONTEXT (context)) \
        -:  534:  || (((constraint) & NEXT_NEWLINE_CONSTRAINT) && !IS_NEWLINE_CONTEXT (context)) \
        -:  535:  || (((constraint) & NEXT_ENDBUF_CONSTRAINT) && !IS_ENDBUF_CONTEXT (context)))
        -:  536:
        -:  537:struct re_dfastate_t
        -:  538:{
        -:  539:  re_hashval_t hash;
        -:  540:  re_node_set nodes;
        -:  541:  re_node_set non_eps_nodes;
        -:  542:  re_node_set inveclosure;
        -:  543:  re_node_set *entrance_nodes;
        -:  544:  struct re_dfastate_t **trtable, **word_trtable;
        -:  545:  unsigned int context : 4;
        -:  546:  unsigned int halt : 1;
        -:  547:  /* If this state can accept "multi byte".
        -:  548:     Note that we refer to multibyte characters, and multi character
        -:  549:     collating elements as "multi byte".  */
        -:  550:  unsigned int accept_mb : 1;
        -:  551:  /* If this state has backreference node(s).  */
        -:  552:  unsigned int has_backref : 1;
        -:  553:  unsigned int has_constraint : 1;
        -:  554:};
        -:  555:typedef struct re_dfastate_t re_dfastate_t;
        -:  556:
        -:  557:struct re_state_table_entry
        -:  558:{
        -:  559:  Idx num;
        -:  560:  Idx alloc;
        -:  561:  re_dfastate_t **array;
        -:  562:};
        -:  563:
        -:  564:/* Array type used in re_sub_match_last_t and re_sub_match_top_t.  */
        -:  565:
        -:  566:typedef struct
        -:  567:{
        -:  568:  Idx next_idx;
        -:  569:  Idx alloc;
        -:  570:  re_dfastate_t **array;
        -:  571:} state_array_t;
        -:  572:
        -:  573:/* Store information about the node NODE whose type is OP_CLOSE_SUBEXP.  */
        -:  574:
        -:  575:typedef struct
        -:  576:{
        -:  577:  Idx node;
        -:  578:  Idx str_idx; /* The position NODE match at.  */
        -:  579:  state_array_t path;
        -:  580:} re_sub_match_last_t;
        -:  581:
        -:  582:/* Store information about the node NODE whose type is OP_OPEN_SUBEXP.
        -:  583:   And information about the node, whose type is OP_CLOSE_SUBEXP,
        -:  584:   corresponding to NODE is stored in LASTS.  */
        -:  585:
        -:  586:typedef struct
        -:  587:{
        -:  588:  Idx str_idx;
        -:  589:  Idx node;
        -:  590:  state_array_t *path;
        -:  591:  Idx alasts; /* Allocation size of LASTS.  */
        -:  592:  Idx nlasts; /* The number of LASTS.  */
        -:  593:  re_sub_match_last_t **lasts;
        -:  594:} re_sub_match_top_t;
        -:  595:
        -:  596:struct re_backref_cache_entry
        -:  597:{
        -:  598:  Idx node;
        -:  599:  Idx str_idx;
        -:  600:  Idx subexp_from;
        -:  601:  Idx subexp_to;
        -:  602:  bitset_word_t eps_reachable_subexps_map;
        -:  603:  char more;
        -:  604:};
        -:  605:
        -:  606:typedef struct
        -:  607:{
        -:  608:  /* The string object corresponding to the input string.  */
        -:  609:  re_string_t input;
        -:  610:  const re_dfa_t *const dfa;
        -:  611:  /* EFLAGS of the argument of regexec.  */
        -:  612:  int eflags;
        -:  613:  /* Where the matching ends.  */
        -:  614:  Idx match_last;
        -:  615:  Idx last_node;
        -:  616:  /* The state log used by the matcher.  */
        -:  617:  re_dfastate_t **state_log;
        -:  618:  Idx state_log_top;
        -:  619:  /* Back reference cache.  */
        -:  620:  Idx nbkref_ents;
        -:  621:  Idx abkref_ents;
        -:  622:  struct re_backref_cache_entry *bkref_ents;
        -:  623:  int max_mb_elem_len;
        -:  624:  Idx nsub_tops;
        -:  625:  Idx asub_tops;
        -:  626:  re_sub_match_top_t **sub_tops;
        -:  627:} re_match_context_t;
        -:  628:
        -:  629:typedef struct
        -:  630:{
        -:  631:  re_dfastate_t **sifted_states;
        -:  632:  re_dfastate_t **limited_states;
        -:  633:  Idx last_node;
        -:  634:  Idx last_str_idx;
        -:  635:  re_node_set limits;
        -:  636:} re_sift_context_t;
        -:  637:
        -:  638:struct re_fail_stack_ent_t
        -:  639:{
        -:  640:  Idx idx;
        -:  641:  Idx node;
        -:  642:  regmatch_t *regs;
        -:  643:  re_node_set eps_via_nodes;
        -:  644:};
        -:  645:
        -:  646:struct re_fail_stack_t
        -:  647:{
        -:  648:  Idx num;
        -:  649:  Idx alloc;
        -:  650:  struct re_fail_stack_ent_t *stack;
        -:  651:};
        -:  652:
        -:  653:struct re_dfa_t
        -:  654:{
        -:  655:  re_token_t *nodes;
        -:  656:  size_t nodes_alloc;
        -:  657:  size_t nodes_len;
        -:  658:  Idx *nexts;
        -:  659:  Idx *org_indices;
        -:  660:  re_node_set *edests;
        -:  661:  re_node_set *eclosures;
        -:  662:  re_node_set *inveclosures;
        -:  663:  struct re_state_table_entry *state_table;
        -:  664:  re_dfastate_t *init_state;
        -:  665:  re_dfastate_t *init_state_word;
        -:  666:  re_dfastate_t *init_state_nl;
        -:  667:  re_dfastate_t *init_state_begbuf;
        -:  668:  bin_tree_t *str_tree;
        -:  669:  bin_tree_storage_t *str_tree_storage;
        -:  670:  re_bitset_ptr_t sb_char;
        -:  671:  int str_tree_storage_idx;
        -:  672:
        -:  673:  /* number of subexpressions 're_nsub' is in regex_t.  */
        -:  674:  re_hashval_t state_hash_mask;
        -:  675:  Idx init_node;
        -:  676:  Idx nbackref; /* The number of backreference in this dfa.  */
        -:  677:
        -:  678:  /* Bitmap expressing which backreference is used.  */
        -:  679:  bitset_word_t used_bkref_map;
        -:  680:  bitset_word_t completed_bkref_map;
        -:  681:
        -:  682:  unsigned int has_plural_match : 1;
        -:  683:  /* If this dfa has "multibyte node", which is a backreference or
        -:  684:     a node which can accept multibyte character or multi character
        -:  685:     collating element.  */
        -:  686:  unsigned int has_mb_node : 1;
        -:  687:  unsigned int is_utf8 : 1;
        -:  688:  unsigned int map_notascii : 1;
        -:  689:  unsigned int word_ops_used : 1;
        -:  690:  int mb_cur_max;
        -:  691:  bitset_t word_char;
        -:  692:  reg_syntax_t syntax;
        -:  693:  Idx *subexp_map;
        -:  694:#ifdef DEBUG
        -:  695:  char* re_str;
        -:  696:#endif
        -:  697:  lock_define (lock)
        -:  698:};
        -:  699:
        -:  700:#define re_node_set_init_empty(set) memset (set, '\0', sizeof (re_node_set))
        -:  701:#define re_node_set_remove(set,id) \
        -:  702:  (re_node_set_remove_at (set, re_node_set_contains (set, id) - 1))
        -:  703:#define re_node_set_empty(p) ((p)->nelem = 0)
        -:  704:#define re_node_set_free(set) re_free ((set)->elems)
        -:  705:
        -:  706:
        -:  707:typedef enum
        -:  708:{
        -:  709:  SB_CHAR,
        -:  710:  MB_CHAR,
        -:  711:  EQUIV_CLASS,
        -:  712:  COLL_SYM,
        -:  713:  CHAR_CLASS
        -:  714:} bracket_elem_type;
        -:  715:
        -:  716:typedef struct
        -:  717:{
        -:  718:  bracket_elem_type type;
        -:  719:  union
        -:  720:  {
        -:  721:    unsigned char ch;
        -:  722:    unsigned char *name;
        -:  723:    wchar_t wch;
        -:  724:  } opr;
        -:  725:} bracket_elem_t;
        -:  726:
        -:  727:
        -:  728:/* Functions for bitset_t operation.  */
        -:  729:
        -:  730:static inline void
function bitset_set called 4 returned 100% blocks executed 100%
        4:  731:bitset_set (bitset_t set, Idx i)
        -:  732:{
        4:  733:  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;
        4:  734:}
        -:  735:
        -:  736:static inline void
function bitset_clear called 0 returned 0% blocks executed 0%
    #####:  737:bitset_clear (bitset_t set, Idx i)
        -:  738:{
    #####:  739:  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);
    #####:  740:}
        -:  741:
        -:  742:static inline bool
function bitset_contain called 0 returned 0% blocks executed 0%
    #####:  743:bitset_contain (const bitset_t set, Idx i)
        -:  744:{
    #####:  745:  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;
        -:  746:}
        -:  747:
        -:  748:static inline void
function bitset_empty called 0 returned 0% blocks executed 0%
    #####:  749:bitset_empty (bitset_t set)
        -:  750:{
    #####:  751:  memset (set, '\0', sizeof (bitset_t));
    #####:  752:}
        -:  753:
        -:  754:static inline void
function bitset_set_all called 0 returned 0% blocks executed 0%
    #####:  755:bitset_set_all (bitset_t set)
        -:  756:{
    #####:  757:  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));
        -:  758:  if (SBC_MAX % BITSET_WORD_BITS != 0)
        -:  759:    set[BITSET_WORDS - 1] =
        -:  760:      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;
    #####:  761:}
        -:  762:
        -:  763:static inline void
function bitset_copy called 0 returned 0% blocks executed 0%
    #####:  764:bitset_copy (bitset_t dest, const bitset_t src)
        -:  765:{
    #####:  766:  memcpy (dest, src, sizeof (bitset_t));
    #####:  767:}
        -:  768:
        -:  769:static inline void
function bitset_not called 0 returned 0% blocks executed 0%
    #####:  770:bitset_not (bitset_t set)
        -:  771:{
        -:  772:  int bitset_i;
    #####:  773:  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)
branch  0 never executed
branch  1 never executed
    #####:  774:    set[bitset_i] = ~set[bitset_i];
        -:  775:  if (SBC_MAX % BITSET_WORD_BITS != 0)
        -:  776:    set[BITSET_WORDS - 1] =
        -:  777:      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)
        -:  778:       & ~set[BITSET_WORDS - 1]);
    #####:  779:}
        -:  780:
        -:  781:static inline void
function bitset_merge called 0 returned 0% blocks executed 0%
    #####:  782:bitset_merge (bitset_t dest, const bitset_t src)
        -:  783:{
        -:  784:  int bitset_i;
    #####:  785:  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)
branch  0 never executed
branch  1 never executed
    #####:  786:    dest[bitset_i] |= src[bitset_i];
    #####:  787:}
        -:  788:
        -:  789:static inline void
function bitset_mask called 0 returned 0% blocks executed 0%
    #####:  790:bitset_mask (bitset_t dest, const bitset_t src)
        -:  791:{
        -:  792:  int bitset_i;
    #####:  793:  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)
branch  0 never executed
branch  1 never executed
    #####:  794:    dest[bitset_i] &= src[bitset_i];
    #####:  795:}
        -:  796:
        -:  797:#ifdef RE_ENABLE_I18N
        -:  798:/* Functions for re_string.  */
        -:  799:static int
        -:  800:__attribute__ ((pure, unused))
function re_string_char_size_at called 5 returned 100% blocks executed 78%
        5:  801:re_string_char_size_at (const re_string_t *pstr, Idx idx)
        -:  802:{
        -:  803:  int byte_idx;
        5:  804:  if (pstr->mb_cur_max == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  805:    return 1;
        5:  806:  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:  807:    if (pstr->wcs[idx + byte_idx] != WEOF)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  808:      break;
        5:  809:  return byte_idx;
        -:  810:}
        -:  811:
        -:  812:static wint_t
        -:  813:__attribute__ ((pure, unused))
function re_string_wchar_at called 155 returned 100% blocks executed 75%
      155:  814:re_string_wchar_at (const re_string_t *pstr, Idx idx)
        -:  815:{
      155:  816:  if (pstr->mb_cur_max == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  817:    return (wint_t) pstr->mbs[idx];
      155:  818:  return (wint_t) pstr->wcs[idx];
        -:  819:}
        -:  820:
        -:  821:# ifdef _LIBC
        -:  822:#  include <locale/weight.h>
        -:  823:# endif
        -:  824:
        -:  825:static int
        -:  826:__attribute__ ((pure, unused))
function re_string_elem_size_at called 0 returned 0% blocks executed 0%
    #####:  827:re_string_elem_size_at (const re_string_t *pstr, Idx idx)
        -:  828:{
        -:  829:# ifdef _LIBC
        -:  830:  const unsigned char *p, *extra;
        -:  831:  const int32_t *table, *indirect;
        -:  832:  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);
        -:  833:
        -:  834:  if (nrules != 0)
        -:  835:    {
        -:  836:      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);
        -:  837:      extra = (const unsigned char *)
        -:  838:	_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);
        -:  839:      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,
        -:  840:						_NL_COLLATE_INDIRECTMB);
        -:  841:      p = pstr->mbs + idx;
        -:  842:      findidx (table, indirect, extra, &p, pstr->len - idx);
        -:  843:      return p - pstr->mbs - idx;
        -:  844:    }
        -:  845:  else
        -:  846:# endif /* _LIBC */
    #####:  847:    return 1;
        -:  848:}
        -:  849:#endif /* RE_ENABLE_I18N */
        -:  850:
        -:  851:#ifndef FALLTHROUGH
        -:  852:# if (__GNUC__ >= 7) || (__clang_major__ >= 10)
        -:  853:#  define FALLTHROUGH __attribute__ ((__fallthrough__))
        -:  854:# else
        -:  855:#  define FALLTHROUGH ((void) 0)
        -:  856:# endif
        -:  857:#endif
        -:  858:
        -:  859:#endif /*  _REGEX_INTERNAL_H */
