        -:    0:Source:../../lib/xmalloc.c
        -:    0:Programs:50
        -:    1:/* xmalloc.c -- malloc with out of memory checking
        -:    2:
        -:    3:   Copyright (C) 1990-2000, 2002-2006, 2008-2020 Free Software Foundation, Inc.
        -:    4:
        -:    5:   This program is free software: you can redistribute it and/or modify
        -:    6:   it under the terms of the GNU General Public License as published by
        -:    7:   the Free Software Foundation; either version 3 of the License, or
        -:    8:   (at your option) any later version.
        -:    9:
        -:   10:   This program is distributed in the hope that it will be useful,
        -:   11:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:   GNU General Public License for more details.
        -:   14:
        -:   15:   You should have received a copy of the GNU General Public License
        -:   16:   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
        -:   17:
        -:   18:#include <config.h>
        -:   19:
        -:   20:#define XALLOC_INLINE _GL_EXTERN_INLINE
        -:   21:
        -:   22:#include "xalloc.h"
        -:   23:
        -:   24:#include <stdlib.h>
        -:   25:#include <string.h>
        -:   26:
        -:   27:/* 1 if calloc, malloc and realloc are known to be compatible with GNU.
        -:   28:   This matters if we are not also using the calloc-gnu, malloc-gnu
        -:   29:   and realloc-gnu modules, which define HAVE_CALLOC_GNU,
        -:   30:   HAVE_MALLOC_GNU and HAVE_REALLOC_GNU and support the GNU API even
        -:   31:   on non-GNU platforms.  */
        -:   32:#if defined HAVE_CALLOC_GNU || (defined __GLIBC__ && !defined __UCLIBC__)
        -:   33:enum { HAVE_GNU_CALLOC = 1 };
        -:   34:#else
        -:   35:enum { HAVE_GNU_CALLOC = 0 };
        -:   36:#endif
        -:   37:#if defined HAVE_MALLOC_GNU || (defined __GLIBC__ && !defined __UCLIBC__)
        -:   38:enum { HAVE_GNU_MALLOC = 1 };
        -:   39:#else
        -:   40:enum { HAVE_GNU_MALLOC = 0 };
        -:   41:#endif
        -:   42:#if defined HAVE_REALLOC_GNU || (defined __GLIBC__ && !defined __UCLIBC__)
        -:   43:enum { HAVE_GNU_REALLOC = 1 };
        -:   44:#else
        -:   45:enum { HAVE_GNU_REALLOC = 0 };
        -:   46:#endif
        -:   47:
        -:   48:/* Allocate N bytes of memory dynamically, with error checking.  */
        -:   49:
        -:   50:void *
function xmalloc called 1321 returned 100% blocks executed 75%
     1321:   51:xmalloc (size_t n)
        -:   52:{
     1321:   53:  void *p = malloc (n);
     1321:   54:  if (!p && (HAVE_GNU_MALLOC || n))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   55:    xalloc_die ();
call    0 never executed
     1321:   56:  return p;
        -:   57:}
        -:   58:
        -:   59:/* Change the size of an allocated block of memory P to N bytes,
        -:   60:   with error checking.  */
        -:   61:
        -:   62:void *
function xrealloc called 744 returned 100% blocks executed 57%
      744:   63:xrealloc (void *p, size_t n)
        -:   64:{
        -:   65:  if (!HAVE_GNU_REALLOC && !n && p)
        -:   66:    {
        -:   67:      /* The GNU and C99 realloc behaviors disagree here.  Act like GNU.  */
        -:   68:      free (p);
        -:   69:      return NULL;
        -:   70:    }
        -:   71:
      744:   72:  void *r = realloc (p, n);
      744:   73:  if (!r && (n || (HAVE_GNU_REALLOC && !p)))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:   74:    xalloc_die ();
call    0 never executed
      744:   75:  return r;
        -:   76:}
        -:   77:
        -:   78:/* If P is null, allocate a block of at least *PN bytes; otherwise,
        -:   79:   reallocate P so that it contains more than *PN bytes.  *PN must be
        -:   80:   nonzero unless P is null.  Set *PN to the new block's size, and
        -:   81:   return the pointer to the new block.  *PN is never set to zero, and
        -:   82:   the returned pointer is never null.  */
        -:   83:
        -:   84:void *
function x2realloc called 0 returned 0% blocks executed 0%
    #####:   85:x2realloc (void *p, size_t *pn)
        -:   86:{
    #####:   87:  return x2nrealloc (p, pn, 1);
call    0 never executed
        -:   88:}
        -:   89:
        -:   90:/* Allocate N bytes of zeroed memory dynamically, with error checking.
        -:   91:   There's no need for xnzalloc (N, S), since it would be equivalent
        -:   92:   to xcalloc (N, S).  */
        -:   93:
        -:   94:void *
function xzalloc called 542 returned 100% blocks executed 100%
      542:   95:xzalloc (size_t n)
        -:   96:{
      542:   97:  return xcalloc (n, 1);
call    0 returned 100%
        -:   98:}
        -:   99:
        -:  100:/* Allocate zeroed memory for N elements of S bytes, with error
        -:  101:   checking.  S must be nonzero.  */
        -:  102:
        -:  103:void *
function xcalloc called 747 returned 100% blocks executed 80%
      747:  104:xcalloc (size_t n, size_t s)
        -:  105:{
        -:  106:  void *p;
        -:  107:  /* Test for overflow, since objects with size greater than
        -:  108:     PTRDIFF_MAX cause pointer subtraction to go awry.  Omit size-zero
        -:  109:     tests if HAVE_GNU_CALLOC, since GNU calloc never returns NULL if
        -:  110:     successful.  */
      747:  111:  if (xalloc_oversized (n, s)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      747:  112:      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  113:    xalloc_die ();
call    0 never executed
      747:  114:  return p;
        -:  115:}
        -:  116:
        -:  117:/* Clone an object P of size S, with error checking.  There's no need
        -:  118:   for xnmemdup (P, N, S), since xmemdup (P, N * S) works without any
        -:  119:   need for an arithmetic overflow check.  */
        -:  120:
        -:  121:void *
function xmemdup called 55 returned 100% blocks executed 100%
       55:  122:xmemdup (void const *p, size_t s)
        -:  123:{
       55:  124:  return memcpy (xmalloc (s), p, s);
call    0 returned 100%
        -:  125:}
        -:  126:
        -:  127:/* Clone STRING.  */
        -:  128:
        -:  129:char *
function xstrdup called 55 returned 100% blocks executed 100%
       55:  130:xstrdup (char const *string)
        -:  131:{
       55:  132:  return xmemdup (string, strlen (string) + 1);
call    0 returned 100%
        -:  133:}
