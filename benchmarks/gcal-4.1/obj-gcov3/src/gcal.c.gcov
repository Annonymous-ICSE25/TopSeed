        -:    0:Source:../../src/gcal.c
        -:    0:Programs:20
        -:    1:/*!
        -:    2:*  \file gcal.c
        -:    3:*  \brief Main part which controls the extended calendar program.
        -:    4:*/
        -:    5:/*
        -:    6:*  Copyright (c) 1994, 95, 96, 1997, 2000, 2011 Thomas Esken
        -:    7:*  Copyright (c) 2010, 2011, 2013, 2014 Free Software Foundation, Inc.
        -:    8:*
        -:    9:*  This software doesn't claim completeness, correctness or usability.
        -:   10:*  On principle I will not be liable for ANY damages or losses (implicit
        -:   11:*  or explicit), which result from using or handling my software.
        -:   12:*  If you use this software, you agree without any exception to this
        -:   13:*  agreement, which binds you LEGALLY !!
        -:   14:*
        -:   15:*  This program is free software; you can redistribute it and/or modify
        -:   16:*  it under the terms of the `GNU General Public License' as published by
        -:   17:*  the `Free Software Foundation'; either version 3, or (at your option)
        -:   18:*  any later version.
        -:   19:*
        -:   20:*  You should have received a copy of the `GNU General Public License'
        -:   21:*  along with this program; if not, write to the:
        -:   22:*
        -:   23:*/
        -:   24:
        -:   25:
        -:   26:/*
        -:   27:*  Include header files.
        -:   28:*/
        -:   29:#include "tailor.h"
        -:   30:#if HAVE_ASSERT_H
        -:   31:# include <assert.h>
        -:   32:#endif
        -:   33:#if HAVE_CTYPE_H
        -:   34:# include <ctype.h>
        -:   35:#endif
        -:   36:#if HAVE_LIMITS_H
        -:   37:# include <limits.h>
        -:   38:#endif
        -:   39:#if HAVE_UNISTD_H
        -:   40:# include <unistd.h>
        -:   41:#endif
        -:   42:#if (!HAVE_SIGNAL_H || !HAVE_SIGNAL) && HAVE_SYS_TYPES_H
        -:   43:/* Otherwise "gcal.h" includes <sys/types.h>. */
        -:   44:# include <sys/types.h>
        -:   45:#endif
        -:   46:#if HAVE_SYS_STAT_H
        -:   47:# include <sys/stat.h>
        -:   48:#endif
        -:   49:#ifdef GCAL_EPAGER
        -:   50:# include <fcntl.h>
        -:   51:# if !HAVE_DUP
        -:   52:#  define dup(old)        (fcntl(old, F_DUPFD, 0))
        -:   53:# endif
        -:   54:# if !HAVE_DUP2
        -:   55:#  define dup2(old, new)  (close(new), fcntl(old, F_DUPFD, new))
        -:   56:# endif
        -:   57:# if HAVE_SYS_WAIT_H
        -:   58:#  include <sys/wait.h>
        -:   59:# endif
        -:   60:#endif /* GCAL_EPAGER */
        -:   61:#include "common.h"
        -:   62:#if USE_RC
        -:   63:# include "rc-defs.h"
        -:   64:#endif /* USE_RC */
        -:   65:#include "globals.h"
        -:   66:#include "file-io.h"
        -:   67:#include "hd-defs.h"
        -:   68:#include "hd-data.h"
        -:   69:#include "hd-use.h"
        -:   70:#include "help.h"
        -:   71:#include "print.h"
        -:   72:#if USE_RC
        -:   73:# include "rc-use.h"
        -:   74:# include "rc-utils.h"
        -:   75:#endif /* USE_RC */
        -:   76:#include "tty.h"
        -:   77:#include "utils.h"
        -:   78:#include "gcal.h"
        -:   79:
        -:   80:
        -:   81:
        -:   82:/*
        -:   83:*  Set Borland/Turbo-C specific MSDOS stack length in case USE_RC is defined  ;<
        -:   84:*/
        -:   85:#if USE_RC
        -:   86:# if defined(MSDOS) && defined(__TURBOC__)
        -:   87:#  include <dos.h>
        -:   88:extern Uint _stklen = 0x4000;
        -:   89:# endif
        -:   90:#endif
        -:   91:
        -:   92:
        -:   93:
        -:   94:/*
        -:   95:*  static functions prototypes.
        -:   96:*/
        -:   97:__BEGIN_DECLARATIONS
        -:   98:/*
        -:   99:************************************************** Defined in `gcal.c'.
        -:  100:*/
        -:  101:static Bool
        -:  102:  is_correct_date_format __P_ ((char *format_txt,
        -:  103:				Bool * use_day_suffix,
        -:  104:				Bool * use_short3_day_name,
        -:  105:				Bool * use_day_zeroleaded,
        -:  106:				Bool * use_year_zeroleaded));
        -:  107:static void
        -:  108:  rearrange_argv __P_ ((const char *opt_list, int *argc, char *argv[]));
        -:  109:static void check_command_line __P_ ((int argc, char *argv[]));
        -:  110:static void build_month_list __P_ ((char *argv[]));
        -:  111:static void eliminate_invalid_data __P_ ((void));
        -:  112:static void pseudo_blank_conversion __P_ ((char **text));
        -:  113:#if USE_RC
        -:  114:static int further_check __P_ ((char **option));
        -:  115:#endif
        -:  116:__END_DECLARATIONS
        -:  117:/*
        -:  118:*  GLOBAL variables definitions.
        -:  119:*/
        -:  120:
        -:  121:/*! Number of days in Julian/Gregorian month. */
        -:  122:const int dvec[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
        -:  123:
        -:  124:/*! Number of past days of Julian/Gregorian month. */
        -:  125:const int mvec[] = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
        -:  126:
        -:  127:/*!
        -:  128:   The long option table is a vector of `Lopt_struct' terminated by an element
        -:  129:     containing a `long_name' which is zero!
        -:  130:   All initialization strings of the structure member `long_name' CAN be
        -:  131:     entered case insensitive (it is recommended to use them in lower-case
        -:  132:     letters only),  but in an ascending lexical sort order, and the table
        -:  133:     MUST be initialized by distinguishable texts given to the structure
        -:  134:     member `long_name'.
        -:  135:   The table structure is as follows:
        -:  136:     `symbolic_name': The symbolic name of the long option (a distingushable
        -:  137:                        number [int]).
        -:  138:     `long_name':     The full name of the long option (case insensitive.)
        -:  139:     `short_name':    A list of short options (maximum 5 (==LARG_MAX-1))
        -:  140:                        terminated by NULL, its order corresponds to the order
        -:  141:                        of the field `largs' (case sensitive), means "a" is
        -:  142:                        another option than "A".
        -:  143:     `larg_mode':     States whether an option requires an argument or not.
        -:  144:                        LARG_NO or 0 means:
        -:  145:                          Option may not have an argument, e.g. `--foo'
        -:  146:                        LARG_NO_OR_ONE or 1 means:
        -:  147:                          Option may have an argument,
        -:  148:                          which is either SPECIAL or GIVEN, e.g. `--foo'
        -:  149:                          or `--foo=BAR' or `--foo=ARG'
        -:  150:                        LARG_ONE or 2 means:
        -:  151:                          Option must have an argument,
        -:  152:                          which must be either SPECIAL if one or more `largs'
        -:  153:                          are defined, or which must be GIVEN if no `largs'
        -:  154:                          are defined, e.g. `--foo=BAR' or `--foo=ARG'
        -:  155:                        LARG_ONE_OR_ARG or 3 means:
        -:  156:                          Option must have an argument,
        -:  157:                          which could be either SPECIAL if one or more `largs'
        -:  158:                          are defined, or which could be GIVEN if one ore more
        -:  159:                          `largs' are defined, but none of these `largs' match
        -:  160:                          the GIVEN argument, e.g. `--foo=BAR' or `--foo=ARG'
        -:  161:                        If this field is set to LARG_NO_OR_ONE and NO argument
        -:  162:                        trails the option, the `short_name[0]' contains
        -:  163:                        the default value of the argument and is returned!
        -:  164:                        It's an ILLEGAL case to set this field to
        -:  165:                        LARG_ONE_OR_ARG and NO `largs' are defined in the
        -:  166:                        `lopt[]' table, but one or more `short_name' entries!
        -:  167:     `largs':         A list of possible SPECIAL arguments (maximum 5
        -:  168:                        (==LARG_MAX-1)) terminated by NULL, from which only
        -:  169:                        one may be selected at a time.
        -:  170:                      If its first element is set to NULL, any GIVEN argument
        -:  171:                        is allowed, otherwise only one of the listed SPECIAL
        -:  172:                        arguments.
        -:  173:                      The SPECIAL arguments may be abbreviated in case this
        -:  174:                        is done unambigously; and they can be given case
        -:  175:                        insensitive.
        -:  176:*/
        -:  177:const Lopt_struct lopt[] = {
        -:  178:/*
        -:  179:  { int symbolic_name, char *long_name, char *short_name[LARG_MAX], int larg_mode, char *largs[LARG_MAX] }
        -:  180:*/
        -:  181:#if USE_RC
        -:  182:  {
        -:  183:   SYM_ADJUST_VALUE,
        -:  184:   "adjust-value",
        -:  185:   {NULL},
        -:  186:   LARG_ONE,
        -:  187:   {NULL}
        -:  188:   },
        -:  189:  {
        -:  190:   SYM_ALTERNATIVE_FORMAT,
        -:  191:   "alternative-format",
        -:  192:   {"A", NULL},
        -:  193:   LARG_NO,
        -:  194:   {NULL}
        -:  195:   },
        -:  196:#endif
        -:  197:  {
        -:  198:   SYM_ASTRONOMICAL_HDY,
        -:  199:   "astronomical-holidays",
        -:  200:   {NULL},
        -:  201:   LARG_NO,
        -:  202:   {NULL}
        -:  203:   },
        -:  204:#if USE_RC
        -:  205:  {
        -:  206:   SYM_ATMOSPHERE,
        -:  207:   "atmosphere",
        -:  208:   {NULL},
        -:  209:   LARG_ONE,
        -:  210:   {NULL}
        -:  211:   },
        -:  212:#endif
        -:  213:  {
        -:  214:   SYM_BAHAI_HDY,
        -:  215:   "bahai-holidays",
        -:  216:   {NULL},
        -:  217:   LARG_NO,
        -:  218:   {NULL}
        -:  219:   },
        -:  220:  {
        -:  221:   SYM_BAHAI_MTH,
        -:  222:   "bahai-months",
        -:  223:   {NULL},
        -:  224:   LARG_NO,
        -:  225:   {NULL}
        -:  226:   },
        -:  227:#if USE_RC
        -:  228:  {
        -:  229:   SYM_BIORHYTHM_AXIS_LEN,
        -:  230:   "biorhythm-axis",
        -:  231:   {NULL},
        -:  232:   LARG_ONE,
        -:  233:   {NULL}
        -:  234:   },
        -:  235:#endif
        -:  236:  {
        -:  237:   SYM_BLOCKS,
        -:  238:   "blocks",
        -:  239:   {"b", NULL},
        -:  240:   LARG_ONE,
        -:  241:   {NULL}
        -:  242:   },
        -:  243:  {
        -:  244:   SYM_CALENDAR_DATES,
        -:  245:   "calendar-dates",
        -:  246:   {"j", "jb", NULL},
        -:  247:   LARG_ONE,
        -:  248:   {"special", "both", NULL}
        -:  249:   },
        -:  250:  {
        -:  251:   SYM_CC_HDY,
        -:  252:   "cc-holidays",
        -:  253:   {"q", NULL},
        -:  254:   LARG_ONE,
        -:  255:   {NULL}
        -:  256:   },
        -:  257:  {
        -:  258:   SYM_CELTIC_HDY,
        -:  259:   "celtic-holidays",
        -:  260:   {NULL},
        -:  261:   LARG_NO,
        -:  262:   {NULL}
        -:  263:   },
        -:  264:  {
        -:  265:   SYM_CHINESE_FLEXIBLE_HDY,
        -:  266:   "chinese-flexible-holidays",
        -:  267:   {NULL},
        -:  268:   LARG_NO,
        -:  269:   {NULL}
        -:  270:   },
        -:  271:  {
        -:  272:   SYM_CHINESE_FLEXIBLE_MTH,
        -:  273:   "chinese-flexible-months",
        -:  274:   {NULL},
        -:  275:   LARG_NO,
        -:  276:   {NULL}
        -:  277:   },
        -:  278:  {
        -:  279:   SYM_CHINESE_HDY,
        -:  280:   "chinese-holidays",
        -:  281:   {NULL},
        -:  282:   LARG_NO,
        -:  283:   {NULL}
        -:  284:   },
        -:  285:  {
        -:  286:   SYM_CHINESE_MTH,
        -:  287:   "chinese-months",
        -:  288:   {NULL},
        -:  289:   LARG_NO,
        -:  290:   {NULL}
        -:  291:   },
        -:  292:  {
        -:  293:   SYM_CHRISTIAN_HDY,
        -:  294:   "christian-holidays",
        -:  295:   {NULL},
        -:  296:   LARG_NO,
        -:  297:   {NULL}
        -:  298:   },
        -:  299:  {
        -:  300:   SYM_COPTIC_MTH,
        -:  301:   "coptic-months",
        -:  302:   {NULL},
        -:  303:   LARG_NO,
        -:  304:   {NULL}
        -:  305:   },
        -:  306:  {
        -:  307:   SYM_LICENSE2,
        -:  308:   "copyleft",
        -:  309:   {"L", NULL},
        -:  310:   LARG_NO,
        -:  311:   {NULL}
        -:  312:   },
        -:  313:  {
        -:  314:   SYM_LICENSE3,
        -:  315:   "copyright",
        -:  316:   {"L", NULL},
        -:  317:   LARG_NO,
        -:  318:   {NULL}
        -:  319:   },
        -:  320:#if USE_RC
        -:  321:  {
        -:  322:   SYM_CYCLE_END,
        -:  323:   "cycle-end",
        -:  324:   {NULL},
        -:  325:   LARG_ONE,
        -:  326:   {NULL}
        -:  327:   },
        -:  328:  {
        -:  329:   SYM_CYCLE_STEP,
        -:  330:   "cycle-step",
        -:  331:   {NULL},
        -:  332:   LARG_ONE,
        -:  333:   {NULL}
        -:  334:   },
        -:  335:#endif
        -:  336:  {
        -:  337:   SYM_DATE_FORMAT,
        -:  338:   "date-format",
        -:  339:   {"!\001", "!\002", "!\003", /* e.g.: "!\004", */ "!", NULL},
        -:  340:   LARG_ONE_OR_ARG,
        -:  341:   {CC_DE, CC_US, CC_GB,	/* e.g.: "OTHER", */
        -:  342:    /*
        -:  343:     *** Translators, please translate this as a fixed 3-character text.
        -:  344:     *** This text should be a proper abbreviation of "ARGUMENT".
        -:  345:     */
        -:  346:    N_("ARG"), NULL}
        -:  347:   },
        -:  348:#if USE_RC
        -:  349:  {
        -:  350:   SYM_DATE_VARIABLE,
        -:  351:   "date-variable",
        -:  352:   {"v", NULL},
        -:  353:   LARG_ONE,
        -:  354:   {NULL}
        -:  355:   },
        -:  356:#endif
        -:  357:  {
        -:  358:   SYM_DEBUG,
        -:  359:   "debug",
        -:  360:   {"0", "1", "2", "3", "4", NULL},
        -:  361:   LARG_NO_OR_ONE,
        -:  362:   {"internal", "handled", "unhandled", "all", "abort", NULL}
        -:  363:   },
        -:  364:#if USE_RC
        -:  365:  {
        -:  366:   SYM_DESC_FIXED_DATES_LIST,
        -:  367:   "descending-fixed-dates",
        -:  368:   {"c-", "C-", NULL},
        -:  369:   LARG_NO_OR_ONE,
        -:  370:   {"short", "long", NULL}
        -:  371:   },
        -:  372:#endif
        -:  373:  {
        -:  374:   SYM_DESC_HOLIDAY_LIST,
        -:  375:   "descending-holiday-list",
        -:  376:   {"n-", "N-", NULL},
        -:  377:   LARG_NO_OR_ONE,
        -:  378:   {"long", "short", NULL}
        -:  379:   },
        -:  380:  {
        -:  381:   SYM_DISABLE_HIGHLIGHTING,
        -:  382:   "disable-highlighting",
        -:  383:   {"Hno", NULL},
        -:  384:   LARG_NO,
        -:  385:   {NULL}
        -:  386:   },
        -:  387:#if USE_RC
        -:  388:  {
        -:  389:   SYM_END_OF_MONTH,
        -:  390:   "end-of-month",
        -:  391:   {"m+", NULL},
        -:  392:   LARG_NO,
        -:  393:   {NULL}
        -:  394:   },
        -:  395:  {
        -:  396:   SYM_END_OF_WEEK,
        -:  397:   "end-of-week",
        -:  398:   {"w+", NULL},
        -:  399:   LARG_NO,
        -:  400:   {NULL}
        -:  401:   },
        -:  402:  {
        -:  403:   SYM_END_OF_YEAR,
        -:  404:   "end-of-year",
        -:  405:   {"y+", NULL},
        -:  406:   LARG_NO,
        -:  407:   {NULL}
        -:  408:   },
        -:  409:#endif
        -:  410:  {
        -:  411:   SYM_ETHIOPIC_MTH,
        -:  412:   "ethiopic-months",
        -:  413:   {NULL},
        -:  414:   LARG_NO,
        -:  415:   {NULL}
        -:  416:   },
        -:  417:#if USE_RC
        -:  418:  {
        -:  419:   SYM_EXCLUDE_RC_TITLE,
        -:  420:   "exclude-fixed-dates-list-title",
        -:  421:   {"x", NULL},
        -:  422:   LARG_NO,
        -:  423:   {NULL}
        -:  424:   },
        -:  425:#endif
        -:  426:  {
        -:  427:   SYM_EXCLUDE_HD_TITLE,
        -:  428:   "exclude-holiday-list-title",
        -:  429:   {"X", NULL},
        -:  430:   LARG_NO,
        -:  431:   {NULL}
        -:  432:   },
        -:  433:#if USE_RC
        -:  434:  {
        -:  435:   SYM_EXECUTE_COMMAND,
        -:  436:   "execute-command",
        -:  437:   {NULL},
        -:  438:   LARG_NO,
        -:  439:   {NULL}
        -:  440:   },
        -:  441:#endif
        -:  442:  {
        -:  443:   SYM_EXIT_STAT_HELP_NON_ZERO,
        -:  444:   "exit-status-help-non-zero",
        -:  445:   {NULL},
        -:  446:   LARG_NO,
        -:  447:   {NULL}
        -:  448:   },
        -:  449:#if USE_RC
        -:  450:  {
        -:  451:   SYM_extern_static_DVARS,
        -:  452:   "export-date-variables",
        -:  453:   {NULL},
        -:  454:   LARG_NO,
        -:  455:   {NULL}
        -:  456:   },
        -:  457:  {
        -:  458:   SYM_extern_static_TVARS,
        -:  459:   "export-text-variables",
        -:  460:   {NULL},
        -:  461:   LARG_NO,
        -:  462:   {NULL}
        -:  463:   },
        -:  464:  {
        -:  465:   SYM_FILTER_DAY,
        -:  466:   "filter-day",
        -:  467:   {"D", NULL},
        -:  468:   LARG_ONE,
        -:  469:   {NULL}
        -:  470:   },
        -:  471:  {
        -:  472:   SYM_FILTER_PERIOD,
        -:  473:   "filter-period",
        -:  474:   {"P", NULL},
        -:  475:   LARG_ONE,
        -:  476:   {NULL}
        -:  477:   },
        -:  478:  {
        -:  479:   SYM_FILTER_TEXT,
        -:  480:   "filter-text",
        -:  481:   {"I", NULL},
        -:  482:   LARG_ONE,
        -:  483:   {NULL}
        -:  484:   },
        -:  485:  {
        -:  486:   SYM_FIXED_DATES,
        -:  487:   "fixed-dates",
        -:  488:   {"jc", "jcb", NULL},
        -:  489:   LARG_ONE,
        -:  490:   {"special", "both", NULL}
        -:  491:   },
        -:  492:#endif
        -:  493:  {
        -:  494:   SYM_FORCE_HIGHLIGHTING,
        -:  495:   "force-highlighting",
        -:  496:   {"Hyes", NULL},
        -:  497:   LARG_NO,
        -:  498:   {NULL}
        -:  499:   },
        -:  500:  {
        -:  501:   SYM_FRENCH_REVOLUTIONARY_MTH,
        -:  502:   "french-revolutionary-months",
        -:  503:   {NULL},
        -:  504:   LARG_NO,
        -:  505:   {NULL}
        -:  506:   },
        -:  507:  {
        -:  508:   SYM_GREG_REFORM,
        -:  509:   "gregorian-reform",
        -:  510:   {"$\001", "$\002", "$\003", "$\004", "$", NULL},
        -:  511:   LARG_ONE_OR_ARG,
        -:  512:   {"1582", "1700", "1752", "1753",
        -:  513:    /*
        -:  514:     *** Translators, please translate this as a fixed 3-character text.
        -:  515:     *** This text should be a proper abbreviation of "ARGUMENT".
        -:  516:     */
        -:  517:    N_("ARG"), NULL}
        -:  518:   },
        -:  519:#if USE_RC
        -:  520:  {
        -:  521:   SYM_GROUPING_TEXT,
        -:  522:   "grouping-text",
        -:  523:   {"g", NULL},
        -:  524:   LARG_NO_OR_ONE,
        -:  525:   {NULL}
        -:  526:   },
        -:  527:  {
        -:  528:   SYM_HEADING_TEXT,
        -:  529:   "heading-text",
        -:  530:   {NULL},
        -:  531:   LARG_ONE,
        -:  532:   {NULL}
        -:  533:   },
        -:  534:#endif
        -:  535:  {
        -:  536:   SYM_HEBREW_HDY,
        -:  537:   "hebrew-holidays",
        -:  538:   {NULL},
        -:  539:   LARG_NO,
        -:  540:   {NULL}
        -:  541:   },
        -:  542:  {
        -:  543:   SYM_HEBREW_MTH,
        -:  544:   "hebrew-months",
        -:  545:   {NULL},
        -:  546:   LARG_NO,
        -:  547:   {NULL}
        -:  548:   },
        -:  549:  {
        -:  550:   SYM_LONG_HELP1,
        -:  551:   "help",
        -:  552:   {"h", NULL},
        -:  553:   LARG_NO,
        -:  554:   {NULL}
        -:  555:   },
        -:  556:#if USE_RC
        -:  557:  {
        -:  558:   SYM_HERE_FILE,
        -:  559:   "here",
        -:  560:   {"#", NULL},
        -:  561:   LARG_ONE,
        -:  562:   {NULL}
        -:  563:   },
        -:  564:#endif
        -:  565:  {
        -:  566:   SYM_HIGHLIGHTING,
        -:  567:   "highlighting",
        -:  568:   {"H", NULL},
        -:  569:   LARG_ONE,
        -:  570:   {NULL}
        -:  571:   },
        -:  572:  {
        -:  573:   SYM_HOLIDAY_DATES,
        -:  574:   "holiday-dates",
        -:  575:   {"jn", "jnb", NULL},
        -:  576:   LARG_ONE,
        -:  577:   {"special", "both", NULL}
        -:  578:   },
        -:  579:  {
        -:  580:   SYM_HOLIDAY_LIST,
        -:  581:   "holiday-list",
        -:  582:   {"n", "N", NULL},
        -:  583:   LARG_NO_OR_ONE,
        -:  584:   {"long", "short", NULL}
        -:  585:   },
        -:  586:#if USE_RC
        -:  587:  {
        -:  588:   SYM_IGNORE_CASE,
        -:  589:   "ignore-case",
        -:  590:   {NULL},
        -:  591:   LARG_NO,
        -:  592:   {NULL}
        -:  593:   },
        -:  594:  {
        -:  595:   SYM_INCLUDE_CONS_NUMBER,
        -:  596:   "include-consecutive-number",
        -:  597:   {"z", NULL},
        -:  598:   LARG_NO,
        -:  599:   {NULL}
        -:  600:   },
        -:  601:  {
        -:  602:   SYM_INCLUDE_HOLIDAY,
        -:  603:   "include-holidays",
        -:  604:   {"e", "E", NULL},
        -:  605:   LARG_NO_OR_ONE,
        -:  606:   {"long", "short", NULL}
        -:  607:   },
        -:  608:  {
        -:  609:   SYM_INCLUDE_FILENAME,
        -:  610:   "include-resource-file-name",
        -:  611:   {"a", NULL},
        -:  612:   LARG_NO,
        -:  613:   {NULL}
        -:  614:   },
        -:  615:  {
        -:  616:   SYM_INCLUDE_TODAY,
        -:  617:   "include-today",
        -:  618:   {"d", NULL},
        -:  619:   LARG_NO,
        -:  620:   {NULL}
        -:  621:   },
        -:  622:  {
        -:  623:   SYM_INCLUDE_WEEK_NUMBER,
        -:  624:   "include-week-number",
        -:  625:   {"k", NULL},
        -:  626:   LARG_NO,
        -:  627:   {NULL}
        -:  628:   },
        -:  629:#endif
        -:  630:  {
        -:  631:   SYM_INDIAN_CIVIL_MTH,
        -:  632:   "indian-civil-months",
        -:  633:   {NULL},
        -:  634:   LARG_NO,
        -:  635:   {NULL}
        -:  636:   },
        -:  637:  {
        -:  638:   SYM_ISLAMIC_HDY,
        -:  639:   "islamic-civil-holidays",
        -:  640:   {NULL},
        -:  641:   LARG_NO,
        -:  642:   {NULL}
        -:  643:   },
        -:  644:  {
        -:  645:   SYM_ISLAMIC_MTH,
        -:  646:   "islamic-civil-months",
        -:  647:   {NULL},
        -:  648:   LARG_NO,
        -:  649:   {NULL}
        -:  650:   },
        -:  651:  {
        -:  652:   SYM_ISO_WEEK_NUMBER,
        -:  653:   "iso-week-number",
        -:  654:   {"y", "n", NULL},
        -:  655:   LARG_ONE,
        -:  656:   {"yes", "no", NULL}
        -:  657:   },
        -:  658:  {
        -:  659:   SYM_JAPANESE_FLEXIBLE_HDY,
        -:  660:   "japanese-flexible-holidays",
        -:  661:   {NULL},
        -:  662:   LARG_NO,
        -:  663:   {NULL}
        -:  664:   },
        -:  665:  {
        -:  666:   SYM_JAPANESE_FLEXIBLE_MTH,
        -:  667:   "japanese-flexible-months",
        -:  668:   {NULL},
        -:  669:   LARG_NO,
        -:  670:   {NULL}
        -:  671:   },
        -:  672:  {
        -:  673:   SYM_JAPANESE_HDY,
        -:  674:   "japanese-holidays",
        -:  675:   {NULL},
        -:  676:   LARG_NO,
        -:  677:   {NULL}
        -:  678:   },
        -:  679:  {
        -:  680:   SYM_JAPANESE_MTH,
        -:  681:   "japanese-months",
        -:  682:   {NULL},
        -:  683:   LARG_NO,
        -:  684:   {NULL}
        -:  685:   },
        -:  686:#if USE_RC
        -:  687:  {
        -:  688:   SYM_LEAP_DAY,
        -:  689:   "leap-day",
        -:  690:   {"f", "m", NULL},
        -:  691:   LARG_ONE,
        -:  692:   {"february", "march", NULL}
        -:  693:   },
        -:  694:#endif
        -:  695:  {
        -:  696:   SYM_LICENSE1,
        -:  697:   "license",
        -:  698:   {"L", NULL},
        -:  699:   LARG_NO,
        -:  700:   {NULL}
        -:  701:   },
        -:  702:#if USE_RC
        -:  703:  {
        -:  704:   SYM_LIMIT,
        -:  705:   "limit",
        -:  706:   {NULL},
        -:  707:   LARG_NO,
        -:  708:   {NULL}
        -:  709:   },
        -:  710:  {
        -:  711:   SYM_LIST_MODE,
        -:  712:   "list-mode",
        -:  713:   {"l", NULL},
        -:  714:   LARG_NO,
        -:  715:   {NULL}
        -:  716:   },
        -:  717:  {
        -:  718:   SYM_FIXED_DATES_LIST,
        -:  719:   "list-of-fixed-dates",
        -:  720:   {"c", "C", NULL},
        -:  721:   LARG_NO_OR_ONE,
        -:  722:   {"short", "long", NULL}
        -:  723:   },
        -:  724:#endif
        -:  725:  {
        -:  726:   SYM_LONG_HELP1,
        -:  727:   "long-help",
        -:  728:   {"hh", NULL},
        -:  729:   LARG_NO_OR_ONE,
        -:  730:   {NULL}
        -:  731:   },
        -:  732:#ifdef GCAL_EMAIL
        -:  733:  {
        -:  734:   SYM_MAIL,
        -:  735:   "mail",
        -:  736:   {NULL},
        -:  737:   LARG_NO_OR_ONE,
        -:  738:   {NULL}
        -:  739:   },
        -:  740:#endif
        -:  741:#if USE_RC
        -:  742:  {
        -:  743:   SYM_MONTH,
        -:  744:   "month",
        -:  745:   {"m", NULL},
        -:  746:   LARG_NO,
        -:  747:   {NULL}
        -:  748:   },
        -:  749:  {
        -:  750:   SYM_MOONIMAGE_LINES,
        -:  751:   "moonimage-lines",
        -:  752:   {NULL},
        -:  753:   LARG_ONE,
        -:  754:   {NULL}
        -:  755:   },
        -:  756:#endif
        -:  757:  {
        -:  758:   SYM_MULTICULTURAL_NEW_YEAR_HDY,
        -:  759:   "multicultural-new-year-holidays",
        -:  760:   {NULL},
        -:  761:   LARG_NO,
        -:  762:   {NULL}
        -:  763:   },
        -:  764:  {
        -:  765:   SYM_OLD_ARMENIC_MTH,
        -:  766:   "old-armenic-months",
        -:  767:   {NULL},
        -:  768:   LARG_NO,
        -:  769:   {NULL}
        -:  770:   },
        -:  771:  {
        -:  772:   SYM_OLD_EGYPTIC_MTH,
        -:  773:   "old-egyptic-months",
        -:  774:   {NULL},
        -:  775:   LARG_NO,
        -:  776:   {NULL}
        -:  777:   },
        -:  778:#if USE_RC
        -:  779:  {
        -:  780:   SYM_OMIT_DATE_PART,
        -:  781:   "omit-multiple-date-part",
        -:  782:   {"o", NULL},
        -:  783:   LARG_NO,
        -:  784:   {NULL}
        -:  785:   },
        -:  786:#endif
        -:  787:  {
        -:  788:   SYM_ORTHODOX_CALENDAR,
        -:  789:   "orthodox-calendar",
        -:  790:   {"O", NULL},
        -:  791:   LARG_NO,
        -:  792:   {NULL}
        -:  793:   },
        -:  794:  {
        -:  795:   SYM_ORTHODOX_NEW_HDY,
        -:  796:   "orthodox-new-holidays",
        -:  797:   {NULL},
        -:  798:   LARG_NO,
        -:  799:   {NULL}
        -:  800:   },
        -:  801:  {
        -:  802:   SYM_ORTHODOX_OLD_HDY,
        -:  803:   "orthodox-old-holidays",
        -:  804:   {NULL},
        -:  805:   LARG_NO,
        -:  806:   {NULL}
        -:  807:   },
        -:  808:#if USE_PAGER
        -:  809:  {
        -:  810:   SYM_PAGER,
        -:  811:   "pager",
        -:  812:   {"p", NULL},
        -:  813:   LARG_NO,
        -:  814:   {NULL}
        -:  815:   },
        -:  816:#endif
        -:  817:#if USE_RC
        -:  818:  {
        -:  819:   SYM_PERIOD,
        -:  820:   "period-of-fixed-dates",
        -:  821:   {"c", NULL},
        -:  822:   LARG_ONE,
        -:  823:   {NULL}
        -:  824:   },
        -:  825:#endif
        -:  826:  {
        -:  827:   SYM_PERSIAN_HDY,
        -:  828:   "persian-jalaali-holidays",
        -:  829:   {NULL},
        -:  830:   LARG_NO,
        -:  831:   {NULL}
        -:  832:   },
        -:  833:  {
        -:  834:   SYM_PERSIAN_MTH,
        -:  835:   "persian-jalaali-months",
        -:  836:   {NULL},
        -:  837:   LARG_NO,
        -:  838:   {NULL}
        -:  839:   },
        -:  840:#if USE_RC
        -:  841:  {
        -:  842:   SYM_PRECISE,
        -:  843:   "precise",
        -:  844:   {NULL},
        -:  845:   LARG_NO,
        -:  846:   {NULL}
        -:  847:   },
        -:  848:  {
        -:  849:   SYM_RESOURCE_FILE,
        -:  850:   "resource-file",
        -:  851:   {"f", NULL},
        -:  852:   LARG_ONE,
        -:  853:   {NULL}
        -:  854:   },
        -:  855:#endif
        -:  856:  {
        -:  857:   SYM_RESPONSE_FILE,
        -:  858:   "response-file",
        -:  859:   {"R", NULL},
        -:  860:   LARG_ONE,
        -:  861:   {NULL}
        -:  862:   },
        -:  863:#if USE_RC
        -:  864:  {
        -:  865:   SYM_REVERT_MATCH,
        -:  866:   "revert-match",
        -:  867:   {NULL},
        -:  868:   LARG_NO,
        -:  869:   {NULL}
        -:  870:   },
        -:  871:#endif
        -:  872:#ifdef GCAL_SHELL
        -:  873:  {
        -:  874:   SYM_SCRIPT_FILE,
        -:  875:   "shell-script",
        -:  876:   {"S", NULL},
        -:  877:   LARG_ONE,
        -:  878:   {NULL}
        -:  879:   },
        -:  880:#endif
        -:  881:#if USE_RC
        -:  882:  {
        -:  883:   SYM_START_OF_MONTH,
        -:  884:   "start-of-month",
        -:  885:   {"m-", NULL},
        -:  886:   LARG_NO,
        -:  887:   {NULL}
        -:  888:   },
        -:  889:  {
        -:  890:   SYM_START_OF_WEEK,
        -:  891:   "start-of-week",
        -:  892:   {"w-", NULL},
        -:  893:   LARG_NO,
        -:  894:   {NULL}
        -:  895:   },
        -:  896:  {
        -:  897:   SYM_START_OF_YEAR,
        -:  898:   "start-of-year",
        -:  899:   {"y-", NULL},
        -:  900:   LARG_NO,
        -:  901:   {NULL}
        -:  902:   },
        -:  903:#endif
        -:  904:  {
        -:  905:   SYM_STARTING_DAY,
        -:  906:   "starting-day",
        -:  907:   {"s", NULL},
        -:  908:   LARG_ONE,
        -:  909:   {NULL}
        -:  910:   },
        -:  911:  {
        -:  912:   SYM_SUPPRESS_CALENDAR,
        -:  913:   "suppress-calendar",
        -:  914:   {"u", NULL},
        -:  915:   LARG_NO,
        -:  916:   {NULL}
        -:  917:   },
        -:  918:#if USE_RC
        -:  919:  {
        -:  920:   SYM_SUPPRESS_DATE_PART,
        -:  921:   "suppress-date-part",
        -:  922:   {"U", NULL},
        -:  923:   LARG_NO,
        -:  924:   {NULL}
        -:  925:   },
        -:  926:  {
        -:  927:   SYM_SUPPRESS_FDLIST_SEP,
        -:  928:   "suppress-fixed-dates-list-separator",
        -:  929:   {"Q", NULL},
        -:  930:   LARG_NO,
        -:  931:   {NULL}
        -:  932:   },
        -:  933:#endif /* USE_RC */
        -:  934:  {
        -:  935:   SYM_SUPPRESS_HDLIST_SEP,
        -:  936:   "suppress-holiday-list-separator",
        -:  937:   {"G", NULL},
        -:  938:   LARG_NO,
        -:  939:   {NULL}
        -:  940:   },
        -:  941:#if USE_RC
        -:  942:  {
        -:  943:   SYM_SUPPRESS_TEXT_PART,
        -:  944:   "suppress-text-part",
        -:  945:   {"J", NULL},
        -:  946:   LARG_NO,
        -:  947:   {NULL}
        -:  948:   },
        -:  949:  {
        -:  950:   SYM_TEXT_VARIABLE,
        -:  951:   "text-variable",
        -:  952:   {"r", NULL},
        -:  953:   LARG_ONE,
        -:  954:   {NULL}
        -:  955:   },
        -:  956:#endif
        -:  957:  {
        -:  958:   SYM_TIME_OFFSET,
        -:  959:   "time-offset",
        -:  960:   {NULL},
        -:  961:   LARG_ONE,
        -:  962:   {NULL}
        -:  963:   },
        -:  964:#if USE_RC
        -:  965:  {
        -:  966:   SYM_TODAY,
        -:  967:   "today",
        -:  968:   {"c", NULL},
        -:  969:   LARG_NO,
        -:  970:   {NULL}
        -:  971:   },
        -:  972:  {
        -:  973:   SYM_TOMORROW,
        -:  974:   "tomorrow",
        -:  975:   {"t", NULL},
        -:  976:   LARG_NO,
        -:  977:   {NULL}
        -:  978:   },
        -:  979:#endif
        -:  980:  {
        -:  981:   SYM_TRANSFORM_YEAR,
        -:  982:   "transform-year",
        -:  983:   {NULL},
        -:  984:   LARG_ONE,
        -:  985:   {NULL}
        -:  986:   },
        -:  987:  {
        -:  988:   SYM_TRANSLATE_STRING,
        -:  989:   "translate-string",
        -:  990:   {NULL},
        -:  991:   LARG_ONE,
        -:  992:   {NULL}
        -:  993:   },
        -:  994:  {
        -:  995:   SYM_TYPE_OF_CALENDAR,
        -:  996:   "type",
        -:  997:   {"i", "i-", NULL},
        -:  998:   LARG_ONE,
        -:  999:   {"special", "standard", NULL}
        -: 1000:   },
        -: 1001:  {
        -: 1002:   SYM_LONG_HELP2,
        -: 1003:   "usage",
        -: 1004:   {"hh", NULL},
        -: 1005:   LARG_NO_OR_ONE,
        -: 1006:   {NULL}
        -: 1007:   },
        -: 1008:  {
        -: 1009:   SYM_VERSION,
        -: 1010:   "version",
        -: 1011:   {"V", NULL},
        -: 1012:   LARG_NO,
        -: 1013:   {NULL}
        -: 1014:   },
        -: 1015:#if USE_RC
        -: 1016:  {
        -: 1017:   SYM_WEEK,
        -: 1018:   "week",
        -: 1019:   {"w", NULL},
        -: 1020:   LARG_NO,
        -: 1021:   {NULL}
        -: 1022:   },
        -: 1023:#endif
        -: 1024:  {
        -: 1025:   SYM_CALENDAR_WITH_WEEK_NUMBER,
        -: 1026:   "with-week-number",
        -: 1027:   {"K", NULL},
        -: 1028:   LARG_NO,
        -: 1029:   {NULL}
        -: 1030:   },
        -: 1031:#if USE_RC
        -: 1032:  {
        -: 1033:   SYM_YEAR,
        -: 1034:   "year",
        -: 1035:   {"y", NULL},
        -: 1036:   LARG_NO,
        -: 1037:   {NULL}
        -: 1038:   },
        -: 1039:  {
        -: 1040:   SYM_ZERO_DATES,
        -: 1041:   "zero-dates-only",
        -: 1042:   {"Z", NULL},
        -: 1043:   LARG_NO,
        -: 1044:   {NULL}
        -: 1045:   },
        -: 1046:#endif
        -: 1047:  {
        -: 1048:   SYM_ZODIACAL_MARKER_HDY,
        -: 1049:   "zodiacal-marker-holidays",
        -: 1050:   {NULL},
        -: 1051:   LARG_NO,
        -: 1052:   {NULL}
        -: 1053:   },
        -: 1054:  {SYM_NIL, NULL, {NULL}, LARG_NO, {NULL}}
        -: 1055:};
        -: 1056:
        -: 1057:/*!
        -: 1058:   The supported date formats table is a vector of `Df_struct'
        -: 1059:     terminated by an element containing a `df_info' which is zero!
        -: 1060:   If you extend this table by some more date formats, please extend the
        -: 1061:     according `lopt[]' table entry for the `--date-format' long-style option,
        -: 1062:     too!  If you do so, remember that each new entry in the `lopt[]' table
        -: 1063:     for SYM_DATE_FORMAT must have a new `short_name' text
        -: 1064:     "!\NEXT-CONSECUTIVE-OCTAL-NUMBER-OF-THIS-NEW-INDEX" and a corresponding
        -: 1065:     identifying text in `largs' (with a length of less than 6 characters).
        -: 1066:     The simple "!" text in the `short_name' member and its corresponding
        -: 1067:     LARG_TXT must always trail any new entry, which will be possibly added
        -: 1068:     in future.
        -: 1069:*/
        -: 1070:Df_struct supported_date_format[LARG_MAX - 1] = {
        -: 1071:/*
        -: 1072:  { char *df_id, char *df_info, char *df_format },
        -: 1073:*/
        -: 1074:  {CC_DE, N_("Germany"), "%<2#K,  %1%>2*D%2 %<3#U %>04*Y"},
        -: 1075:  {CC_US, N_("U.S.A."), "%<3#K,  %<3#U %1%>2&*D%2 %>04*Y"},
        -: 1076:  {CC_GB, N_("Great Britain"), "%<3#K,  %1%>2&*D%2 %<3#U %>04*Y"},
        -: 1077:/*
        -: 1078:   The next table field can be provided with further data!
        -: 1079:   If more "burned-in" data is needed, LARG_MAX must be increased accordingly,
        -: 1080:   because it's necessary to respect the data of this fields in the functions,
        -: 1081:   which manage the long-style arguments!
        -: 1082:*/
        -: 1083:  {NULL, NULL, NULL},
        -: 1084:/*
        -: 1085:   This next "empty" table field must be kept UNTOUCHED,
        -: 1086:     because it marks the end of the table!
        -: 1087:*/
        -: 1088:  {NULL, NULL, NULL}
        -: 1089:};
        -: 1090:
        -: 1091:/* Points to the used date format. */
        -: 1092:Df_struct *date_format = supported_date_format;
        -: 1093:
        -: 1094:/*
        -: 1095:   The Gregorian Reformation dates table is a vector of `Greg_struct'
        -: 1096:     terminated by an element containing a `year' which is zero!
        -: 1097:   If you extend this table by some more dates, please extend the according
        -: 1098:     `lopt[]' table entry for the `--gregorian-reform' long-style option, too!
        -: 1099:     If you do so, remember that each new entry in the `lopt[]' table for
        -: 1100:     SYM_GREG_REFORM must have a new `short_name' text
        -: 1101:     "$\NEXT-CONSECUTIVE-OCTAL-NUMBER-OF-THIS-NEW-INDEX" and a corresponding
        -: 1102:     year of Gregorian Reformation text in `largs'.  The simple "$" text in
        -: 1103:     the `short_name' member and its corresponding LARG_TXT must always
        -: 1104:     trail any new entry, which will be possibly added in future.
        -: 1105:*/
        -: 1106:Greg_struct greg_reform_date[LARG_MAX - 1] = {
        -: 1107:/*
        -: 1108:  { int year, int month, int f_day, int l_day },
        -: 1109:*/
        -: 1110:  {1582, 10, 5, 14},
        -: 1111:  {1700, 2, 19, 28},
        -: 1112:  {1752, 9, 3, 13},
        -: 1113:  {1753, 2, 18, 28},
        -: 1114:/*
        -: 1115:   This next "empty" table field must be kept UNTOUCHED,
        -: 1116:     because it marks the end of the table!
        -: 1117:*/
        -: 1118:  {0, 0, 0, 0}
        -: 1119:};
        -: 1120:
        -: 1121:/*! Points to the used Gregorian Reformation date. */
        -: 1122:Greg_struct *greg = greg_reform_date;
        -: 1123:
        -: 1124:/*! User defined Gregorian Reformation date. */
        -: 1125:Greg_struct users_greg;
        -: 1126:
        -: 1127:#ifdef GCAL_EMAIL
        -: 1128:/*! Temporary file which is send by the mailer. */
        -: 1129:FILE *tfp = (FILE *) NULL;
        -: 1130:#endif
        -: 1131:
        -: 1132:/*! Used if a list/range of months/years is given. */
        -: 1133:Ml_struct *month_list = (Ml_struct *) NULL;
        -: 1134:
        -: 1135:/*! Effective hls 1 start (current day). */
        -: 1136:Hls_struct ehls1s;
        -: 1137:
        -: 1138:/*! Effective hls 1 end (current day). */
        -: 1139:Hls_struct ehls1e;
        -: 1140:
        -: 1141:/*! Effective hls 2 start (holiday). */
        -: 1142:Hls_struct ehls2s;
        -: 1143:
        -: 1144:/*! Effective hls 2 end (holiday). */
        -: 1145:Hls_struct ehls2e;
        -: 1146:
        -: 1147:#ifdef DJG
        -: 1148:/*! Set to SHRT_MAX for checking the maximum table range. */
        -: 1149:Usint testval = (Usint) 0;
        -: 1150:#else
        -: 1151:/*! Set to INT_MAX for checking the maximum table range. */
        -: 1152:Uint testval = (Uint) 0;
        -: 1153:#endif
        -: 1154:
        -: 1155:/*! Actual size of all string vectors. */
        -: 1156:Uint maxlen_max = MAXLEN_MAX;
        -: 1157:
        -: 1158:/*! String length of the maximum year able to compute. */
        -: 1159:int len_year_max = 0;
        -: 1160:
        -: 1161:/*! Maximum string length of a textual day_name(). */
        -: 1162:int len_dayname_max = 0;
        -: 1163:
        -: 1164:/*! Maximum string length of a textual month_name(). */
        -: 1165:int len_monthname_max = 0;
        -: 1166:
        -: 1167:/*! Maximum string length of a textual day_suffix() [if any]. */
        -: 1168:int len_suffix_max = 0;
        -: 1169:
        -: 1170:/*! `--debug[=0...WARN_LVL_MAX]', SPECIAL VALUE at startup. */
        -: 1171:int warning_level = SPECIAL_VALUE;
        -: 1172:
        -: 1173:/*! `-s<0,1...7|day name>'. */
        -: 1174:int start_day = 0;
        -: 1175:
        -: 1176:/*! `--transform-year=BASE_YEAR'. */
        -: 1177:int transform_year = 0;
        -: 1178:
        -: 1179:/*! `--time-offset=t|@|[t|@][+|-]MMMM|HH:[MM]' for correcting astronomically based data. */
        -: 1180:int time_hour_offset = 0;
        -: 1181:
        -: 1182:/*! `--time-offset=t|@|[t|@][+|-]MMMM|HH:[MM]' for correcting astronomically based data. */
        -: 1183:int time_min_offset = 0;
        -: 1184:
        -: 1185:/*! Current day. */
        -: 1186:int day = 0;
        -: 1187:
        -: 1188:/*! Current month. */
        -: 1189:int month = 0;
        -: 1190:
        -: 1191:/*! Current year. */
        -: 1192:int year = 0;
        -: 1193:
        -: 1194:/*! Actual second. */
        -: 1195:int act_sec = 0;
        -: 1196:
        -: 1197:/*! Actual minute. */
        -: 1198:int act_min = 0;
        -: 1199:
        -: 1200:/*! Actual hour. */
        -: 1201:int act_hour = 0;
        -: 1202:
        -: 1203:/*! Actual day. */
        -: 1204:int act_day = 0;
        -: 1205:
        -: 1206:/*! Actual month. */
        -: 1207:int act_month = 0;
        -: 1208:
        -: 1209:/*! Actual year. */
        -: 1210:int act_year = 0;
        -: 1211:
        -: 1212:/*! Buffer of actual day. */
        -: 1213:int buf_ad = 0;
        -: 1214:
        -: 1215:/*! Buffer of actual month. */
        -: 1216:int buf_am = 0;
        -: 1217:
        -: 1218:/*! Buffer of actual year. */
        -: 1219:int buf_ay = 0;
        -: 1220:
        -: 1221:/*! True actual day as reported by the operating system. */
        -: 1222:int true_day = 0;
        -: 1223:
        -: 1224:/*! True actual month as reported by the operating system. */
        -: 1225:int true_month = 0;
        -: 1226:
        -: 1227:/*! True actual year as reported by the operating system. */
        -: 1228:int true_year = 0;
        -: 1229:
        -: 1230:/*! Starting month of a fiscal year. */
        -: 1231:int fiscal_month = MONTH_MIN;
        -: 1232:
        -: 1233:/*! Is output displayed on a terminal? */
        -: 1234:int is_tty = 0;
        -: 1235:
        -: 1236:/*! Is output directed to channel 1? */
        -: 1237:int is_tty1 = 0;
        -: 1238:
        -: 1239:/*! Is output directed to channel 2? */
        -: 1240:int is_tty2 = 0;
        -: 1241:
        -: 1242:#if USE_PAGER
        -: 1243:/*! Number of tty rows, SPECIAL_VALUE at startup. */
        -: 1244:int tty_rows = SPECIAL_VALUE;
        -: 1245:
        -: 1246:/*! Number of tty columns, SPECIAL_VALUE at startup. */
        -: 1247:int tty_cols = SPECIAL_VALUE;
        -: 1248:#endif
        -: 1249:
        -: 1250:/*! Number of month rows of a year calendar. */
        -: 1251:int out_rows = 0;
        -: 1252:
        -: 1253:/*! Number of month columns of a year calendar. */
        -: 1254:int out_cols = 0;
        -: 1255:
        -: 1256:/*! Format length of a standard/special/both day. */
        -: 1257:int format_len = 0;
        -: 1258:
        -: 1259:/*! Is current year a leap year? */
        -: 1260:int is_leap_year = 0;
        -: 1261:
        -: 1262:#ifdef GCAL_EMAIL
        -: 1263:/*! Name of tempfile used by the mailer. */
        -: 1264:char *tfn = (char *) NULL;
        -: 1265:
        -: 1266:/*! Email address Gcal's output is send to. */
        -: 1267:char *email_adr = (char *) NULL;
        -: 1268:#endif
        -: 1269:
        -: 1270:/*! `--cc-holidays=CC[+CC+...]'. */
        -: 1271:char *cc = (char *) NULL;
        -: 1272:
        -: 1273:/*! The "YY" text. */
        -: 1274:char *yy_lit = (char *) NULL;
        -: 1275:
        -: 1276:/*! The "YYYY" text. */
        -: 1277:char *yyyy_lit = (char *) NULL;
        -: 1278:
        -: 1279:/*! The "MM" text. */
        -: 1280:char *mm_lit = (char *) NULL;
        -: 1281:
        -: 1282:/*! The "WWW" text. */
        -: 1283:char *www_lit = (char *) NULL;
        -: 1284:
        -: 1285:/*! The "DD" text. */
        -: 1286:char *dd_lit = (char *) NULL;
        -: 1287:
        -: 1288:/*! The "ARG" text. */
        -: 1289:char *larg_lit = (char *) NULL;
        -: 1290:
        -: 1291:/*! General purpose text buffer 1. */
        -: 1292:char *s1 = (char *) NULL;
        -: 1293:
        -: 1294:/*! General purpose text buffer 2. */
        -: 1295:char *s2 = (char *) NULL;
        -: 1296:
        -: 1297:/*! General purpose text buffer 3. */
        -: 1298:char *s3 = (char *) NULL;
        -: 1299:
        -: 1300:/*! General purpose text buffer 4. */
        -: 1301:char *s4 = (char *) NULL;
        -: 1302:
        -: 1303:/*! Stores the actual program name. */
        -: 1304:char *prgr_name = (char *) NULL;
        -: 1305:
        -: 1306:/*! Character for separating HH:MM time values. */
        -: 1307:char *time_sep = (char *) NULL;
        -: 1308:
        -: 1309:/*! `--translate-string=CHARACTER_PAIR...'. */
        -: 1310:char *translate_string = (char *) NULL;
        -: 1311:
        -: 1312:/*! Pointer to the $TZ (timezone) environment variable. */
        -: 1313:char *tz = (char *) NULL;
        -: 1314:
        -: 1315:#ifdef GCAL_EPAGER
        -: 1316:/*! Name of external pager program. */
        -: 1317:char *ext_pager = (char *) NULL;
        -: 1318:#endif
        -: 1319:
        -: 1320:/*! Day suffix format specifier given in date format?. */
        -: 1321:Bool use_day_suffix = FALSE;
        -: 1322:
        -: 1323:/*! 3 char day name format specifier given in date format? */
        -: 1324:Bool use_short3_day_name = FALSE;
        -: 1325:
        -: 1326:/*! Day number leaded with zeroes format specifier given in date format? */
        -: 1327:Bool use_day_zeroleaded = FALSE;
        -: 1328:
        -: 1329:/*! Year number leaded with zeroes format specifier given in date format? */
        -: 1330:Bool use_year_zeroleaded = FALSE;
        -: 1331:
        -: 1332:/*! Don't use Astronomical holidays by default. */
        -: 1333:Bool hdy_astronomical = FALSE;
        -: 1334:
        -: 1335:/*! Don't use Bahai calendar holidays by default. */
        -: 1336:Bool hdy_bahai = FALSE;
        -: 1337:
        -: 1338:/*! Don't use Celtic calendar holidays by default. */
        -: 1339:Bool hdy_celtic = FALSE;
        -: 1340:
        -: 1341:/*! Don't use Chinese calendar holidays by default. */
        -: 1342:Bool hdy_chinese = FALSE;
        -: 1343:
        -: 1344:/*! Don't use Chinese flexible calendar holidays by default. */
        -: 1345:Bool hdy_chinese_flexible = FALSE;
        -: 1346:
        -: 1347:/*! Don't use Christian Western churches calendar holidays by default. */
        -: 1348:Bool hdy_christian = FALSE;
        -: 1349:
        -: 1350:/*! Don't use Hebrew calendar holidays by default. */
        -: 1351:Bool hdy_hebrew = FALSE;
        -: 1352:
        -: 1353:/*! Don't use Islamic CIVIL calendar holidays by default. */
        -: 1354:Bool hdy_islamic = FALSE;
        -: 1355:
        -: 1356:/*! Don't use Japanese calendar holidays by default. */
        -: 1357:Bool hdy_japanese = FALSE;
        -: 1358:
        -: 1359:/*! Don't use Japanese flexible calendar holidays by default. */
        -: 1360:Bool hdy_japanese_flexible = FALSE;
        -: 1361:
        -: 1362:/*! Don't use Multicultural New_Year's_Day holidays by default. */
        -: 1363:Bool hdy_multicultural_new_year = FALSE;
        -: 1364:
        -: 1365:/*! Don't use Orthodox Christian Eastern churches NEW calendar holidays by default. */
        -: 1366:Bool hdy_orthodox_new = FALSE;
        -: 1367:
        -: 1368:/*! Don't use Orthodox Christian Eastern churches OLD calendar holidays by default. */
        -: 1369:Bool hdy_orthodox_old = FALSE;
        -: 1370:
        -: 1371:/*! Don't use Persian Jalaali calendar holidays by default. */
        -: 1372:Bool hdy_persian = FALSE;
        -: 1373:
        -: 1374:/*! Don't use Zodiacal Marker holidays by default. */
        -: 1375:Bool hdy_zodiacal_marker = FALSE;
        -: 1376:
        -: 1377:/*! Don't use Bahai calendar months by default. */
        -: 1378:Bool mth_bahai = FALSE;
        -: 1379:
        -: 1380:/*! Don't use Chinese calendar months by default. */
        -: 1381:Bool mth_chinese = FALSE;
        -: 1382:
        -: 1383:/*! Don't use Chinese flexible calendar months by default. */
        -: 1384:Bool mth_chinese_flexible = FALSE;
        -: 1385:
        -: 1386:/*! Don't use Coptic calendar months by default. */
        -: 1387:Bool mth_coptic = FALSE;
        -: 1388:
        -: 1389:/*! Don't use Ethiopic calendar months by default. */
        -: 1390:Bool mth_ethiopic = FALSE;
        -: 1391:
        -: 1392:/*! Don't use French Revolutionary calendar months by default. */
        -: 1393:Bool mth_french_revolutionary = FALSE;
        -: 1394:
        -: 1395:/*! Don't use Hebrew calendar months by default. */
        -: 1396:Bool mth_hebrew = FALSE;
        -: 1397:
        -: 1398:/*! Don't use Indian CIVIL calendar months by default. */
        -: 1399:Bool mth_indian_civil = FALSE;
        -: 1400:
        -: 1401:/*! Don't use Islamic CIVIL calendar months by default. */
        -: 1402:Bool mth_islamic = FALSE;
        -: 1403:
        -: 1404:/*! Don't use Japanese calendar months by default. */
        -: 1405:Bool mth_japanese = FALSE;
        -: 1406:
        -: 1407:/*! Don't use Japanese flexible calendar months by default. */
        -: 1408:Bool mth_japanese_flexible = FALSE;
        -: 1409:
        -: 1410:/*! Don't use Old-Armenic calendar months by default. */
        -: 1411:Bool mth_old_armenic = FALSE;
        -: 1412:
        -: 1413:/*! Don't use Old-Egyptic calendar months by default. */
        -: 1414:Bool mth_old_egyptic = FALSE;
        -: 1415:
        -: 1416:/*! Don't use Persian Jalaali calendar months by default. */
        -: 1417:Bool mth_persian = FALSE;
        -: 1418:
        -: 1419:/*! `-O' (compute leap years as done by Eastern churches). */
        -: 1420:Bool orthodox_calendar = FALSE;
        -: 1421:
        -: 1422:/*! `-u'. */
        -: 1423:Bool suppr_cal_flag = FALSE;
        -: 1424:
        -: 1425:/*! `-H<yes>|<no>'. */
        -: 1426:Bool highlight_flag = TRUE;
        -: 1427:
        -: 1428:/*! `--iso-week-number=<yes>|<no>'. */
        -: 1429:Bool iso_week_number = FALSE;
        -: 1430:
        -: 1431:/*! `-K'. */
        -: 1432:Bool cal_with_week_number = FALSE;
        -: 1433:
        -: 1434:/*! `-j'. */
        -: 1435:Bool cal_special_flag = FALSE;
        -: 1436:
        -: 1437:/*! `-jb'. */
        -: 1438:Bool cal_both_dates_flag = FALSE;
        -: 1439:
        -: 1440:/*! `-n|N'. */
        -: 1441:Bool holiday_flag = FALSE;
        -: 1442:
        -: 1443:/*! `-N'. */
        -: 1444:Bool hd_legal_days_only = FALSE;
        -: 1445:
        -: 1446:/*! `-n|N-'. */
        -: 1447:Bool hd_sort_des_flag = FALSE;
        -: 1448:
        -: 1449:/*! `-jn'. */
        -: 1450:Bool hd_special_flag = FALSE;
        -: 1451:
        -: 1452:/*! `-jnb'. */
        -: 1453:Bool hd_both_dates_flag = FALSE;
        -: 1454:
        -: 1455:/*! `-G'. */
        -: 1456:Bool hd_suppr_list_sep_flag = FALSE;
        -: 1457:
        -: 1458:/*! `-X'. */
        -: 1459:Bool hd_title_flag = TRUE;
        -: 1460:
        -: 1461:/*! ':' char found in argument (MM:YYYY). */
        -: 1462:Bool is_fiscal_year = FALSE;
        -: 1463:
        -: 1464:/*! Argument is `.' or `.+' or `.-'. */
        -: 1465:Bool is_3month_mode = FALSE;
        -: 1466:
        -: 1467:/*! Argument is `..' -> current quarter of actual year. */
        -: 1468:Bool is_3month_mode2 = FALSE;
        -: 1469:
        -: 1470:/*! Is an extended list/range of years given? */
        -: 1471:Bool is_ext_year = FALSE;
        -: 1472:
        -: 1473:/*! Is an extended list of months/years given? */
        -: 1474:Bool is_ext_list = FALSE;
        -: 1475:
        -: 1476:/*! Is an extended range of months/years given? */
        -: 1477:Bool is_ext_range = FALSE;
        -: 1478:
        -: 1479:/*! Is a special range of a selected month of years given? */
        -: 1480:Bool is_special_range = FALSE;
        -: 1481:
        -: 1482:/*! Is a special range of selected months of years given? */
        -: 1483:Bool is_multi_range = FALSE;
        -: 1484:
        -: 1485:#ifdef GCAL_NLS
        -: 1486:/*! Support of English language? */
        -: 1487:Bool is_en = FALSE;
        -: 1488:#endif
        -: 1489:
        -: 1490:/*! `-i[-]'. */
        -: 1491:Bool special_calsheet_flag = FALSE;
        -: 1492:
        -: 1493:#if USE_HLS
        -: 1494:/*! Must we emulate the highlighting sequences? */
        -: 1495:Bool emu_hls = FALSE;
        -: 1496:#else /* !USE_HLS */
        -: 1497:/*! Must we emulate the highlighting sequences? */
        -: 1498:Bool emu_hls = TRUE;
        -: 1499:#endif /* !USE_HLS */
        -: 1500:
        -: 1501:#if USE_PAGER
        -: 1502:/*! `-p'. */
        -: 1503:Bool pager_flag = FALSE;
        -: 1504:#endif
        -: 1505:
        -: 1506:
        -: 1507:
        -: 1508:/*
        -: 1509:*  static variables definitions.
        -: 1510:*/
        -: 1511:#ifdef GCAL_EPAGER
        -: 1512:/*! Child process id of external pager. */
        -: 1513:static pid_t child_pid;
        -: 1514:
        -: 1515:/*! Pipe file descriptors. */
        -: 1516:static int pipe_fd[2];
        -: 1517:
        -: 1518:/*! Buffer of system file descriptors 0 and 1. */
        -: 1519:static int sys_fd[2];
        -: 1520:#endif
        -: 1521:
        -: 1522:/*! User defined date format. */
        -: 1523:static Df_struct users_date_format;
        -: 1524:
        -: 1525:/*! Maximum number of `month_list[]' table elems. */
        -: 1526:static Uint month_list_max = MONTH_MAX + 1;
        -: 1527:
        -: 1528:/*! The index value of a long option. */
        -: 1529:static int lopt_id = 0;
        -: 1530:
        -: 1531:/*! Termination status on `--help', `--version' etc... */
        -: 1532:static int exit_stat_help = EXIT_STAT_HELP;
        -: 1533:
        -: 1534:/*! Buffers default value of `-s<ARG>' option. */
        -: 1535:static int buf_start_day = 0;
        -: 1536:
        -: 1537:#ifdef GCAL_EPAGER
        -: 1538:/*!
        -: 1539:   Possible options passed to the $PAGER external pager program.
        -: 1540:*/
        -: 1541:static char **pg_argv = (char **) NULL;
        -: 1542:
        -: 1543:/*!
        -: 1544:   The external pager program names table is a vector of char pointer
        -: 1545:     elements, which must be terminated by a NULL element!
        -: 1546:*/
        -: 1547:static char *pagers[] = { PAGER1_PROG, PAGER2_PROG, PAGER3_PROG, NULL };
        -: 1548:#endif
        -: 1549:
        -: 1550:
        -: 1551:#ifdef GCAL_SHELL
        -: 1552:/*! File name of shell script to write `-S<NAME>'. */
        -: 1553:static char *shl_filename = (char *) NULL;
        -: 1554:#endif
        -: 1555:
        -: 1556:/*! Name of response file to read (@FILE) or write (-R<NAME>). */
        -: 1557:static char *rsp_filename = (char *) NULL;
        -: 1558:
        -: 1559:/*! Text containing user defined highlighting sequences `-H<>'. */
        -: 1560:static char *hl_seq = (char *) NULL;
        -: 1561:
        -: 1562:/*! Points to "date format error location" description text. */
        -: 1563:static char *errtxt_dformat = (char *) NULL;
        -: 1564:
        -: 1565:/*! `-b<1|2|3|4|6|12>'. */
        -: 1566:static Bool year_flag = FALSE;
        -: 1567:
        -: 1568:
        -: 1569:
        -: 1570:/*
        -: 1571:*  Function implementations.
        -: 1572:*/
        -: 1573:int
function main called 91 returned 0% blocks executed 40%
       91: 1574:main (argc, argv)
        -: 1575:     int argc;
        -: 1576:     char *argv[];
        -: 1577:/*!
        -: 1578:   The Gcal program entry point   =8^)
        -: 1579:*/
        -: 1580:{
       91: 1581:  auto FILE *fp = (FILE *) NULL;
       91: 1582:  auto Uint my_argc_max = MY_ARGC_MAX;
       91: 1583:  auto int my_argc = 1;
        -: 1584:  auto int i;
        -: 1585:  register int j;
       91: 1586:  auto char **my_argv = (char **) NULL;
        -: 1587:#if USE_RC
        -: 1588:# ifdef GCAL_SHELL
        -: 1589:  static const char *these_short_opts_need_args = "#DFHIPRSbfqrsv";
        -: 1590:# else /* !GCAL_SHELL */
        -: 1591:  static const char *these_short_opts_need_args = "#DFHIPRbfqrsv";
        -: 1592:# endif	/* !GCAL_SHELL */
        -: 1593:#else /* !USE_RC */
        -: 1594:# ifdef GCAL_SHELL
        -: 1595:  static const char *these_short_opts_need_args = "HRSbqs";
        -: 1596:# else /* !GCAL_SHELL */
        -: 1597:  static const char *these_short_opts_need_args = "HRbqs";
        -: 1598:# endif	/* !GCAL_SHELL */
        -: 1599:#endif /* !USE_RC */
        -: 1600:  auto char *ptr_char;
        -: 1601:  auto char *y_txt;
        -: 1602:  auto char *m_txt;
        -: 1603:  auto char *w_txt;
        -: 1604:  auto char *d_txt;
       91: 1605:  auto Bool show_calendar = TRUE;
        -: 1606:  auto Bool b_dummy;
        -: 1607:
        -: 1608:
        -: 1609:  /*
        -: 1610:     Let's set `testval' to SHRT_MAX/INT_MAX if SHRT_MAX/INT_MAX itself
        -: 1611:     isn't defined.  This solution only works on machines with internal
        -: 1612:     arithmethics based on "two complements".
        -: 1613:   */
        -: 1614:#ifdef DJG
        -: 1615:# ifdef SHRT_MAX
        -: 1616:  testval = SHRT_MAX;
        -: 1617:# else /* !SHRT_MAX */
        -: 1618:  testval = ~0;
        -: 1619:  testval >>= 1;
        -: 1620:# endif	/* !SHRT_MAX */
        -: 1621:#else /* !DJG */
        -: 1622:# ifdef INT_MAX
       91: 1623:  testval = INT_MAX;
        -: 1624:# else /* !INT_MAX */
        -: 1625:  testval = ~0;
        -: 1626:  testval >>= 1;
        -: 1627:# endif	/* !INT_MAX */
        -: 1628:#endif /* !DJG */
        -: 1629:#if HAVE_ASSERT_H
        -: 1630:  /*
        -: 1631:     To ensure safe program operations,
        -: 1632:     MAXLEN_MAX must be 1024 minimum and `testval' maximum!
        -: 1633:   */
        -: 1634:  assert (MAXLEN_MAX >= 1024);
       91: 1635:  assert ((Uint) MAXLEN_MAX <= testval);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1636:#endif
        -: 1637:  /*
        -: 1638:     Then we have to allocate all string vectors we'll use.
        -: 1639:   */
       91: 1640:  allocate_all_strings (MAXLEN_MAX, __FILE__, (long) __LINE__);
call    0 returned 100%
        -: 1641:  /*
        -: 1642:     Compute the string length of the maximum year able to compute.
        -: 1643:   */
       91: 1644:  sprintf (s1, "%d", YEAR_MAX);
       91: 1645:  len_year_max = (int) strlen (s1);
        -: 1646:  /*
        -: 1647:     Perform some more assertations for safe program operation.
        -: 1648:   */
        -: 1649:#if HAVE_ASSERT_H
        -: 1650:  /*
        -: 1651:     Check if value for maximum number of table entries
        -: 1652:     fits to the positive range of a signed int (SHRT_MAX/INT_MAX)!
        -: 1653:   */
       91: 1654:  assert (my_argc_max > 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       91: 1655:  assert (my_argc_max <= testval);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       91: 1656:  assert (len_year_max < 11);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
       91: 1657:  assert (len_year_max > 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1658:  assert (YEAR_MAX >= YEAR_MIN);
        -: 1659:  assert (MONTH_MAX == 12);
        -: 1660:  assert (CENTURY == 1900);
        -: 1661:  /*
        -: 1662:     For safe program operation, BUF_LEN must be 1 minimum and `testval'-1 maximum!
        -: 1663:   */
        -: 1664:  assert (BUF_LEN >= 1);
       91: 1665:  assert ((Uint) BUF_LEN < testval);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1666:  assert (strlen (PACKAGE_NAME) > 0);
        -: 1667:  assert (strlen (PACKAGE_VERSION) > 0);
        -: 1668:  assert (MY_ARGC_MAX > 1);
       91: 1669:  assert ((Uint) MY_ARGC_MAX <= testval);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1670:  assert (HD_ELEMS_MAX > 0);
       91: 1671:  assert ((Uint) HD_ELEMS_MAX <= testval);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1672:  assert (FWIDTH_MAX > 0);
        -: 1673:#endif /* HAVE_ASSERT_H */
        -: 1674:#ifdef GCAL_NLS
        -: 1675:  /*
        -: 1676:     Now initialize the NLS functions.
        -: 1677:   */
        -: 1678:# if HAVE_SETLOCALE
       91: 1679:  setlocale (LC_ALL, "");
call    0 returned 100%
        -: 1680:# endif
        -: 1681:# ifndef LOCALEEDIR
        -: 1682:#  define LOCALEEDIR  NULL
        -: 1683:# endif
        -: 1684:  bindtextdomain (PACKAGE, LOCALEDIR);
        -: 1685:  textdomain (PACKAGE);
        -: 1686:  /*
        -: 1687:     Now check whether we use a native language message catalog
        -: 1688:     or the internal default (==English) language texts!
        -: 1689:   */
        -: 1690:# if !defined(AMIGA) || defined(__GNUC__)
        -: 1691:  /*
        -: 1692:     Detect whether the $LANGUAGE environment variable (GNU specific) is set.
        -: 1693:   */
       91: 1694:  ptr_char = getenv (ENV_VAR_LANGUAGE);
call    0 returned 100%
       91: 1695:  if (ptr_char != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1696:    if (!*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1697:      ptr_char = (char *) NULL;
       91: 1698:  if (ptr_char == (char *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1699:    {
        -: 1700:      /*
        -: 1701:         Detect whether the $LC_ALL environment variable is set.
        -: 1702:       */
       91: 1703:      ptr_char = getenv (ENV_VAR_LC_ALL);
call    0 returned 100%
       91: 1704:      if (ptr_char != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1705:	if (!*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1706:	  ptr_char = (char *) NULL;
        -: 1707:    }
        -: 1708:#  if HAVE_LC_MESSAGES
        -: 1709:  if (ptr_char == (char *) NULL)
        -: 1710:    {
        -: 1711:      /*
        -: 1712:         Detect whether the $LC_MESSAGES environment variable is set.
        -: 1713:       */
        -: 1714:      ptr_char = getenv (ENV_VAR_LC_MESSAGES);
        -: 1715:      if (ptr_char != (char *) NULL)
        -: 1716:	if (!*ptr_char)
        -: 1717:	  ptr_char = (char *) NULL;
        -: 1718:    }
        -: 1719:#  endif
       91: 1720:  if (ptr_char == (char *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1721:    {
        -: 1722:      /*
        -: 1723:         Detect whether the $LANG environment variable is set.
        -: 1724:       */
       91: 1725:      ptr_char = getenv (ENV_VAR_LANG);
call    0 returned 100%
       91: 1726:      if (ptr_char != (char *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 1727:	if (!*ptr_char)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1728:	  ptr_char = (char *) NULL;
        -: 1729:    }
        -: 1730:  /*
        -: 1731:     Now check the kind of territory specifics we have to use!
        -: 1732:   */
       91: 1733:  if (ptr_char != (char *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1734:    {
       91: 1735:      if (*ptr_char)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1736:	{
       91: 1737:	  strncpy (s1, ptr_char, 6);
       91: 1738:	  s1[5] = '\0';
       91: 1739:	  if (!strncasecmp (s1, "de", 2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1740:	    /*
        -: 1741:	       We have to use German texts and territory specifics!
        -: 1742:	     */
    #####: 1743:	    is_en = FALSE;
       91: 1744:	  else if (!strncasecmp (s1, "en", 2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1745:	    /*
        -: 1746:	       We have to use English texts, but we check for territory
        -: 1747:	       specifics (either U.S.A. or Great Britain) later!
        -: 1748:	     */
    #####: 1749:	    is_en = TRUE;
        -: 1750:	  else
        -: 1751:	    /*
        -: 1752:	       Hmm... We have to check whether the special settings "C" or
        -: 1753:	       "POSIX" are given, if so, we have to use English texts
        -: 1754:	       and U.S.A. territory by default!
        -: 1755:	     */
       91: 1756:	  if (!strncasecmp (s1, "posix", 5) || !strcasecmp (s1, "c"))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1757:	    is_en = TRUE;
        -: 1758:	}
        -: 1759:      else
        -: 1760:	/*
        -: 1761:	   Environment variable defined but not set, hmm...
        -: 1762:	   We use English texts and U.S.A. territory specifics by default!
        -: 1763:	 */
    #####: 1764:	is_en = TRUE;
        -: 1765:    }
        -: 1766:  else
        -: 1767:    /*
        -: 1768:       No environment variable defined.
        -: 1769:     */
        -: 1770:# endif /* !AMIGA || __GNUC__ */
        -: 1771:    /*
        -: 1772:       We use English texts and U.S.A. territory specifics by default!
        -: 1773:     */
    #####: 1774:    is_en = TRUE;
        -: 1775:  /*
        -: 1776:     Set some variables according to the native language used.
        -: 1777:   */
       91: 1778:  if (is_en)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1779:    {
        -: 1780:      /*
        -: 1781:         `is_en' means English texts and U.S.A. territory specifics by default for now.
        -: 1782:       */
    #####: 1783:      special_calsheet_flag = TRUE;
    #####: 1784:      iso_week_number = FALSE;
    #####: 1785:      out_rows = J_OUT_ROWS;
        -: 1786:      /*
        -: 1787:         Set the date of Gregorian Reformation to 1752 (table index 2 !!)
        -: 1788:       */
    #####: 1789:      greg += 2;
        -: 1790:      /*
        -: 1791:         Set the date format to U.S.A. style (table index 1 !!)
        -: 1792:       */
    #####: 1793:      date_format++;
        -: 1794:# if !defined(AMIGA) || defined(__GNUC__)
        -: 1795:      /*
        -: 1796:         Now check whether if we have to use the British date format.
        -: 1797:       */
    #####: 1798:      if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1799:	if (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 1800:	  {
        -: 1801:	    /*
        -: 1802:	       Skip the first three characters for detecting a possibly territory information.
        -: 1803:	     */
    #####: 1804:	    for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
    #####: 1805:	      if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1806:		ptr_char++;
    #####: 1807:	    if (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 1808:	      {
    #####: 1809:		strncpy (s1, ptr_char, 3);
    #####: 1810:		s1[2] = '\0';
        -: 1811:		/*
        -: 1812:		   We have to use the British date format!
        -: 1813:		 */
    #####: 1814:		if (!strcasecmp (s1, CC_GB))
branch  0 never executed
branch  1 never executed
        -: 1815:		  /*
        -: 1816:		     Set the date format to Great Britain style (table index 2 !!)
        -: 1817:		   */
    #####: 1818:		  date_format++;
        -: 1819:	      }
        -: 1820:	  }
        -: 1821:# endif /* !AMIGA || __GNUC__ */
        -: 1822:    }
        -: 1823:  else
        -: 1824:    {
        -: 1825:      /*
        -: 1826:         `!is_en' means German territory specifics (useful for most Europeans)
        -: 1827:         by default and possibly another native language instead of English.
        -: 1828:       */
       91: 1829:      special_calsheet_flag = FALSE;
       91: 1830:      iso_week_number = TRUE;
       91: 1831:      out_rows = S_OUT_ROWS;
        -: 1832:    }
        -: 1833:#else /* !GCAL_NLS */
        -: 1834:  special_calsheet_flag = TRUE;
        -: 1835:  iso_week_number = FALSE;
        -: 1836:  out_rows = J_OUT_ROWS;
        -: 1837:  /*
        -: 1838:     Set the date of Gregorian Reformation to 1752 (table index 2 !!)
        -: 1839:   */
        -: 1840:  greg += 2;
        -: 1841:  /*
        -: 1842:     Set the date format to U.S.A. style (table index 1 !!)
        -: 1843:   */
        -: 1844:  date_format++;
        -: 1845:#endif	/* !GCAL_NLS */
        -: 1846:  /*
        -: 1847:     Test if the default date format is valid.
        -: 1848:   */
       91: 1849:  if (!is_correct_date_format
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
       91: 1850:      (date_format->df_format, &use_day_suffix, &use_short3_day_name,
        -: 1851:       &use_day_zeroleaded, &use_year_zeroleaded))
    #####: 1852:    errtxt_dformat = _("default");
        -: 1853:  /*
        -: 1854:     Test if the program output is redirected or piped.
        -: 1855:   */
        -: 1856:#if USE_PAGER
       91: 1857:  is_tty1 = isatty (1);
call    0 returned 100%
       91: 1858:  is_tty2 = isatty (2);
call    0 returned 100%
       91: 1859:  is_tty = (is_tty1 && is_tty2);
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1860:# ifdef GCAL_EPAGER
       91: 1861:  if (is_tty)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1862:    {
        -: 1863:      /*
        -: 1864:         Store the SYS-STDIN/SYS-STDOUT file descriptors.
        -: 1865:       */
    #####: 1866:      dup2 (0, sys_fd[0]);
call    0 never executed
    #####: 1867:      dup2 (1, sys_fd[1]);
call    0 never executed
        -: 1868:    }
        -: 1869:# endif
        -: 1870:#else /* !USE_PAGER */
        -: 1871:  is_tty = (int) TRUE;
        -: 1872:#endif /* !USE_PAGER */
        -: 1873:  /*
        -: 1874:     Detect the own program name.
        -: 1875:   */
       91: 1876:  i = (int) strlen (*argv);
       91: 1877:  if ((Uint) i >= maxlen_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1878:    resize_all_strings (i + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
       91: 1879:  if (!i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1880:    strcpy (s3, PACKAGE_NAME);
        -: 1881:  else
       91: 1882:    strcpy (s3, *argv);
        -: 1883:#ifdef SUFFIX_SEP
        -: 1884:  /*
        -: 1885:     Eliminate version suffix under VMS.
        -: 1886:   */
        -: 1887:  ptr_char = strrchr (s3, *SUFFIX_SEP);
        -: 1888:  if (ptr_char != (char *) NULL)
        -: 1889:    *ptr_char = '\0';
        -: 1890:#endif
       91: 1891:  i = (int) strlen (s3);
        -: 1892:#ifdef DJG
        -: 1893:  ptr_char = strrchr (s3, *DIR2_SEP);
        -: 1894:#else /* !DJG */
       91: 1895:  ptr_char = strrchr (s3, *DIR_SEP);
        -: 1896:#endif /* !DJG */
       91: 1897:  if (ptr_char != (char *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1898:    {
       91: 1899:      ptr_char++;
       91: 1900:      i = (int) strlen (ptr_char);
        -: 1901:    }
        -: 1902:  else
    #####: 1903:    ptr_char = s3;
       91: 1904:  if (tolower ('A') == 'a')
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1905:    {
       91: 1906:      auto char *buf_ptr_char = ptr_char;
        -: 1907:
        -: 1908:
      455: 1909:      for (; *ptr_char; ptr_char++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
      364: 1910:	*ptr_char = (char) tolower (*ptr_char);
       91: 1911:      ptr_char = buf_ptr_char;
        -: 1912:    }
        -: 1913:  /*
        -: 1914:     Suppress ".exe" suffix for MSDOS, OS/2 and VMS.
        -: 1915:   */
       91: 1916:  if ((i > 4) && !strcmp (ptr_char + i - 4, ".exe"))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1917:    {
    #####: 1918:      i -= 4;
    #####: 1919:      *(ptr_char + i) = '\0';
        -: 1920:    }
       91: 1921:  prgr_name = (char *) my_malloc (i + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 returned 100%
        -: 1922:				  __FILE__, ((long) __LINE__) - 1L,
        -: 1923:				  "prgr_name", 0);
       91: 1924:  strcpy (prgr_name, ptr_char);
        -: 1925:#if HAVE_SIGNAL
        -: 1926:  /*
        -: 1927:     Now let's modify the signal handling a bit to make sure that
        -: 1928:     temporary files are always deleted if such signals are raised.
        -: 1929:   */
        -: 1930:# ifdef SIGINT
       91: 1931:  if (signal (SIGINT, SIG_IGN) != SIG_IGN)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       91: 1932:    (void) signal (SIGINT, (Sig_type) handle_signal);
call    0 returned 100%
        -: 1933:# endif
        -: 1934:# ifdef SIGTERM
       91: 1935:  if (signal (SIGTERM, SIG_IGN) != SIG_IGN)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       91: 1936:    (void) signal (SIGTERM, (Sig_type) handle_signal);
call    0 returned 100%
        -: 1937:# endif
        -: 1938:# ifdef SIGHUP
       91: 1939:  if (signal (SIGHUP, SIG_IGN) != SIG_IGN)
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       91: 1940:    (void) signal (SIGHUP, (Sig_type) handle_signal);
call    0 returned 100%
        -: 1941:# endif
        -: 1942:#endif /* HAVE_SIGNAL */
        -: 1943:  /*
        -: 1944:     Assign the character which is used for separating the time HH:MM.
        -: 1945:   */
        -: 1946:
        -: 1947:  /*
        -: 1948:   *** Translators, please translate this as a fixed 1-character text.
        -: 1949:   *** This is the character which is used for separating the time HH:MM.
        -: 1950:   */
       91: 1951:  time_sep = _(":");
        -: 1952:
        -: 1953:  /*
        -: 1954:     Initialize the basic meta texts.
        -: 1955:   */
        -: 1956:
        -: 1957:  /*
        -: 1958:   *** Translators, please translate this as a fixed 1-character text.
        -: 1959:   *** This text should be a proper abbreviation of "Year".
        -: 1960:   */
       91: 1961:  y_txt = _("Y");
        -: 1962:  /*
        -: 1963:   *** Translators, please translate this as a fixed 1-character text.
        -: 1964:   *** This text should be a proper abbreviation of "Month".
        -: 1965:   */
       91: 1966:  m_txt = _("M");
        -: 1967:  /*
        -: 1968:   *** Translators, please translate this as a fixed 1-character text.
        -: 1969:   *** This text should be a proper abbreviation of "Week".
        -: 1970:   */
       91: 1971:  w_txt = _("W");
        -: 1972:  /*
        -: 1973:   *** Translators, please translate this as a fixed 1-character text.
        -: 1974:   *** This text should be a proper abbreviation of "Day".
        -: 1975:   */
       91: 1976:  d_txt = _("D");
        -: 1977:
        -: 1978:  /*
        -: 1979:     Initial memory allocation and initialization of the variables
        -: 1980:     which contain the "YY", "YYYY", "MM", "WWW" and "DD" literals.
        -: 1981:   */
       91: 1982:  yy_lit = (char *) my_malloc (3, ERR_NO_MEMORY_AVAILABLE,
call    0 returned 100%
        -: 1983:			       __FILE__, ((long) __LINE__) - 1L, "yy_lit", 0);
      273: 1984:  for (i = 0; i < 2; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      182: 1985:    yy_lit[i] = (char) toupper (*y_txt);
       91: 1986:  yy_lit[i] = '\0';
       91: 1987:  yyyy_lit = (char *) my_malloc (len_year_max + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 returned 100%
        -: 1988:				 __FILE__, ((long) __LINE__) - 1L,
        -: 1989:				 "yyyy_lit", 0);
      455: 1990:  for (i = 0; i < len_year_max; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
      364: 1991:    yyyy_lit[i] = (char) toupper (*y_txt);
       91: 1992:  yyyy_lit[i] = '\0';
       91: 1993:  mm_lit = (char *) my_malloc (3, ERR_NO_MEMORY_AVAILABLE,
call    0 returned 100%
        -: 1994:			       __FILE__, ((long) __LINE__) - 1L, "mm_lit", 0);
      273: 1995:  for (i = 0; i < 2; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      182: 1996:    mm_lit[i] = (char) toupper (*m_txt);
       91: 1997:  mm_lit[i] = '\0';
       91: 1998:  www_lit = (char *) my_malloc (4, ERR_NO_MEMORY_AVAILABLE,
call    0 returned 100%
        -: 1999:				__FILE__, ((long) __LINE__) - 1L,
        -: 2000:				"www_lit", 0);
      364: 2001:  for (i = 0; i < 3; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      273: 2002:    www_lit[i] = (char) toupper (*w_txt);
       91: 2003:  www_lit[i] = '\0';
       91: 2004:  dd_lit = (char *) my_malloc (3, ERR_NO_MEMORY_AVAILABLE,
call    0 returned 100%
        -: 2005:			       __FILE__, ((long) __LINE__) - 1L, "dd_lit", 0);
      273: 2006:  for (i = 0; i < 2; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      182: 2007:    dd_lit[i] = (char) toupper (*d_txt);
       91: 2008:  dd_lit[i] = '\0';
        -: 2009:  /*
        -: 2010:     Initial memory allocation and initialization of the variable which
        -: 2011:     contains the 3 characters "ARG" literal (a proper abbreviation of
        -: 2012:     the word "ARGUMENT").
        -: 2013:   */
       91: 2014:  larg_lit = (char *) my_malloc (4, ERR_NO_MEMORY_AVAILABLE,
call    0 returned 100%
        -: 2015:				 __FILE__, ((long) __LINE__) - 1L,
        -: 2016:				 "larg_lit", 0);
        -: 2017:
        -: 2018:  /*
        -: 2019:   *** Translators, please translate this as a fixed 3-character text.
        -: 2020:   *** This text should be a proper abbreviation of "ARGUMENT".
        -: 2021:   */
       91: 2022:  strncpy (larg_lit, _("ARG"), 4);
        -: 2023:
       91: 2024:  larg_lit[3] = '\0';
        -: 2025:  /*
        -: 2026:     Initial memory allocation for the `my_argv[]' table.
        -: 2027:   */
       91: 2028:  my_argv = (char **) my_malloc (MY_ARGC_MAX * sizeof (char *),
call    0 returned 100%
        -: 2029:				 ERR_NO_MEMORY_AVAILABLE,
        -: 2030:				 __FILE__, ((long) __LINE__) - 2L,
        -: 2031:				 "my_argv[MY_ARGC_MAX]", MY_ARGC_MAX);
        -: 2032:  /*
        -: 2033:     Initial memory allocation for `month_list[]' structure,
        -: 2034:     the number of vector elements must be set to MONTH_MAX+1 in this case,
        -: 2035:     because the vector must always be terminated by an empty structure
        -: 2036:     element (year==0 && month==0).
        -: 2037:   */
       91: 2038:  month_list = (Ml_struct *) my_malloc ((MONTH_MAX + 1) * sizeof (Ml_struct),
call    0 returned 100%
        -: 2039:					ERR_NO_MEMORY_AVAILABLE,
        -: 2040:					__FILE__, ((long) __LINE__) - 2L,
        -: 2041:					"month_list[MONTH_MAX+1]",
        -: 2042:					MONTH_MAX + 1);
        -: 2043:  /*
        -: 2044:     Initialize `month_list[]' structure.
        -: 2045:   */
     1274: 2046:  for (i = 0; i <= MONTH_MAX; i++)
branch  0 taken 93%
branch  1 taken 7% (fallthrough)
     1183: 2047:    month_list[i].ml_year = month_list[i].ml_month = 0;
        -: 2048:#if USE_RC
        -: 2049:  /*
        -: 2050:     Initial memory allocation for an element of the `Line_struct' record.
        -: 2051:   */
       91: 2052:  lineptrs = (Line_struct *) my_malloc (sizeof (Line_struct),
call    0 returned 100%
        -: 2053:					ERR_NO_MEMORY_AVAILABLE,
        -: 2054:					__FILE__, ((long) __LINE__) - 2L,
        -: 2055:					"lineptrs", 0);
        -: 2056:  /*
        -: 2057:     Initial memory allocation for an element of the `Line_struct' record
        -: 2058:     which is needed if we have to evaluate %?... special texts.
        -: 2059:   */
       91: 2060:  lptrs3 = (Line_struct *) my_malloc (sizeof (Line_struct),
call    0 returned 100%
        -: 2061:				      ERR_NO_MEMORY_AVAILABLE,
        -: 2062:				      __FILE__, ((long) __LINE__) - 2L,
        -: 2063:				      "lptrs3", 0);
        -: 2064:  /*
        -: 2065:     Initial memory allocation for the fixed date list title text.
        -: 2066:   */
       91: 2067:  ptr_char = _("Fixed date list:");
        -: 2068:
       91: 2069:  rc_heading_text = (char *) my_malloc (strlen (ptr_char) + 1 + 2,
call    0 returned 100%
        -: 2070:					ERR_NO_MEMORY_AVAILABLE,
        -: 2071:					__FILE__, ((long) __LINE__) - 2L,
        -: 2072:					"rc_heading_text", 0);
       91: 2073:  strcpy (rc_heading_text, "0 ");
       91: 2074:  strcat (rc_heading_text, ptr_char);
        -: 2075:#endif /* USE_RC */
        -: 2076:#if !defined(AMIGA) || defined(__GNUC__)
        -: 2077:  /*
        -: 2078:     Detect whether a $GCAL_DATE_FORMAT environment variable is set.
        -: 2079:   */
       91: 2080:  ptr_char = getenv (ENV_VAR_GCAL_DATE_FORMAT);
call    0 returned 100%
       91: 2081:  if (ptr_char != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2082:    if (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 2083:      {
    #####: 2084:	users_date_format.df_info = _("environment variable");
        -: 2085:
    #####: 2086:	users_date_format.df_format =
    #####: 2087:	  (char *) my_malloc (strlen (ptr_char) + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 never executed
        -: 2088:			      __FILE__, ((long) __LINE__) - 2L,
        -: 2089:			      "users_date_format.df_format", 0);
    #####: 2090:	strcpy (users_date_format.df_format, ptr_char);
    #####: 2091:	date_format = &users_date_format;
        -: 2092:	/*
        -: 2093:	   Test if the date format given in environment variable is valid.
        -: 2094:	 */
    #####: 2095:	if (!is_correct_date_format
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2096:	    (date_format->df_format, &use_day_suffix, &use_short3_day_name,
        -: 2097:	     &use_day_zeroleaded, &use_year_zeroleaded))
        -: 2098:
    #####: 2099:	  errtxt_dformat = _("environment variable");
        -: 2100:
        -: 2101:	else
    #####: 2102:	  errtxt_dformat = (char *) NULL;
        -: 2103:      }
        -: 2104:  /*
        -: 2105:     Detect whether a $TZ (timezone) environment variable is set.
        -: 2106:   */
       91: 2107:  tz = getenv (ENV_VAR_TZ);
call    0 returned 100%
       91: 2108:  if (tz != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2109:    if (!*tz)
branch  0 never executed
branch  1 never executed
    #####: 2110:      tz = (char *) NULL;
        -: 2111:  /*
        -: 2112:     Detect whether the $GCAL environment variable is set.
        -: 2113:   */
       91: 2114:  ptr_char = getenv (ENV_VAR_GCAL);
call    0 returned 100%
       91: 2115:  if (ptr_char != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2116:    {
    #####: 2117:      if (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 2118:	{
        -: 2119:	  /*
        -: 2120:	     $GCAL environment variable defined and not empty:
        -: 2121:	     Copy the OPTIONS, expanded @FILE arguments or the actual date
        -: 2122:	     modifier %DATE argument only; found in environment variable
        -: 2123:	     $GCAL; into the private `my_argv[]' table.
        -: 2124:	   */
    #####: 2125:	  while (isspace (*ptr_char))
branch  0 never executed
branch  1 never executed
    #####: 2126:	    ptr_char++;
    #####: 2127:	  i = 0;
    #####: 2128:	  while (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 2129:	    {
    #####: 2130:	      if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 2131:		resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -: 2132:				    (long) __LINE__);
    #####: 2133:	      s1[i++] = *ptr_char++;
    #####: 2134:	      if (!*ptr_char || isspace (*ptr_char))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2135:		{
    #####: 2136:		  s1[i] = '\0';
    #####: 2137:		  if (*s1 == *SWITCH || *s1 == *SWITCH2
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2138:# if USE_RC
    #####: 2139:		      || *s1 == RC_ADATE_CHAR
branch  0 never executed
branch  1 never executed
        -: 2140:# endif
    #####: 2141:		      || *s1 == RSP_CHAR)
branch  0 never executed
branch  1 never executed
        -: 2142:		    {
        -: 2143:		      /*
        -: 2144:		         Avoid one or two letter combinations of '-', '/', '%' or '@' characters only!
        -: 2145:		       */
    #####: 2146:		      if (i == 1 || ((i == 2) && (s1[1] == *SWITCH
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2147:# if USE_RC
    #####: 2148:						  || s1[1] == RC_ADATE_CHAR
branch  0 never executed
branch  1 never executed
        -: 2149:# endif
    #####: 2150:						  || s1[1] == *SWITCH2)))
branch  0 never executed
branch  1 never executed
        -: 2151:			;	/* Void, don't allocate memory */
        -: 2152:		      else
        -: 2153:			{
    #####: 2154:			  if (*s1 == RSP_CHAR)
branch  0 never executed
branch  1 never executed
        -: 2155:			    {
        -: 2156:			      /*
        -: 2157:			         Try to manage a response file @FILE argument given
        -: 2158:			         in the environment variable $GCAL.
        -: 2159:			       */
    #####: 2160:			      rsp_filename = (char *) my_malloc (strlen (s1),
call    0 never executed
        -: 2161:								 ERR_NO_MEMORY_AVAILABLE,
        -: 2162:								 __FILE__,
        -: 2163:								 ((long)
        -: 2164:								  __LINE__) -
        -: 2165:								 2L,
        -: 2166:								 "rsp_filename",
        -: 2167:								 0);
    #####: 2168:			      strcpy (rsp_filename, s1 + 1);
    #####: 2169:			      fp =
call    0 never executed
        -: 2170:				file_open (&rsp_filename, 0, REsponse,
        -: 2171:					   &b_dummy);
    #####: 2172:			      if (fp != (FILE *) NULL)
branch  0 never executed
branch  1 never executed
        -: 2173:				{
    #####: 2174:				  my_argv =
call    0 never executed
    #####: 2175:				    insert_response_file (fp, rsp_filename,
        -: 2176:							  these_short_opts_need_args,
        -: 2177:							  &my_argc_max,
        -: 2178:							  &my_argc, my_argv);
    #####: 2179:				  (void) fclose (fp);
call    0 never executed
        -: 2180:				}
    #####: 2181:			      free (rsp_filename);
    #####: 2182:			      rsp_filename = (char *) NULL;
        -: 2183:			    }
        -: 2184:			  else
        -: 2185:			    {
        -: 2186:			      /*
        -: 2187:			         Ok, argument is an option or an actual date modifier %DATE.
        -: 2188:			       */
    #####: 2189:			      if ((*s1 == *SWITCH
branch  0 never executed
branch  1 never executed
    #####: 2190:				   || *s1 == *SWITCH2) && (s1[1] != *SWITCH))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2191:				{
        -: 2192:				  /*
        -: 2193:				     Short-style option found.
        -: 2194:				   */
    #####: 2195:				  if ((strchr
branch  0 never executed
branch  1 never executed
        -: 2196:				       (these_short_opts_need_args,
    #####: 2197:					s1[1]) != (char *) NULL) && !s1[2])
branch  0 never executed
branch  1 never executed
        -: 2198:				    {
        -: 2199:				      /*
        -: 2200:				         Short-style option requires an argument, which is separated by
        -: 2201:				         one or more whitespace characters from the option character;
        -: 2202:				         respect this!  This means all separating whitespace characters
        -: 2203:				         between the option character and argument will be eliminated.
        -: 2204:				       */
    #####: 2205:				      while (isspace (*ptr_char))
branch  0 never executed
branch  1 never executed
        -: 2206:					/*
        -: 2207:					   Skip the separating whitespace characters.
        -: 2208:					 */
    #####: 2209:					ptr_char++;
        -: 2210:				      /*
        -: 2211:				         Store needed argument of option adjacent to option character.
        -: 2212:				       */
    #####: 2213:				      while (*ptr_char
branch  0 never executed
branch  1 never executed
    #####: 2214:					     && !isspace (*ptr_char))
branch  0 never executed
branch  1 never executed
        -: 2215:					{
    #####: 2216:					  if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 2217:					    resize_all_strings (maxlen_max <<
call    0 never executed
        -: 2218:								1, FALSE,
        -: 2219:								__FILE__,
        -: 2220:								(long)
        -: 2221:								__LINE__);
    #####: 2222:					  s1[i++] = *ptr_char++;
        -: 2223:					}
    #####: 2224:				      s1[i] = '\0';
        -: 2225:				    }
        -: 2226:				}
    #####: 2227:			      if ((Uint) my_argc >= my_argc_max)
branch  0 never executed
branch  1 never executed
        -: 2228:				{
        -: 2229:				  /*
        -: 2230:				     Resize the `my_argv[]' table.
        -: 2231:				   */
    #####: 2232:				  my_argc_max <<= 1;
    #####: 2233:				  if (my_argc_max * sizeof (char *) > testval)
branch  0 never executed
branch  1 never executed
    #####: 2234:				    my_argc_max--;
    #####: 2235:				  my_argv =
call    0 never executed
    #####: 2236:				    (char **) my_realloc ((VOID_PTR) my_argv,
    #####: 2237:							  my_argc_max *
        -: 2238:							  sizeof (char *),
        -: 2239:							  ERR_NO_MEMORY_AVAILABLE,
        -: 2240:							  __FILE__,
        -: 2241:							  ((long) __LINE__) -
        -: 2242:							  3L,
        -: 2243:							  "my_argv[my_argc_max]",
        -: 2244:							  my_argc_max);
        -: 2245:				}
    #####: 2246:			      my_argv[my_argc] = (char *) my_malloc (i + 1,
call    0 never executed
        -: 2247:								     ERR_NO_MEMORY_AVAILABLE,
        -: 2248:								     __FILE__,
        -: 2249:								     ((long)
        -: 2250:								      __LINE__)
        -: 2251:								     - 2L,
        -: 2252:								     "my_argv[my_argc]",
        -: 2253:								     my_argc);
    #####: 2254:			      strcpy (my_argv[my_argc++], s1);
        -: 2255:			    }
        -: 2256:			}
    #####: 2257:		      while (isspace (*ptr_char))
branch  0 never executed
branch  1 never executed
    #####: 2258:			ptr_char++;
    #####: 2259:		      i = 0;
        -: 2260:		    }
    #####: 2261:		  else if (i)
branch  0 never executed
branch  1 never executed
        -: 2262:		    {
        -: 2263:		      /*
        -: 2264:		         Error, argument is a command.
        -: 2265:		       */
    #####: 2266:		      fprintf (stderr,
call    0 never executed
call    1 never executed
call    2 never executed
        -: 2267:			       _
        -: 2268:			       ("%s: command in environment variable `%s' found -- %s\n%s\n%s\n"),
        -: 2269:			       prgr_name, ENV_VAR_GCAL, s1, usage_msg (),
        -: 2270:			       lopt_msg ());
        -: 2271:
    #####: 2272:		      exit (ERR_INVALID_OPTION);
call    0 never executed
        -: 2273:		    }
        -: 2274:		}
        -: 2275:	    }
        -: 2276:	}
        -: 2277:    }
        -: 2278:#endif /* !AMIGA || __GNUC__ */
        -: 2279:  /*
        -: 2280:     Now insert/append the "arguments" of command line
        -: 2281:     into the private `my_argv[]' table.
        -: 2282:   */
      383: 2283:  while (argc > 1)
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
        -: 2284:    {
      203: 2285:      argv++;
        -: 2286:      /*
        -: 2287:         Preload the contents of response files and don't place this option
        -: 2288:         text itself in private `my_argv[]' command line options table!
        -: 2289:       */
      203: 2290:      if (**argv == RSP_CHAR)
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
        -: 2291:	{
        -: 2292:	  /*
        -: 2293:	     Try to manage a response file @FILE argument given in the command line.
        -: 2294:	   */
      140: 2295:	  rsp_filename = (char *) my_malloc (strlen (*argv),
call    0 returned 100%
        -: 2296:					     ERR_NO_MEMORY_AVAILABLE,
        -: 2297:					     __FILE__, ((long) __LINE__) - 2L,
        -: 2298:					     "rsp_filename", 0);
      140: 2299:	  strcpy (rsp_filename, *argv + 1);
      140: 2300:	  fp = file_open (&rsp_filename, 0, REsponse, &b_dummy);
call    0 returned 100%
      140: 2301:	  if (fp != (FILE *) NULL)
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
        -: 2302:	    {
       26: 2303:	      my_argv =
call    0 returned 92%
       26: 2304:		insert_response_file (fp, rsp_filename,
        -: 2305:				      these_short_opts_need_args,
        -: 2306:				      &my_argc_max, &my_argc, my_argv);
       24: 2307:	      (void) fclose (fp);
call    0 returned 100%
        -: 2308:	    }
      138: 2309:	  free (rsp_filename);
      138: 2310:	  rsp_filename = (char *) NULL;
        -: 2311:	}
        -: 2312:      else
        -: 2313:	{
       63: 2314:	  register int len = (int) strlen (*argv);
        -: 2315:
        -: 2316:
        -: 2317:	  /*
        -: 2318:	     Avoid one or two letter combinations of '-', '/' or '%' characters only!
        -: 2319:	   */
       68: 2320:	  if (((len == 1) && (**argv == *SWITCH
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 2321:#if USE_RC
        4: 2322:			      || **argv == RC_ADATE_CHAR
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -: 2323:#endif
        1: 2324:			      || **argv == *SWITCH2))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       60: 2325:	      || ((len == 2) && (**argv == *SWITCH
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
        -: 2326:#if USE_RC
        8: 2327:				 || **argv == RC_ADATE_CHAR
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -: 2328:#endif
        6: 2329:				 || **argv == *SWITCH2)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        9: 2330:		  && (*(*argv + 1) == *SWITCH
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2331:#if USE_RC
        9: 2332:		      || *(*argv + 1) == RC_ADATE_CHAR
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
        -: 2333:#endif
        7: 2334:		      || *(*argv + 1) == *SWITCH2)))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2335:	    ;			/* Void, don't allocate memory */
        -: 2336:	  else
        -: 2337:	    {
       58: 2338:	      if ((Uint) my_argc >= my_argc_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2339:		{
        -: 2340:		  /*
        -: 2341:		     Resize the `my_argv[]' table.
        -: 2342:		   */
    #####: 2343:		  my_argc_max <<= 1;
    #####: 2344:		  if (my_argc_max * sizeof (char *) > testval)
branch  0 never executed
branch  1 never executed
    #####: 2345:		    my_argc_max--;
    #####: 2346:		  my_argv = (char **) my_realloc ((VOID_PTR) my_argv,
call    0 never executed
    #####: 2347:						  my_argc_max *
        -: 2348:						  sizeof (char *),
        -: 2349:						  ERR_NO_MEMORY_AVAILABLE,
        -: 2350:						  __FILE__,
        -: 2351:						  ((long) __LINE__) - 3L,
        -: 2352:						  "my_argv[my_argc_max]",
        -: 2353:						  my_argc_max);
        -: 2354:		}
       58: 2355:	      my_argv[my_argc] = (char *) my_malloc (len + 1,
call    0 returned 100%
        -: 2356:						     ERR_NO_MEMORY_AVAILABLE,
        -: 2357:						     __FILE__,
        -: 2358:						     ((long) __LINE__) - 2L,
        -: 2359:						     "my_argv[my_argc]",
        -: 2360:						     my_argc);
       58: 2361:	      strcpy (my_argv[my_argc++], *argv);
        -: 2362:	    }
        -: 2363:	}
      201: 2364:      argc--;
        -: 2365:    }
        -: 2366:  /*
        -: 2367:     Building of private `my_argv[]' table is done, so check first whether
        -: 2368:     warning/debug option (`--debug[=0...WARN_LVL_MAX]') is given (needed
        -: 2369:     to set correct warning level in case global date variable definitions
        -: 2370:     follow) and the command execution option (`--execute-command') is
        -: 2371:     given, and then check whether global date variable definitions `-v<>'
        -: 2372:     (or global text variable definitions `-r<>') are given, so we can
        -: 2373:     reference them in the actual date modifier, e.g.,
        -: 2374:     %YYYY@DVAR[[-]N[WW[W]]].
        -: 2375:   */
       89: 2376:  if (my_argc > 1)
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
        -: 2377:    {
        -: 2378:      /*
        -: 2379:         Now it's time to rearrange the `my_argv[]' table, so all short-style
        -: 2380:         options with needed argument like `-X foo' are concatenated to `-Xfoo'.
        -: 2381:       */
       46: 2382:      rearrange_argv (these_short_opts_need_args, &my_argc, my_argv);
call    0 returned 100%
       46: 2383:      i = 1;
      112: 2384:      while (i < my_argc)
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
        -: 2385:	{
       46: 2386:	  ptr_char = my_argv[i];
       46: 2387:	  if (*ptr_char == *SWITCH || *ptr_char == *SWITCH2)
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
branch  2 taken 20% (fallthrough)
branch  3 taken 80%
        -: 2388:	    {
       18: 2389:	      ptr_char++;
       18: 2390:	      if (*ptr_char == *SWITCH)
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
        -: 2391:		{
        -: 2392:		  /*
        -: 2393:		     Long-style option given:
        -: 2394:		     Convert it to an according short-style option.
        -: 2395:		   */
        7: 2396:		  ptr_char++;
        -: 2397:		  /*
        -: 2398:		     Copy this long-style option into a buffer.
        -: 2399:		   */
        7: 2400:		  j = (int) strlen (ptr_char);
        7: 2401:		  if ((Uint) j >= maxlen_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2402:		    resize_all_strings (j + 1, FALSE, __FILE__,
call    0 never executed
        -: 2403:					(long) __LINE__);
        7: 2404:		  strcpy (s3, ptr_char);
        -: 2405:		  /*
        -: 2406:		     Check this long-style option.
        -: 2407:		   */
        7: 2408:		  if (!eval_longopt (s3, &lopt_id))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2409:		    ptr_char = s3;
        -: 2410:		  else
        -: 2411:		    /*
        -: 2412:		       Error in given long-style option detected:
        -: 2413:		       Skip this long-style option only!
        -: 2414:		     */
        7: 2415:		    ptr_char = s3 + strlen (s3);
        -: 2416:		}
        -: 2417:	      else
       11: 2418:		lopt_id = SYM_NIL;
       18: 2419:	      if (lopt_id == SYM_DEBUG)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2420:		warning_level = my_atoi (ptr_char);
call    0 never executed
        -: 2421:#if USE_RC
       18: 2422:	      else if (lopt_id == SYM_EXECUTE_COMMAND)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2423:		rc_execute_command = TRUE;
       18: 2424:	      else if (*ptr_char == 'r')
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2425:		{
    #####: 2426:		  ptr_char++;
        -: 2427:		  /*
        -: 2428:		     Global text variable definition found
        -: 2429:		     (e.g.: -r$a=TEXT1:$b=TEXT2:$c=$a...):
        -: 2430:		     Try to scan this argument and store found TEXTs
        -: 2431:		     into the text variable table.
        -: 2432:		   */
    #####: 2433:		  while (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 2434:		    {
        -: 2435:		      /*
        -: 2436:		         Split the SEP (colon) separated list of text variables.
        -: 2437:		       */
    #####: 2438:		      j = 0;
    #####: 2439:		      while (*ptr_char && (*ptr_char != *SEP))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2440:			{
    #####: 2441:			  if ((Uint) j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 2442:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -: 2443:						__FILE__, (long) __LINE__);
    #####: 2444:			  s1[j++] = *ptr_char++;
        -: 2445:			  /*
        -: 2446:			     Take a quoted SEP (colon) separator as is,
        -: 2447:			     but remove the quote character.
        -: 2448:			   */
    #####: 2449:			  if ((*ptr_char == *SEP)
branch  0 never executed
branch  1 never executed
    #####: 2450:			      && (s1[j - 1] == QUOTE_CHAR))
branch  0 never executed
branch  1 never executed
    #####: 2451:			    s1[j - 1] = *ptr_char++;
        -: 2452:			}
    #####: 2453:		      s1[j] = '\0';
    #####: 2454:		      pseudo_blank_conversion (&s1);
call    0 never executed
    #####: 2455:		      set_tvar (s1, _("Internal"), 0L, GLobal);
call    0 never executed
    #####: 2456:		      if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 2457:			ptr_char++;
        -: 2458:		    }
        -: 2459:		}
       18: 2460:	      else if (*ptr_char == 'v')
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2461:		{
    #####: 2462:		  ptr_char++;
        -: 2463:		  /*
        -: 2464:		     Global text variable definition found
        -: 2465:		     (e.g.: -va=1227:b=0514:c=a...):
        -: 2466:		     Try to scan this argument and store found MMDD
        -: 2467:		     dates into the date variable table.
        -: 2468:		   */
    #####: 2469:		  while (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 2470:		    {
        -: 2471:		      /*
        -: 2472:		         Split the SEP (colon) separated list of date variables.
        -: 2473:		       */
    #####: 2474:		      j = 0;
    #####: 2475:		      while (*ptr_char && (*ptr_char != *SEP))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2476:			{
    #####: 2477:			  if ((Uint) j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 2478:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -: 2479:						__FILE__, (long) __LINE__);
    #####: 2480:			  s1[j++] = *ptr_char++;
        -: 2481:			}
    #####: 2482:		      s1[j] = '\0';
    #####: 2483:		      set_dvar (s1, lineptrs, _("Internal"), 0L, GLobal);
call    0 never executed
    #####: 2484:		      if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 2485:			ptr_char++;
        -: 2486:		    }
        -: 2487:		}
        -: 2488:#endif /* USE_RC */
        -: 2489:	    }
        -: 2490:	  /*
        -: 2491:	     Stop processing if the first command is found.
        -: 2492:	   */
       46: 2493:	  if ((*my_argv[i] != *SWITCH) && (*my_argv[i] != *SWITCH2)
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
        -: 2494:#if USE_RC
       28: 2495:	      && (*my_argv[i] != RC_ADATE_CHAR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2496:#endif
       28: 2497:	      && (*my_argv[i] != RSP_CHAR))
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
       26: 2498:	    break;
       20: 2499:	  i++;
        -: 2500:	}
        -: 2501:    }
        -: 2502:#if USE_RC
        -: 2503:  /*
        -: 2504:     Check whether an actual date modifier %DATE is given.
        -: 2505:   */
       89: 2506:  if (my_argc > 1)
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
        -: 2507:    {
       46: 2508:      i = 1;
      110: 2509:      while (i < my_argc)
branch  0 taken 72%
branch  1 taken 28% (fallthrough)
        -: 2510:	{
       46: 2511:	  if (*my_argv[i] == RC_ADATE_CHAR)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2512:	    rc_adate = my_argv[i] + 1;
        -: 2513:	  /*
        -: 2514:	     Stop processing if the first command is found.
        -: 2515:	   */
       46: 2516:	  if ((*my_argv[i] != *SWITCH)
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
       35: 2517:	      && (*my_argv[i] != *SWITCH2) && (*my_argv[i] != RC_ADATE_CHAR))
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       28: 2518:	    break;
       18: 2519:	  i++;
        -: 2520:	}
        -: 2521:    }
        -: 2522:#endif /* USE_RC */
        -: 2523:#ifdef GCAL_EPAGER
       89: 2524:  if (is_tty)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2525:    {
        -: 2526:      /*
        -: 2527:         Try to detect the external pager program in a safe way.  This
        -: 2528:         means first to detect whether a $PAGER environment variable is set,
        -: 2529:         if so, try to use this pager program, otherwise try to use one of
        -: 2530:         the burned-in pager names of `ext_pager[]' table.
        -: 2531:       */
    #####: 2532:      ptr_char = getenv (ENV_VAR_PAGER);
call    0 never executed
    #####: 2533:      if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 2534:	{
    #####: 2535:	  if (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 2536:	    {
    #####: 2537:	      while (isspace (*ptr_char))
branch  0 never executed
branch  1 never executed
    #####: 2538:		ptr_char++;
    #####: 2539:	      i = (int) strlen (ptr_char);
    #####: 2540:	      if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 2541:		resize_all_strings (i + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####: 2542:	      strcpy (s3, ptr_char);
    #####: 2543:	      if (*ptr_char != *DIR_SEP)
branch  0 never executed
branch  1 never executed
        -: 2544:		{
    #####: 2545:		  ptr_char = strrchr (s3, *DIR_SEP);
    #####: 2546:		  if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 2547:		    ptr_char++;
        -: 2548:		  else
    #####: 2549:		    ptr_char = s3;
        -: 2550:		}
    #####: 2551:	      j = strlen (ptr_char);
    #####: 2552:	      ext_pager = (char *) my_malloc (j + 1,
call    0 never executed
        -: 2553:					      ERR_NO_MEMORY_AVAILABLE,
        -: 2554:					      __FILE__,
        -: 2555:					      ((long) __LINE__) - 2L,
        -: 2556:					      "ext_pager", 0);
    #####: 2557:	      strcpy (ext_pager, ptr_char);
    #####: 2558:	      i = 0;
    #####: 2559:	      while (ext_pager[i] && !isspace (ext_pager[i]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2560:		i++;
    #####: 2561:	      ext_pager[i] = '\0';
    #####: 2562:	      if (*ext_pager == *DIR_SEP)
branch  0 never executed
branch  1 never executed
        -: 2563:		{
        -: 2564:		  /*
        -: 2565:		     Absolute pager name given, try to get this executable directly.
        -: 2566:		   */
        -: 2567:# if HAVE_SYS_STAT_H && defined(S_IFMT) && defined(S_IFREG)
        -: 2568:		  auto struct stat statbuf;
        -: 2569:
        -: 2570:
        -: 2571:		  /*
        -: 2572:		     Test if the file is a regular file, if not, ignore it!
        -: 2573:		   */
    #####: 2574:		  if (!stat (ext_pager, &statbuf))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2575:		    if ((statbuf.st_mode & S_IFMT) == S_IFREG)
branch  0 never executed
branch  1 never executed
    #####: 2576:		      fp = fopen (ext_pager, "r");
call    0 never executed
        -: 2577:# else /* !HAVE_SYS_STAT_H || !S_IFMT || !S_IFREG */
        -: 2578:		  fp = fopen (ext_pager, "r");
        -: 2579:# endif	/* !HAVE_SYS_STAT_H || !S_IFMT || !S_IFREG */
        -: 2580:		}
        -: 2581:	      else
        -: 2582:		/*
        -: 2583:		   Relative pager name given, search this executable
        -: 2584:		   using the $PATH environment variable.
        -: 2585:		 */
    #####: 2586:		fp = file_open (&ext_pager, 0, COmmon, &b_dummy);
call    0 never executed
    #####: 2587:	      if (fp == (FILE *) NULL)
branch  0 never executed
branch  1 never executed
        -: 2588:		{
    #####: 2589:		  free (ext_pager);
    #####: 2590:		  ext_pager = (char *) NULL;
        -: 2591:		}
        -: 2592:	      else
        -: 2593:		{
    #####: 2594:		  (void) fclose (fp);
call    0 never executed
    #####: 2595:		  if (i != j)
branch  0 never executed
branch  1 never executed
        -: 2596:		    {
    #####: 2597:		      register Uint pg_argc_max = MY_ARGC_MAX;
    #####: 2598:		      register int pg_argc = 0;
    #####: 2599:		      register int k = j;
        -: 2600:
        -: 2601:
        -: 2602:		      /*
        -: 2603:		         Initial memory allocation for the `pg_argv[]' table.
        -: 2604:		       */
    #####: 2605:		      pg_argv =
    #####: 2606:			(char **) my_malloc (MY_ARGC_MAX * sizeof (char *),
call    0 never executed
        -: 2607:					     ERR_NO_MEMORY_AVAILABLE,
        -: 2608:					     __FILE__, ((long) __LINE__) - 2L,
        -: 2609:					     "pg_argv[MY_ARGC_MAX]",
        -: 2610:					     MY_ARGC_MAX);
        -: 2611:		      /*
        -: 2612:		         Now copy the name of the $PAGER executable into
        -: 2613:		         `pg_argv[]' table at position 0;
        -: 2614:		       */
    #####: 2615:		      pg_argv[pg_argc] = (char *) my_malloc (i + 1,
call    0 never executed
        -: 2616:							     ERR_NO_MEMORY_AVAILABLE,
        -: 2617:							     __FILE__,
        -: 2618:							     ((long) __LINE__)
        -: 2619:							     - 2L,
        -: 2620:							     "pg_argv[pg_argc]",
        -: 2621:							     pg_argc);
    #####: 2622:		      strcpy (pg_argv[pg_argc++], ext_pager);
        -: 2623:		      /*
        -: 2624:		         Now copy the command line arguments which are delivered
        -: 2625:		         to the $PAGER executable into `pg_argv[]' table at
        -: 2626:		         position `pg_argc'.
        -: 2627:		       */
    #####: 2628:		      j = i + 1;
        -: 2629:		      LOOP
        -: 2630:		      {
    #####: 2631:			if ((Uint) pg_argc >= pg_argc_max)
branch  0 never executed
branch  1 never executed
        -: 2632:			  {
        -: 2633:			    /*
        -: 2634:			       Resize the `pg_argv[]' table.
        -: 2635:			     */
    #####: 2636:			    pg_argc_max <<= 1;
    #####: 2637:			    if (pg_argc_max * sizeof (char *) > testval)
branch  0 never executed
branch  1 never executed
    #####: 2638:			      pg_argc_max--;
    #####: 2639:			    pg_argv =
    #####: 2640:			      (char **) my_realloc ((VOID_PTR) pg_argv,
call    0 never executed
    #####: 2641:						    pg_argc_max *
        -: 2642:						    sizeof (char *),
        -: 2643:						    ERR_NO_MEMORY_AVAILABLE,
        -: 2644:						    __FILE__,
        -: 2645:						    ((long) __LINE__) - 3L,
        -: 2646:						    "pg_argv[pg_argc_max]",
        -: 2647:						    pg_argc_max);
        -: 2648:			  }
    #####: 2649:			while (isspace (ext_pager[j]))
branch  0 never executed
branch  1 never executed
    #####: 2650:			  j++;
    #####: 2651:			if (!ext_pager[j])
branch  0 never executed
branch  1 never executed
    #####: 2652:			  break;
    #####: 2653:			ptr_char = ext_pager + j;
    #####: 2654:			while (*ptr_char && !isspace (*ptr_char))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2655:			  ptr_char++;
    #####: 2656:			if (!*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 2657:			  ptr_char = ext_pager + k;
    #####: 2658:			i = ptr_char - (ext_pager + j);
    #####: 2659:			if (!i)
branch  0 never executed
branch  1 never executed
    #####: 2660:			  break;
    #####: 2661:			*ptr_char = '\0';
    #####: 2662:			pg_argv[pg_argc] = (char *) my_malloc (i + 1,
call    0 never executed
        -: 2663:							       ERR_NO_MEMORY_AVAILABLE,
        -: 2664:							       __FILE__,
        -: 2665:							       ((long)
        -: 2666:								__LINE__) -
        -: 2667:							       2L,
        -: 2668:							       "pg_argv[pg_argc]",
        -: 2669:							       pg_argc);
    #####: 2670:			strcpy (pg_argv[pg_argc++], ext_pager + j);
    #####: 2671:			j += i;
    #####: 2672:			if (j >= k)
branch  0 never executed
branch  1 never executed
    #####: 2673:			  break;
    #####: 2674:			j++;
        -: 2675:		      }
        -: 2676:		      /*
        -: 2677:		         And terminate the `pg_argv[]' table by a final NULL element.
        -: 2678:		       */
    #####: 2679:		      if ((Uint) pg_argc >= pg_argc_max)
branch  0 never executed
branch  1 never executed
        -: 2680:			{
        -: 2681:			  /*
        -: 2682:			     Resize the `pg_argv[]' table.
        -: 2683:			   */
    #####: 2684:			  pg_argc_max <<= 1;
    #####: 2685:			  if (pg_argc_max * sizeof (char *) > testval)
branch  0 never executed
branch  1 never executed
    #####: 2686:			    pg_argc_max--;
    #####: 2687:			  pg_argv = (char **) my_realloc ((VOID_PTR) pg_argv,
call    0 never executed
    #####: 2688:							  pg_argc_max *
        -: 2689:							  sizeof (char *),
        -: 2690:							  ERR_NO_MEMORY_AVAILABLE,
        -: 2691:							  __FILE__,
        -: 2692:							  ((long) __LINE__) -
        -: 2693:							  3L,
        -: 2694:							  "pg_argv[pg_argc_max]",
        -: 2695:							  pg_argc_max);
        -: 2696:			}
    #####: 2697:		      pg_argv[pg_argc] = (char *) NULL;
        -: 2698:		    }
        -: 2699:		}
        -: 2700:	    }
        -: 2701:	}
    #####: 2702:      if (ext_pager == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 2703:	{
    #####: 2704:	  i = 0;
    #####: 2705:	  while (pagers[i] != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 2706:	    {
    #####: 2707:	      ext_pager = (char *) my_malloc (strlen (pagers[i]) + 1,
call    0 never executed
        -: 2708:					      ERR_NO_MEMORY_AVAILABLE,
        -: 2709:					      __FILE__,
        -: 2710:					      ((long) __LINE__) - 2L,
        -: 2711:					      "ext_pager", 0);
    #####: 2712:	      strcpy (ext_pager, pagers[i]);
    #####: 2713:	      fp = file_open (&ext_pager, 0, COmmon, &b_dummy);
call    0 never executed
    #####: 2714:	      if (fp != (FILE *) NULL)
branch  0 never executed
branch  1 never executed
        -: 2715:		{
    #####: 2716:		  (void) fclose (fp);
call    0 never executed
    #####: 2717:		  break;
        -: 2718:		}
    #####: 2719:	      free (ext_pager);
    #####: 2720:	      ext_pager = (char *) NULL;
    #####: 2721:	      i++;
        -: 2722:	    }
        -: 2723:	}
        -: 2724:      /*
        -: 2725:         If we have found an external pager program, we'll use it!
        -: 2726:       */
    #####: 2727:      if (ext_pager != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 2728:	{
        -: 2729:	  /*
        -: 2730:	     We work unbuffered in this case so we have to flush the stdout buffer first.
        -: 2731:	   */
    #####: 2732:	  fflush (stdout);
call    0 never executed
        -: 2733:	  /*
        -: 2734:	     Open an unnamed pipe.
        -: 2735:	   */
    #####: 2736:	  if (pipe (pipe_fd) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2737:	    /*
        -: 2738:	       Error, `pipe()' function failed.
        -: 2739:	     */
    #####: 2740:	    my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 2741:		      ((long) __LINE__) - 4L, "pipe()<", 0);
        -: 2742:# if HAVE_SIGNAL && defined(SIGPIPE)
        -: 2743:	  /*
        -: 2744:	     Ignore the SIGPIPE signal.
        -: 2745:	   */
    #####: 2746:	  (void) signal (SIGPIPE, SIG_IGN);
call    0 never executed
        -: 2747:# endif
        -: 2748:	}
        -: 2749:    }
        -: 2750:#endif /* GCAL_EPAGER */
        -: 2751:  /*
        -: 2752:     Check and evaluate the command line arguments and detect,
        -: 2753:     whether a list/range of extended years or other lists/ranges of
        -: 2754:     months/years are wanted.
        -: 2755:   */
       89: 2756:  check_command_line (my_argc, my_argv);
call    0 returned 83%
        -: 2757:  /*
        -: 2758:     If an invalid date format is found, exit the program with error message!
        -: 2759:   */
       74: 2760:  if (errtxt_dformat != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2761:    my_error (ERR_INVALID_DATE_FORMAT, errtxt_dformat, 0,
call    0 never executed
    #####: 2762:	      date_format->df_format, 0);
        -: 2763:#ifdef GCAL_EMAIL
        -: 2764:  /*
        -: 2765:     In case Gcal's output must be send to a user via eMail:
        -: 2766:     Create and open a temporary file.
        -: 2767:   */
       74: 2768:  if (email_adr != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2769:    {
    #####: 2770:      ptr_char = TMPFILENAME;
call    0 never executed
    #####: 2771:      if (ptr_char == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 2772:	my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 2773:		  ((long) __LINE__) - 2L, "tmpnam()=", 0);
    #####: 2774:      tfn =
    #####: 2775:	(char *) my_malloc (strlen (ptr_char) + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 never executed
        -: 2776:			    __FILE__, ((long) __LINE__) - 2L, "tfn", 0);
    #####: 2777:      strcpy (tfn, ptr_char);
    #####: 2778:      tfp = fopen (tfn, "w");
call    0 never executed
    #####: 2779:      if (tfp == (FILE *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 2780:	my_error (ERR_WRITE_FILE, __FILE__, ((long) __LINE__) - 2L, tfn, 0);
call    0 never executed
    #####: 2781:      is_tty = (int) FALSE;
        -: 2782:    }
        -: 2783:#endif /* GCAL_EMAIL */
        -: 2784:  /*
        -: 2785:     Do we have to suppress the output of a month calendar in case only
        -: 2786:     the `-n|N[-]' option (display eternal holiday list) is found and/or
        -: 2787:     only the `-c[]' option (display fixed dates list) is found?
        -: 2788:   */
       74: 2789:  if (!year && !month && (holiday_flag
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -: 2790:#if USE_RC
       73: 2791:			  || rc_use_flag
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -: 2792:#endif
        3: 2793:      ) && !year_flag)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3: 2794:    show_calendar = FALSE;
        -: 2795:  else
        -: 2796:    /*
        -: 2797:       It's sure that we have to suppress a month/year calendar sheet,
        -: 2798:       because the `-u' option is given in the command line!
        -: 2799:       If NO eternal holiday list option (`-n|N[-]') AND NO fixed dates
        -: 2800:       list option (`-c|C[]') is given, we have to avoid the call
        -: 2801:       of the calendar sheet creating function `print_calendar()';
        -: 2802:       this case is marked by setting `show_calendar' to FALSE!
        -: 2803:     */
       71: 2804:    if (suppr_cal_flag
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2805:#if USE_RC
    #####: 2806:	&& !rc_use_flag
branch  0 never executed
branch  1 never executed
        -: 2807:#endif
    #####: 2808:	&& !holiday_flag)
branch  0 never executed
branch  1 never executed
    #####: 2809:    show_calendar = FALSE;
        -: 2810:#if USE_RC
        -: 2811:  /*
        -: 2812:     Check whether an explicit date is given in the command line.
        -: 2813:   */
       74: 2814:  is_date_given = (Bool) (month || year || is_fiscal_year);
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
       74: 2815:  if (rc_use_flag && ((!month && year) || is_fiscal_year))
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
    #####: 2816:    date_enables_year = TRUE;
       74: 2817:  if (rc_filename != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2818:    pseudo_blank_conversion (&rc_filename);
call    0 never executed
       74: 2819:  if (rc_filter_text != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2820:    pseudo_blank_conversion (&rc_filter_text);
call    0 never executed
        -: 2821:#endif /* USE_RC */
        -: 2822:  /*
        -: 2823:     Check whether the arguments of command line are valid.
        -: 2824:   */
       74: 2825:  eliminate_invalid_data ();
call    0 returned 100%
        -: 2826:  /*
        -: 2827:     Get the highlighting sequences of the terminal.
        -: 2828:   */
       74: 2829:  get_tty_hls (hl_seq);
call    0 returned 100%
        -: 2830:#if USE_PAGER
        -: 2831:  /*
        -: 2832:     No program output yet, so if the paging option is wanted:
        -: 2833:     Set the standard stream buffers to unbuffered mode
        -: 2834:     and get actual settings of the tty.
        -: 2835:   */
       74: 2836:  if (is_tty1 && is_tty2
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2837:# ifdef GCAL_EPAGER
    #####: 2838:      && (ext_pager == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 2839:# endif
    #####: 2840:      && pager_flag)
branch  0 never executed
branch  1 never executed
        -: 2841:    {
    #####: 2842:      setbuf (stdout, (char *) NULL);
call    0 never executed
    #####: 2843:      setbuf (stdin, (char *) NULL);
call    0 never executed
    #####: 2844:      get_tty_scr_size (&tty_rows, &tty_cols);
call    0 never executed
        -: 2845:    }
        -: 2846:#endif /* USE_PAGER */
        -: 2847:#if USE_RC
        -: 2848:  /*
        -: 2849:     If any `-# ARG' resp., `--here=ARG' options are found:
        -: 2850:     Close temporary file which is used for managing all "here" options
        -: 2851:     (it contains all "here" lines now) so it can be used at the end
        -: 2852:     of each resource file processing step/cycle.
        -: 2853:   */
       74: 2854:  if (rc_here_fn != (char *) NULL)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        3: 2855:    if (fclose (rc_here_fp) == EOF)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####: 2856:      my_error (ERR_WRITE_FILE, __FILE__, ((long) __LINE__) - 1L, rc_here_fn,
call    0 never executed
        -: 2857:		0);
        -: 2858:#endif
        -: 2859:  /*
        -: 2860:     Log contents of command line:
        -: 2861:     I.e. check whether a response file must be written.
        -: 2862:   */
       74: 2863:  if (rsp_filename != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2864:    write_log_file (rsp_filename, REsponse, _("response file"), _("Created"),
call    0 never executed
        -: 2865:		    my_argc, my_argv);
        -: 2866:#ifdef GCAL_SHELL
        -: 2867:  /*
        -: 2868:     Log contents of command line:
        -: 2869:     i.e. check whether a shell script must be written
        -: 2870:   */
       74: 2871:  if (shl_filename != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2872:    write_log_file (shl_filename, SCript, _("shell script"), _("Created"),
call    0 never executed
        -: 2873:		    my_argc, my_argv);
        -: 2874:#endif /* GCAL_SHELL */
        -: 2875:#ifdef GCAL_EPAGER
       74: 2876:  if (is_tty1
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
       32: 2877:      && is_tty2
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2878:      && pager_flag
branch  0 never executed
branch  1 never executed
    #####: 2879:      && (ext_pager != (char *) NULL) && (email_adr == (char *) NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2880:    {
    #####: 2881:      child_pid = fork ();
call    0 never executed
    #####: 2882:      switch (child_pid)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 2883:	{
    #####: 2884:	case -1:
        -: 2885:	  /*
        -: 2886:	     Error, `fork()' function failed.
        -: 2887:	   */
    #####: 2888:	  my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 2889:		    ((long) __LINE__) - 7L, "fork() child_pid=", child_pid);
        -: 2890:	  /* Not reached. */
    #####: 2891:	case 0:
        -: 2892:	  /*
        -: 2893:	     Child process (read from pipe):
        -: 2894:	     Connect PIPE-STDIN to SYS-STDIN in a safe way
        -: 2895:	     and launch the external pager program.
        -: 2896:	   */
    #####: 2897:	  close (pipe_fd[1]);
call    0 never executed
    #####: 2898:	  if (pipe_fd[0])
branch  0 never executed
branch  1 never executed
        -: 2899:	    {
    #####: 2900:	      close (0);
call    0 never executed
    #####: 2901:	      dup (pipe_fd[0]);
call    0 never executed
    #####: 2902:	      close (pipe_fd[0]);
call    0 never executed
        -: 2903:	    }
    #####: 2904:	  if (pg_argv == (char **) NULL)
branch  0 never executed
branch  1 never executed
        -: 2905:	    {
    #####: 2906:	      i = execlp (ext_pager, ext_pager, (char *) NULL);
        -: 2907:	      /*
        -: 2908:	         Error, `execlp()' function failed
        -: 2909:	         (this line should never be executed)!
        -: 2910:	       */
    #####: 2911:	      j = (int) strlen (ext_pager) + LEN_SINGLE_LINE;
    #####: 2912:	      if ((Uint) j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 2913:		resize_all_strings (j + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####: 2914:	      sprintf (s1, "execlp(%s)=", ext_pager);
    #####: 2915:	      my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 2916:			((long) __LINE__) - 9L, s1, i);
        -: 2917:	    }
        -: 2918:	  else
        -: 2919:	    {
    #####: 2920:	      i = execvp (ext_pager, pg_argv);
        -: 2921:	      /*
        -: 2922:	         Error, `execvp()' function failed
        -: 2923:	         (this line should never be executed)!
        -: 2924:	       */
    #####: 2925:	      j = (int) strlen (ext_pager) + LEN_SINGLE_LINE;
    #####: 2926:	      if ((Uint) j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 2927:		resize_all_strings (j + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####: 2928:	      sprintf (s1, "execvp(%s)=", ext_pager);
    #####: 2929:	      my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 2930:			((long) __LINE__) - 9L, s1, i);
        -: 2931:	    }
        -: 2932:	  /* Not reached. */
        -: 2933:	default:
        -: 2934:	  /*
        -: 2935:	     Parent process (write to pipe):
        -: 2936:	     Connect PIPE-stdout to SYS-stdout in a safe way
        -: 2937:	     and initiate the action.
        -: 2938:	   */
    #####: 2939:	  close (pipe_fd[0]);
call    0 never executed
    #####: 2940:	  if (pipe_fd[1] != 1)
branch  0 never executed
branch  1 never executed
        -: 2941:	    {
    #####: 2942:	      close (1);
call    0 never executed
    #####: 2943:	      if (!dup (pipe_fd[1]))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2944:		{
    #####: 2945:		  dup (pipe_fd[1]);
call    0 never executed
    #####: 2946:		  close (0);
call    0 never executed
        -: 2947:		}
    #####: 2948:	      close (pipe_fd[1]);
call    0 never executed
        -: 2949:	    }
        -: 2950:	}
        -: 2951:    }
        -: 2952:#endif /* GCAL_EPAGER */
        -: 2953:  /*
        -: 2954:     And now display the calendar sheet(s)!
        -: 2955:   */
       74: 2956:  if (show_calendar)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
       71: 2957:    print_calendar ();
call    0 returned 100%
        -: 2958:  else
        -: 2959:    /*
        -: 2960:       Only the `-n|N[-]' option (display eternal holiday list) is found
        -: 2961:       and/or only the `-c[]' option (display fixed dates) is found,
        -: 2962:       display these list(s) without/omitting a leading month calendar.
        -: 2963:     */
        3: 2964:    if (holiday_flag
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2965:#if USE_RC
        3: 2966:	|| rc_use_flag
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2967:#endif
        -: 2968:    )
        -: 2969:    {
        3: 2970:      register int tmp_ad = act_day;
        -: 2971:
        -: 2972:
        3: 2973:      is_leap_year = (days_of_february (year) == 29);
call    0 returned 100%
        3: 2974:      if (is_fiscal_year)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2975:	fiscal_month = (*month_list).ml_month;
        3: 2976:      if (cal_special_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2977:	act_day = day_of_year (tmp_ad, act_month, act_year);
call    0 never executed
        3: 2978:      if (((year == EASTER_MIN - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2979:	   && (fiscal_month > MONTH_MIN))
branch  0 never executed
branch  1 never executed
        3: 2980:	  || ((year >= EASTER_MIN) && (year <= EASTER_MAX)))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        3: 2981:	print_all_holidays (FALSE, TRUE);
call    0 returned 100%
        3: 2982:      if (cal_special_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2983:	act_day = tmp_ad;
        -: 2984:    }
        -: 2985:  /*
        -: 2986:     If the simple month/year mode is active...
        -: 2987:   */
       74: 2988:  if (!month_list[1].ml_month)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2989:    {
       74: 2990:      if (is_fiscal_year || (holiday_flag && !show_calendar))
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
        1: 2991:	month = 0;
        -: 2992:#if USE_RC
       74: 2993:      if (rc_use_flag)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        3: 2994:	rc_use ();
call    0 returned 67%
        -: 2995:#endif
       73: 2996:      if (holiday_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2997:	{
    #####: 2998:	  if (((year == EASTER_MIN - 1)
branch  0 never executed
branch  1 never executed
    #####: 2999:	       && (fiscal_month == 1))
branch  0 never executed
branch  1 never executed
    #####: 3000:	      || year < EASTER_MIN - 1 || year > EASTER_MAX)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3001:	    /*
        -: 3002:	       Error, invalid year given for computing Easter Sunday's date.
        -: 3003:	     */
    #####: 3004:	    my_error (ERR_INVALID_EASTER_DATE, "", 0L, "", 0);
call    0 never executed
    #####: 3005:	  print_all_holidays (FALSE, FALSE);
call    0 never executed
        -: 3006:	}
        -: 3007:    }
        -: 3008:#ifdef GCAL_EPAGER
       73: 3009:  if (is_tty1
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
       32: 3010:      && is_tty2
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3011:      && pager_flag
branch  0 never executed
branch  1 never executed
    #####: 3012:      && (ext_pager != (char *) NULL) && (email_adr == (char *) NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3013:    {
        -: 3014:      /*
        -: 3015:         We work unbuffered in this case so we have to flush the stdout buffer
        -: 3016:         for showing all contents of it.
        -: 3017:       */
    #####: 3018:      fflush (stdout);
call    0 never executed
        -: 3019:      /*
        -: 3020:         And reconnect the SYS-STDIN/SYS-STDOUT file descriptors.
        -: 3021:       */
    #####: 3022:      close (0);
call    0 never executed
    #####: 3023:      dup (sys_fd[0]);
call    0 never executed
    #####: 3024:      close (1);
call    0 never executed
    #####: 3025:      dup (sys_fd[1]);
call    0 never executed
        -: 3026:      /*
        -: 3027:         And wait until the child has performed all actions.
        -: 3028:       */
    #####: 3029:      while (wait ((int *) NULL) != child_pid)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3030:	;
        -: 3031:# if HAVE_SIGNAL && defined(SIGPIPE)
        -: 3032:      /*
        -: 3033:         Reset the SIGPIPE signal.
        -: 3034:       */
    #####: 3035:      (void) signal (SIGPIPE, SIG_DFL);
call    0 never executed
        -: 3036:# endif
        -: 3037:    }
        -: 3038:#endif /* GCAL_EPAGER */
        -: 3039:#ifdef GCAL_EMAIL
        -: 3040:  /*
        -: 3041:     If the mailing option is selected:
        -: 3042:     Close temporary file, redirect it to mailer and then erase it.
        -: 3043:   */
       73: 3044:  if (email_adr != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3045:    {
    #####: 3046:      if (fclose (tfp) == EOF)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3047:	my_error (ERR_WRITE_FILE, __FILE__, ((long) __LINE__) - 1L, tfn, 0);
call    0 never executed
        -: 3048:      else
        -: 3049:	{
        -: 3050:	  /*
        -: 3051:	     Check whether the temporary file is "empty" (zero contents).
        -: 3052:	   */
        -: 3053:# if HAVE_SYS_STAT_H
        -: 3054:	  auto struct stat statbuf;
        -: 3055:
        -: 3056:
    #####: 3057:	  tfp = (FILE *) NULL;
        -: 3058:	  /*
        -: 3059:	     Get the size of the temporary file.
        -: 3060:	     If it's not accessable, report a serious error.
        -: 3061:	   */
    #####: 3062:	  if (!stat (tfn, &statbuf))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 3063:	    i = (statbuf.st_size > 0);
        -: 3064:	  else
    #####: 3065:	    my_error (ERR_READ_FILE, __FILE__, ((long) __LINE__) - 3L, tfn,
call    0 never executed
        -: 3066:		      0);
        -: 3067:# else /* !HAVE_SYS_STAT_H */
        -: 3068:	  i = 0;
        -: 3069:	  tfp = fopen (tfn, "r");
        -: 3070:	  if (tfp == (FILE *) NULL)
        -: 3071:	    my_error (ERR_READ_FILE, __FILE__, ((long) __LINE__) - 2L, tfn,
        -: 3072:		      0);
        -: 3073:	  i = fgetc (tfp);
        -: 3074:	  if (fclose (tfp) == EOF)
        -: 3075:	    my_error (ERR_READ_FILE, __FILE__, ((long) __LINE__) - 1L, tfn,
        -: 3076:		      0);
        -: 3077:	  tfp = (FILE *) NULL;
        -: 3078:	  i = (i != EOF);
        -: 3079:# endif	/* !HAVE_SYS_STAT_H */
        -: 3080:	}
    #####: 3081:      if (i)
branch  0 never executed
branch  1 never executed
        -: 3082:	{
    #####: 3083:	  sprintf (s2, _("Mail from \\`%s' (%02d-%s-%04d %02d%s%02d%s%02d"),
call    0 never executed
        -: 3084:		   prgr_name, true_day, short_month_name (true_month),
        -: 3085:		   true_year, act_hour, time_sep, act_min, time_sep, act_sec);
    #####: 3086:	  if (tz != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 3087:	    {
    #####: 3088:	      sprintf (s1, " %s", tz);
    #####: 3089:	      strcat (s2, s1);
        -: 3090:	    }
    #####: 3091:	  strcat (s2, ")");
        -: 3092:# if !defined(AMIGA) || defined(__GNUC__)
        -: 3093:	  /*
        -: 3094:	     Detect whether a $MAILPROG environment variable is set.
        -: 3095:	   */
    #####: 3096:	  ptr_char = getenv (ENV_VAR_MAILPROG);
call    0 never executed
    #####: 3097:	  if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 3098:	    {
    #####: 3099:	      if (!*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 3100:		ptr_char = MAIL_PRGR;
        -: 3101:	    }
        -: 3102:	  else
        -: 3103:# endif	/* !AMIGA || __GNUC__ */
    #####: 3104:	    ptr_char = MAIL_PRGR;
    #####: 3105:	  i =
    #####: 3106:	    (int) strlen (ptr_char) + strlen (s2) + strlen (email_adr) +
    #####: 3107:	    strlen (REDIRECT_IN) + 9;
    #####: 3108:	  if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 3109:	    resize_all_strings (i + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####: 3110:	  sprintf (s1, "%s -s \"%s\" %s %s %s", ptr_char, s2, email_adr,
        -: 3111:		   REDIRECT_IN, tfn);
        -: 3112:	  /*
        -: 3113:	     And send the eMail to the given `email_adr' NOW.
        -: 3114:	   */
    #####: 3115:	  if (my_system (s1))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3116:	    {
        -: 3117:	      /*
        -: 3118:	         If the "shell" reports a MAIL exit status not equal 0, first try
        -: 3119:	         to erase the temporary file (if this results to an error, this
        -: 3120:	         error has a higher preference than pointing out only that the
        -: 3121:	         mail program has failed, see the next comment to this a few lines
        -: 3122:	         below), and only then, terminate Gcal with error message.
        -: 3123:	       */
    #####: 3124:	      i = unlink (tfn);
call    0 never executed
    #####: 3125:	      if (i)
branch  0 never executed
branch  1 never executed
    #####: 3126:		my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 3127:			  ((long) __LINE__) - 2L, "unlink(tfn)=", i);
    #####: 3128:	      my_error (ERR_EMAIL_SEND_FAILURE, __FILE__,
call    0 never executed
        -: 3129:			((long) __LINE__) - 13L, email_adr, 0);
        -: 3130:	    }
        -: 3131:	}
        -: 3132:      else
    #####: 3133:	fprintf (stderr,
call    0 never executed
        -: 3134:		 _
        -: 3135:		 ("%s: warning, eMail with empty message body not sent to <%s>.\n"),
        -: 3136:		 prgr_name, email_adr);
        -: 3137:
    #####: 3138:      i = unlink (tfn);
call    0 never executed
    #####: 3139:      if (i)
branch  0 never executed
branch  1 never executed
        -: 3140:	/*
        -: 3141:	   Don't ignore any errors, because NOT being able to erase a non-write
        -: 3142:	   protected regular file we have created just some [milli]seconds
        -: 3143:	   before is a serious error that DOES produce trouble in future,
        -: 3144:	   because this is a detection of a bad block of the storage media
        -: 3145:	   in most cases!
        -: 3146:	 */
    #####: 3147:	my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 3148:		  ((long) __LINE__) - 9L, "unlink(tfn)=", i);
        -: 3149:    }
        -: 3150:#endif /* GCAL_EMAIL */
        -: 3151:#if USE_RC
        -: 3152:  /*
        -: 3153:     Erase temporary file which is used for managing all `-# ARG' resp.,
        -: 3154:     `--here=ARG' options if all processing is done.
        -: 3155:   */
       73: 3156:  if (rc_here_fn != (char *) NULL)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -: 3157:    {
        2: 3158:      i = unlink (rc_here_fn);
call    0 returned 100%
        2: 3159:      if (i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3160:	/*
        -: 3161:	   Don't ignore any errors, because NOT being able to erase a non-write
        -: 3162:	   protected regular file we have created some time before is a
        -: 3163:	   serious error that DOES produce trouble in future, because this
        -: 3164:	   is a detection of a bad block of the storage media in most cases!
        -: 3165:	 */
    #####: 3166:	my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 3167:		  ((long) __LINE__) - 8L, "unlink(rc_here_fn)=", i);
        -: 3168:    }
       73: 3169:  if (rc_use_flag
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        2: 3170:      && !shell_escape_done
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 3171:      && (!rc_elems || (rc_zero_dates_flag && !(rc_elems - rc_zero_pos))))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        2: 3172:    exit (ERR_NO_FIXED_DATES_LISTED);
call    0 returned 0%
        -: 3173:#endif
        -: 3174:
       71: 3175:  exit (EXIT_SUCCESS);
        -: 3176:}
        -: 3177:
        -: 3178:
        -: 3179:
        -: 3180:int
function eval_longopt called 12 returned 100% blocks executed 16%
       12: 3181:eval_longopt (longopt, longopt_symbolic)
        -: 3182:     char *longopt;
        -: 3183:     int *longopt_symbolic;
        -: 3184:/*!
        -: 3185:   Evaluates a long option and returns -2...0 if success, +1...+6 if fails:
        -: 3186:     -2 == Given `longopt' successfully parsed and completed `long_name' with argument returned.
        -: 3187:     -1 == Given `longopt' successfully parsed and completed `long_name' returned only.
        -: 3188:      0 == Given `longopt' successfully parsed and corresponding `short_name' returned.
        -: 3189:     +1 == Given `longopt' is ambiguous (not distinguishable).
        -: 3190:     +2 == Given `longopt' is unknown.
        -: 3191:     +3 == Given `longopt' requires no argument (completed `long_name' returned).
        -: 3192:     +4 == Given `longopt' requires an argument
        -: 3193:     +5 == Given `longopt' with invalid argument.
        -: 3194:     +6 == Given `longopt' with ambiguous argument.
        -: 3195:   This function `abort()'s internally if no SPECIAL longoption argument
        -: 3196:     is defined in the `lopt[]' table for a LARG_ONE_OR_ARG mode, but one
        -: 3197:     or some `short_name' entries are in it!  Such a case is illegal!
        -: 3198:   If success and `short_name[0]' isn't set to NULL, the delivered `longopt'
        -: 3199:     is converted to an according `short_name' (UN*X-style) option and returned,
        -: 3200:     otherwise `longopt' is returned unmodified.
        -: 3201:   If success and `short_name[0]' is set to NULL, return the completed
        -: 3202:     `long_name' (with possibly trailing arguments) instead.
        -: 3203:   `&longopt_symbolic' is either set to SYM_NIL if given `longopt' isn't member
        -: 3204:     of field `long_name' in `lopt[]' table or to the according SYM_???.
        -: 3205:*/
        -: 3206:{
       12: 3207:  auto const Lopt_struct *ptr_lopt = lopt;
        -: 3208:
        -: 3209:
       12: 3210:  *longopt_symbolic = SYM_NIL;
       12: 3211:  if (tolower (*longopt) >= tolower (*ptr_lopt->long_name))
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -: 3212:    {
        -: 3213:      /*
        -: 3214:         Check whether first character of `longopt' can be found
        -: 3215:         in `lopt[]' tables structure member `long_name'.
        -: 3216:       */
        8: 3217:      while (tolower (*ptr_lopt->long_name) < tolower (*longopt))
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -: 3218:	{
    #####: 3219:	  ptr_lopt++;
    #####: 3220:	  if (ptr_lopt->long_name == NULL)
branch  0 never executed
branch  1 never executed
    #####: 3221:	    break;
        -: 3222:	}
        4: 3223:      if (ptr_lopt->long_name != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3224:	{
        4: 3225:	  if (tolower (*ptr_lopt->long_name) == tolower (*longopt))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3226:	    {
        4: 3227:	      auto const Lopt_struct *ptr2_lopt = ptr_lopt + 1;
        4: 3228:	      register int len_longopt = (int) strlen (longopt);
        -: 3229:	      auto Bool larg_sep_found;
        4: 3230:	      auto Bool ok = FALSE;
        -: 3231:
        -: 3232:
        4: 3233:	      if (strchr (longopt, *LARG_SEP) != NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3234:		len_longopt -= (int) strlen (strchr (longopt, *LARG_SEP));
        -: 3235:	      /*
        -: 3236:	         First character of `longopt' is found in `lopt[]' tables
        -: 3237:	         structure member `long_name'; now check for the complete
        -: 3238:	         long name or a significant abbreviation of it.
        -: 3239:	       */
        8: 3240:	      while (!ok && (ptr_lopt->long_name != NULL))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        -: 3241:		{
        4: 3242:		  if (ptr2_lopt->long_name != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8: 3243:		    if (!strncasecmp
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4: 3244:			(ptr_lopt->long_name, longopt, len_longopt)
        4: 3245:			&& !strncasecmp (ptr2_lopt->long_name, longopt,
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3246:					 len_longopt))
        -: 3247:		      /*
        -: 3248:		         Error, `longopt' is ambiguous (not distinguishable).
        -: 3249:		       */
        4: 3250:		      return (1);
    #####: 3251:		  if (strncasecmp (ptr_lopt->long_name, longopt, len_longopt))
branch  0 never executed
branch  1 never executed
        -: 3252:		    {
    #####: 3253:		      ptr_lopt++;
    #####: 3254:		      if (ptr_lopt->long_name != NULL)
branch  0 never executed
branch  1 never executed
    #####: 3255:			ptr2_lopt++;
    #####: 3256:		      if ((ptr_lopt->long_name != NULL)
branch  0 never executed
branch  1 never executed
    #####: 3257:			  && (ptr2_lopt->long_name == NULL))
branch  0 never executed
branch  1 never executed
    #####: 3258:			if (!strncasecmp
branch  0 never executed
branch  1 never executed
    #####: 3259:			    (ptr_lopt->long_name, longopt, len_longopt))
    #####: 3260:			  ok = TRUE;
        -: 3261:		    }
        -: 3262:		  else
    #####: 3263:		    ok = TRUE;
        -: 3264:		}
    #####: 3265:	      if (!ok)
branch  0 never executed
branch  1 never executed
        -: 3266:		/*
        -: 3267:		   Error, `longopt' not found (contains a spelling mistake).
        -: 3268:		 */
    #####: 3269:		return (2);
    #####: 3270:	      larg_sep_found =
    #####: 3271:		(Bool) (((int) strlen (longopt) -
        -: 3272:			 len_longopt) ? TRUE : FALSE);
    #####: 3273:	      if (larg_sep_found && (ptr_lopt->larg_mode == LARG_NO))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3274:		{
    #####: 3275:		  strcpy (longopt, ptr_lopt->long_name);
    #####: 3276:		  *longopt_symbolic = ptr_lopt->symbolic_name;
        -: 3277:		  /*
        -: 3278:		     Error, `longopt' requires NO argument.
        -: 3279:		   */
    #####: 3280:		  return (3);
        -: 3281:		}
    #####: 3282:	      if (!larg_sep_found && (ptr_lopt->larg_mode > LARG_NO_OR_ONE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3283:		{
    #####: 3284:		  *longopt_symbolic = ptr_lopt->symbolic_name;
        -: 3285:		  /*
        -: 3286:		     Error, `longopt' requires AN argument.
        -: 3287:		   */
    #####: 3288:		  return (4);
        -: 3289:		}
        -: 3290:	      /*
        -: 3291:	         Valid `longopt' found.
        -: 3292:	       */
    #####: 3293:	      if (ptr_lopt->larg_mode == LARG_NO
branch  0 never executed
branch  1 never executed
    #####: 3294:		  || ((ptr_lopt->larg_mode == LARG_NO_OR_ONE)
branch  0 never executed
branch  1 never executed
    #####: 3295:		      && !larg_sep_found))
branch  0 never executed
branch  1 never executed
        -: 3296:		{
        -: 3297:		  /*
        -: 3298:		     `longopt' requires NO argument (e.g. foo).
        -: 3299:		     Return the FIRST `short_name' of `lopt[]' table if it's
        -: 3300:		     not set to NULL, otherwise return the completed `long_name'.
        -: 3301:		   */
    #####: 3302:		  if (ptr_lopt->short_name[0] == NULL)
branch  0 never executed
branch  1 never executed
        -: 3303:		    {
    #####: 3304:		      strcpy (longopt, ptr_lopt->long_name);
    #####: 3305:		      *longopt_symbolic = ptr_lopt->symbolic_name;
    #####: 3306:		      return (-1);
        -: 3307:		    }
    #####: 3308:		  strcpy (longopt, ptr_lopt->short_name[0]);
        -: 3309:		}
        -: 3310:	      else
        -: 3311:		{
    #####: 3312:		  auto char *ptr_char = longopt + len_longopt + 1;
        -: 3313:		  auto char *larg_longopt;
        -: 3314:
        -: 3315:
        -: 3316:		  /*
        -: 3317:		     `longopt' must have ONE trailing argument (e.g. foo=BAR);
        -: 3318:		     Return the CORRESPONDING `short_name' stored in `lopt[]' table.
        -: 3319:		   */
    #####: 3320:		  if (!*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 3321:		    {
    #####: 3322:		      *longopt_symbolic = ptr_lopt->symbolic_name;
        -: 3323:		      /*
        -: 3324:		         Error, `longopt' isn't trailed by an argument.
        -: 3325:		       */
    #####: 3326:		      return (4);
        -: 3327:		    }
    #####: 3328:		  larg_longopt =
call    0 never executed
    #####: 3329:		    (char *) my_malloc (strlen (longopt) - len_longopt,
        -: 3330:					ERR_NO_MEMORY_AVAILABLE, __FILE__,
        -: 3331:					((long) __LINE__) - 2L,
        -: 3332:					"larg_longopt", 0);
    #####: 3333:		  strcpy (larg_longopt, ptr_char);
    #####: 3334:		  if (ptr_lopt->largs[0] == NULL)
branch  0 never executed
branch  1 never executed
        -: 3335:		    {
        -: 3336:		      /*
        -: 3337:		         Process GIVEN argument.
        -: 3338:		       */
    #####: 3339:		      if (ptr_lopt->short_name[0] == NULL)
branch  0 never executed
branch  1 never executed
        -: 3340:			{
        -: 3341:			  /*
        -: 3342:			     Return the completed `long_name' with GIVEN argument;
        -: 3343:			     the format of returned `longopt' is like:  foo=ARG
        -: 3344:			   */
    #####: 3345:			  strcpy (longopt, ptr_lopt->long_name);
    #####: 3346:			  strcat (longopt, LARG_SEP);
    #####: 3347:			  strcat (longopt, larg_longopt);
    #####: 3348:			  *longopt_symbolic = ptr_lopt->symbolic_name;
    #####: 3349:			  free (larg_longopt);
    #####: 3350:			  return (-2);
        -: 3351:			}
    #####: 3352:		      if (ptr_lopt->larg_mode == LARG_ONE_OR_ARG)
branch  0 never executed
branch  1 never executed
        -: 3353:			/*
        -: 3354:			   Internal error, such a mode MUST HAVE one
        -: 3355:			   SPECIAL longoption argument minimum in the table!
        -: 3356:			 */
    #####: 3357:			abort ();
call    0 never executed
        -: 3358:		      /*
        -: 3359:		         Return the corresponding `short_name' with GIVEN argument;
        -: 3360:		         the format of returned `longopt' is like:  fooARG
        -: 3361:		       */
    #####: 3362:		      strcpy (longopt, ptr_lopt->short_name[0]);
    #####: 3363:		      strcat (longopt, larg_longopt);
        -: 3364:		    }
        -: 3365:		  else
        -: 3366:		    {
    #####: 3367:		      register int i = 0;
        -: 3368:
        -: 3369:
        -: 3370:		      /*
        -: 3371:		         Process SPECIAL argument given.
        -: 3372:		       */
    #####: 3373:		      ok = FALSE;
    #####: 3374:		      i = 0;
    #####: 3375:		      ptr_char = ptr_lopt->largs[i++];
    #####: 3376:		      while (!ok && (ptr_char != NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3377:			{
    #####: 3378:			  if (tolower (*ptr_char) == tolower (*larg_longopt))
branch  0 never executed
branch  1 never executed
        -: 3379:			    {
    #####: 3380:			      register int j = i - 1;
    #####: 3381:			      register int len_larg =
    #####: 3382:				(int) strlen (larg_longopt);
        -: 3383:
        -: 3384:
    #####: 3385:			      if (!strncasecmp
branch  0 never executed
branch  1 never executed
    #####: 3386:				  (ptr_lopt->largs[j], larg_longopt,
        -: 3387:				   len_larg))
        -: 3388:				{
    #####: 3389:				  if (len_larg ==
branch  0 never executed
branch  1 never executed
    #####: 3390:				      (int) strlen (ptr_lopt->largs[j]))
        -: 3391:				    /*
        -: 3392:				       Exact match happened!
        -: 3393:				     */
    #####: 3394:				    ok = TRUE;
        -: 3395:				  else
        -: 3396:				    {
    #####: 3397:				      while (!ok
branch  0 never executed
branch  1 never executed
    #####: 3398:					     && (ptr_lopt->largs[i] != NULL))
branch  0 never executed
branch  1 never executed
        -: 3399:					{
    #####: 3400:					  if (!strncasecmp
branch  0 never executed
branch  1 never executed
    #####: 3401:					      (ptr_lopt->largs[i],
        -: 3402:					       larg_longopt, len_larg)
    #####: 3403:					      && (len_larg ==
branch  0 never executed
branch  1 never executed
    #####: 3404:						  (int) strlen (ptr_lopt->
    #####: 3405:								largs[i])))
        -: 3406:					    /*
        -: 3407:					       Exact match happened!
        -: 3408:					     */
    #####: 3409:					    ok = TRUE;
    #####: 3410:					  i++;
        -: 3411:					}
        -: 3412:				    }
    #####: 3413:				  if (!ok)
branch  0 never executed
branch  1 never executed
        -: 3414:				    {
    #####: 3415:				      auto Bool ambig = FALSE;
        -: 3416:
        -: 3417:
        -: 3418:				      /*
        -: 3419:				         The given SPECIAL argument doesn't match precisely,
        -: 3420:				         so try to detect whether it's ambiguous.
        -: 3421:				       */
    #####: 3422:				      i = j + 1;
    #####: 3423:				      while (!ambig
branch  0 never executed
branch  1 never executed
    #####: 3424:					     && (ptr_lopt->largs[i] != NULL))
branch  0 never executed
branch  1 never executed
        -: 3425:					{
    #####: 3426:					  if (!strncasecmp
branch  0 never executed
branch  1 never executed
    #####: 3427:					      (ptr_lopt->largs[i],
        -: 3428:					       larg_longopt, len_larg))
    #####: 3429:					    ambig = TRUE;
    #####: 3430:					  i++;
        -: 3431:					}
    #####: 3432:				      if (ambig)
branch  0 never executed
branch  1 never executed
        -: 3433:					{
    #####: 3434:					  *longopt_symbolic =
    #####: 3435:					    ptr_lopt->symbolic_name;
        -: 3436:					  /*
        -: 3437:					     Error, the given SPECIAL argument is ambiguous.
        -: 3438:					   */
    #####: 3439:					  return (6);
        -: 3440:					}
        -: 3441:				      else
        -: 3442:					{
        -: 3443:					  /*
        -: 3444:					     The given SPECIAL argument is valid!
        -: 3445:					   */
    #####: 3446:					  ok = TRUE;
    #####: 3447:					  i = j + 1;
        -: 3448:					}
        -: 3449:				    }
        -: 3450:				}
        -: 3451:			      else
    #####: 3452:				ptr_char = ptr_lopt->largs[i++];
        -: 3453:			    }
        -: 3454:			  else
    #####: 3455:			    ptr_char = ptr_lopt->largs[i++];
        -: 3456:			}
    #####: 3457:		      if (!ok && (ptr_lopt->larg_mode != LARG_ONE_OR_ARG))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3458:			{
    #####: 3459:			  *longopt_symbolic = ptr_lopt->symbolic_name;
        -: 3460:			  /*
        -: 3461:			     Error, the given SPECIAL argument not found
        -: 3462:			     in `lopt[]' tables structure member `largs'.
        -: 3463:			   */
    #####: 3464:			  return (5);
        -: 3465:			}
    #####: 3466:		      i--;
    #####: 3467:		      if (ptr_lopt->short_name[0] == NULL)
branch  0 never executed
branch  1 never executed
        -: 3468:			{
        -: 3469:			  /*
        -: 3470:			     Return the completed `long_name' with a completed SPECIAL argument
        -: 3471:			     or with a GIVEN argument;
        -: 3472:			     the format of returned `longopt' is like:  foo=BAR  or  foo=ARG
        -: 3473:			   */
    #####: 3474:			  strcpy (longopt, ptr_lopt->long_name);
    #####: 3475:			  strcat (longopt, LARG_SEP);
    #####: 3476:			  if (ptr_lopt->larg_mode == LARG_ONE_OR_ARG)
branch  0 never executed
branch  1 never executed
        -: 3477:			    /*
        -: 3478:			       Return with the GIVEN argument.
        -: 3479:			     */
    #####: 3480:			    strcat (longopt, larg_longopt);
        -: 3481:			  else
        -: 3482:			    /*
        -: 3483:			       Return with the completed SPECIAL argument.
        -: 3484:			     */
    #####: 3485:			    strcat (longopt, ptr_lopt->largs[i]);
    #####: 3486:			  *longopt_symbolic = ptr_lopt->symbolic_name;
    #####: 3487:			  free (larg_longopt);
    #####: 3488:			  return (-2);
        -: 3489:			}
    #####: 3490:		      if (!ok && (ptr_lopt->larg_mode == LARG_ONE_OR_ARG))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3491:			{
        -: 3492:			  /*
        -: 3493:			     Return the corresponding `short_name' with a GIVEN argument;
        -: 3494:			     the format of returned `longopt' is like:  fooBAR
        -: 3495:			   */
    #####: 3496:			  strcpy (larg_longopt, longopt + len_longopt + 1);
    #####: 3497:			  strcpy (longopt, ptr_lopt->short_name[--i]);
    #####: 3498:			  strcat (longopt, larg_longopt);
        -: 3499:			}
        -: 3500:		      else
        -: 3501:			{
        -: 3502:			  /*
        -: 3503:			     Return the corresponding `short_name' with a converted SPECIAL argument;
        -: 3504:			     the format of returned `longopt' is like:  fooBAR
        -: 3505:			   */
    #####: 3506:			  strcpy (longopt, ptr_lopt->short_name[i]);
    #####: 3507:			  if (!strcmp (ptr_lopt->largs[i], larg_lit))
branch  0 never executed
branch  1 never executed
        -: 3508:			    /*
        -: 3509:			       Error, `larg_lit' matched, so return with the GIVEN argument.
        -: 3510:			     */
    #####: 3511:			    strcat (longopt, larg_longopt);
        -: 3512:			}
        -: 3513:		    }
    #####: 3514:		  free (larg_longopt);
        -: 3515:		}
        -: 3516:	    }
        -: 3517:	  else
        -: 3518:	    /*
        -: 3519:	       Error, `longopt' not member of field `long_name' in `lopt[]' table.
        -: 3520:	     */
    #####: 3521:	    return (2);
        -: 3522:	}
        -: 3523:      else
        -: 3524:	/*
        -: 3525:	   Error, `longopt' not member of field `long_name' in `lopt[]' table.
        -: 3526:	 */
    #####: 3527:	return (2);
        -: 3528:    }
        -: 3529:  else
        -: 3530:    /*
        -: 3531:       Error, first entry in `lopt[]' tables structure member `long_name'
        -: 3532:       is greater than the delivered `longopt'.
        -: 3533:     */
        8: 3534:    return (2);
    #####: 3535:  *longopt_symbolic = ptr_lopt->symbolic_name;
        -: 3536:
    #####: 3537:  return (0);
        -: 3538:}
        -: 3539:
        -: 3540:
        -: 3541:
        -: 3542:static Bool
function is_correct_date_format called 91 returned 100% blocks executed 82%
       91: 3543:is_correct_date_format (format_txt, use_day_suffix, use_short3_day_name,
        -: 3544:			use_day_zeroleaded, use_year_zeroleaded)
        -: 3545:     char *format_txt;
        -: 3546:     Bool *use_day_suffix;
        -: 3547:     Bool *use_short3_day_name;
        -: 3548:     Bool *use_day_zeroleaded;
        -: 3549:     Bool *use_year_zeroleaded;
        -: 3550:/*!
        -: 3551:   Checks whether the delivered `format_txt' contains valid format directives
        -: 3552:     (see the `decode_date_format()' function for a more brief description of
        -: 3553:     all used format specifiers).  Returns FALSE in case any invalid format
        -: 3554:     specifiers are found, otherwise TRUE.  Boolean `&use_day_suffix' is set
        -: 3555:     to TRUE and is returned in case a day GROUP format character defining the
        -: 3556:     use of a trailing day suffix is found in `format_txt', otherwise to FALSE.
        -: 3557:     Boolean `&use_short3_day_name' is set to TRUE and is returned in case a
        -: 3558:     weekday GROUP format character defining the use of a day name truncated to
        -: 3559:     three characters WWW is found in `format_txt', otherwise to FALSE.
        -: 3560:     Boolean `&use_day_zeroleaded' is set to TRUE and is returned in case a day
        -: 3561:     GROUP format character defining the use of a day with leading zeroes is
        -: 3562:     found in `format_txt', otherwise to FALSE.  Boolean `&use_year_zeroleaded'
        -: 3563:     is set to TRUE and is returned in case a year GROUP format character
        -: 3564:     defining the use of a year with leading zeroes is found in `format_txt',
        -: 3565:     otherwise to FALSE.
        -: 3566:*/
        -: 3567:{
       91: 3568:  register int start_highlighting = 2;
       91: 3569:  register int end_highlighting = 2;
       91: 3570:  register int weekday_name_group = 2;
       91: 3571:  register int day_group = 2;
       91: 3572:  register int month_group = 2;
       91: 3573:  register int year_group = 2;
        -: 3574:  register int pos;
       91: 3575:  auto int fstyle = FSTYLE_NONE;
       91: 3576:  auto int fwidth = SPECIAL_VALUE;
       91: 3577:  auto Bool is_cformat = FALSE;
       91: 3578:  auto Bool is_lformat = FALSE;
       91: 3579:  auto Bool is_sign = FALSE;
       91: 3580:  auto Bool is_lzero = FALSE;
       91: 3581:  auto Bool is_fformat = FALSE;
       91: 3582:  auto Bool is_suffix = FALSE;
        -: 3583:
        -: 3584:
       91: 3585:  *use_day_suffix = (*use_short3_day_name) = (*use_day_zeroleaded) =
       91: 3586:    (*use_year_zeroleaded) = FALSE;
       91: 3587:  if (!*format_txt)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3588:    /*
        -: 3589:       Error, no `format_txt' given.
        -: 3590:     */
    #####: 3591:    return (FALSE);
        -: 3592:  do
        -: 3593:    {
     1547: 3594:      while (*format_txt
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1001: 3595:	     && (*format_txt != DFORMAT_CHAR) && (*format_txt != QUOTE_CHAR))
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
      455: 3596:	format_txt++;
      546: 3597:      if (*format_txt)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3598:	{
      546: 3599:	  if (*format_txt == DFORMAT_CHAR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3600:	    {
      546: 3601:	      pos = decode_format (format_txt, 1, &is_cformat,
call    0 returned 100%
        -: 3602:				   &is_lformat, &is_sign, &is_lzero,
        -: 3603:				   &is_suffix, &is_fformat, &fstyle, &fwidth);
      546: 3604:	      format_txt += pos;
        -: 3605:	      /*
        -: 3606:	         Format specifier found.
        -: 3607:	       */
      546: 3608:	      switch (*format_txt)
branch  0 taken 17%
branch  1 taken 17%
branch  2 taken 17%
branch  3 taken 17%
branch  4 taken 17%
branch  5 taken 17%
branch  6 taken 0%
        -: 3609:		{
       91: 3610:		case HLS1S_CHAR:
       91: 3611:		  if (end_highlighting == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3612:		    if (start_highlighting)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3613:		      start_highlighting--;
       91: 3614:		  break;
       91: 3615:		case HLS1E_CHAR:
       91: 3616:		  if (start_highlighting == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3617:		    if (end_highlighting)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3618:		      end_highlighting--;
       91: 3619:		  break;
       91: 3620:		case DAYNR_CHAR:
       91: 3621:		  if (is_lzero)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3622:		    *use_day_zeroleaded = TRUE;
       91: 3623:		  if (is_suffix)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3624:		    *use_day_suffix = TRUE;
       91: 3625:		  if (day_group)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3626:		    day_group--;
       91: 3627:		  break;
       91: 3628:		case WDNAME_CHAR:
       91: 3629:		  if (fwidth == 3)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3630:		    *use_short3_day_name = TRUE;
       91: 3631:		  if (weekday_name_group)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3632:		    weekday_name_group--;
       91: 3633:		  break;
       91: 3634:		case MONTHNAME_CHAR:
        -: 3635:		case MONTHNR_CHAR:
       91: 3636:		  if (month_group)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3637:		    month_group--;
       91: 3638:		  break;
       91: 3639:		case YEARNR_CHAR:
       91: 3640:		  if (is_lzero)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3641:		    *use_year_zeroleaded = TRUE;
       91: 3642:		  if (year_group)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3643:		    year_group--;
       91: 3644:		  break;
    #####: 3645:		default:
        -: 3646:		  /*
        -: 3647:		     Error, invalid or no date format character specified.
        -: 3648:		   */
    #####: 3649:		  return (FALSE);
        -: 3650:		}
        -: 3651:	    }
        -: 3652:	  else
        -: 3653:	    /*
        -: 3654:	       Quote character found.
        -: 3655:	     */
    #####: 3656:	  if (!*++format_txt)
branch  0 never executed
branch  1 never executed
    #####: 3657:	    format_txt--;
      546: 3658:	  format_txt++;
        -: 3659:	}
        -: 3660:      else
    #####: 3661:	break;
        -: 3662:    }
      546: 3663:  while (*format_txt);
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       91: 3664:  if (start_highlighting != 1
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3665:      || end_highlighting != 1
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       91: 3666:      || day_group != 1 || month_group != 1 || year_group != 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -: 3667:    /*
        -: 3668:       Error, either required date format element not given
        -: 3669:       or it occurred more than once.
        -: 3670:     */
    #####: 3671:    return (FALSE);
       91: 3672:  if (weekday_name_group < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3673:    /*
        -: 3674:       Error, optional format element occurred more than once.
        -: 3675:     */
    #####: 3676:    return (FALSE);
        -: 3677:
       91: 3678:  return (TRUE);
        -: 3679:}
        -: 3680:
        -: 3681:
        -: 3682:
        -: 3683:static void
function rearrange_argv called 46 returned 100% blocks executed 54%
       46: 3684:rearrange_argv (opt_list, argc, argv)
        -: 3685:     const char *opt_list;
        -: 3686:     int *argc;
        -: 3687:     char *argv[];
        -: 3688:/*!
        -: 3689:   Rearranges `argv[]' internally.
        -: 3690:     This means all short-style options which need an argument,
        -: 3691:     that is separated by a whitespace character in the command line
        -: 3692:     from the short option character, e.g. `-x foo', is concatenated
        -: 3693:     to `-xfoo'.  The short option characters which need an argument
        -: 3694:     are given in `opt_list'.  This function sets given `&argc' to
        -: 3695:     the "new" rearranged amount of arguments stored in `argv[]'.
        -: 3696:*/
        -: 3697:{
       46: 3698:  register int i = (*argc - 1);
       46: 3699:  register int n = 1;
       46: 3700:  auto char **ptr_argv = argv;
        -: 3701:  auto char **ptr2_argv;
        -: 3702:  auto Bool is_modified;
        -: 3703:
        -: 3704:
      153: 3705:  while (i)
branch  0 taken 57%
branch  1 taken 43% (fallthrough)
        -: 3706:    {
        -: 3707:      /*
        -: 3708:         Skip `argv[0]' generally!
        -: 3709:       */
       61: 3710:      ptr_argv++;
       61: 3711:      is_modified = FALSE;
       61: 3712:      if (**ptr_argv == *SWITCH || **ptr_argv == *SWITCH2)
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
branch  2 taken 14% (fallthrough)
branch  3 taken 86%
        -: 3713:	{
        -: 3714:	  /*
        -: 3715:	     Found an option in `argv[]'
        -: 3716:	     (either a long-style option or a short-style option).
        -: 3717:	   */
       18: 3718:	  (*ptr_argv)++;
       36: 3719:	  if (**ptr_argv && (**ptr_argv != *SWITCH))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 61% (fallthrough)
branch  3 taken 39%
        -: 3720:	    {
        -: 3721:	      /*
        -: 3722:	         Short-style option given, e.g. `-x' or `-Xfoo' or `-x bar'.
        -: 3723:	       */
       11: 3724:	      if (strchr (opt_list, **ptr_argv) != (char *) NULL)
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
        -: 3725:		{
        -: 3726:		  /*
        -: 3727:		     The option character is found in `opt_list',
        -: 3728:		     this means this option needs an argument.
        -: 3729:		   */
        8: 3730:		  if (i > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3731:		    {
        -: 3732:		      /*
        -: 3733:		         We are not working on the final option stored in `argv[]'.
        -: 3734:		       */
    #####: 3735:		      (*ptr_argv)++;
        -: 3736:		      /*
        -: 3737:		         Check if the option doesn't have its argument already
        -: 3738:		         unseparated by a whitespace character in the command line,
        -: 3739:		         e.g. is not like this `-Xfoo' option.
        -: 3740:		       */
    #####: 3741:		      if (!**ptr_argv)
branch  0 never executed
branch  1 never executed
        -: 3742:			{
        -: 3743:			  /*
        -: 3744:			     Check if the option is trailed by a needed argument,
        -: 3745:			     which is the next argument in `argv[]', e.g. `-x bar'.
        -: 3746:			   */
    #####: 3747:			  (*ptr_argv) -= 2;
    #####: 3748:			  ptr2_argv = ptr_argv;
    #####: 3749:			  ptr2_argv++;
        -: 3750:			  /*
        -: 3751:			     Check whether this next argument in `argv[]' is an option.
        -: 3752:			   */
    #####: 3753:			  if ((**ptr2_argv != RSP_CHAR)
branch  0 never executed
branch  1 never executed
        -: 3754:#if USE_RC
    #####: 3755:			      && (**ptr2_argv != RC_ADATE_CHAR)
branch  0 never executed
branch  1 never executed
        -: 3756:#endif
        -: 3757:			    )
        -: 3758:			    {
    #####: 3759:			      if ((**ptr2_argv == *SWITCH
branch  0 never executed
branch  1 never executed
    #####: 3760:				   || **ptr2_argv == *SWITCH2)
branch  0 never executed
branch  1 never executed
    #####: 3761:				  && (strlen (*ptr2_argv) <= 2))
branch  0 never executed
branch  1 never executed
        -: 3762:				/*
        -: 3763:				   Next argument is definitely a simple short-style option
        -: 3764:				   without a given modifier, e.g. `-x' or `/x'.
        -: 3765:				 */
    #####: 3766:				(*ptr_argv)++;
        -: 3767:			      else
        -: 3768:				{
        -: 3769:				  /*
        -: 3770:				     Next argument is no option, so let's concatenate the
        -: 3771:				     short-style option character and its needed argument.
        -: 3772:				   */
    #####: 3773:				  i--;
    #####: 3774:				  argv[n] =
    #####: 3775:				    (char *) my_realloc ((VOID_PTR) (argv[n]),
call    0 never executed
    #####: 3776:							 strlen (*ptr_argv) +
    #####: 3777:							 strlen (*ptr2_argv) +
        -: 3778:							 1,
        -: 3779:							 ERR_NO_MEMORY_AVAILABLE,
        -: 3780:							 __FILE__,
        -: 3781:							 ((long) __LINE__) -
        -: 3782:							 3L, "argv[n]", n);
    #####: 3783:				  strcpy (argv[n], *ptr_argv);
    #####: 3784:				  strcat (argv[n], *ptr2_argv);
    #####: 3785:				  ptr_argv++;
    #####: 3786:				  is_modified = TRUE;
        -: 3787:				}
        -: 3788:			    }
        -: 3789:			  else
    #####: 3790:			    (*ptr_argv)++;
        -: 3791:			}
        -: 3792:		      else
    #####: 3793:			(*ptr_argv)--;
        -: 3794:		    }
        -: 3795:		}
        -: 3796:	    }
        -: 3797:	}
        -: 3798:      else
       43: 3799:	(*ptr_argv)++;
       61: 3800:      if (!is_modified)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3801:	{
        -: 3802:	  /*
        -: 3803:	     Unmodified argument found in `argv[]'.
        -: 3804:	     This means, the argument we work on here is:
        -: 3805:	     either a short-style option, which needs an argument, which isn't given,
        -: 3806:	     or     a short-style option, which already contains its argument like `-Xfoo',
        -: 3807:	     or     a simple short-style option like `-x',
        -: 3808:	     or     a long-style option like `--foo',
        -: 3809:	     or     a command (an argument not leaded by a '-', '/', '@' or '%' character.
        -: 3810:	   */
       61: 3811:	  (*ptr_argv)--;
       61: 3812:	  argv[n] = (char *) my_realloc ((VOID_PTR) (argv[n]),
call    0 returned 100%
       61: 3813:					 strlen (*ptr_argv) + 1,
        -: 3814:					 ERR_NO_MEMORY_AVAILABLE,
        -: 3815:					 __FILE__, ((long) __LINE__) - 3L,
        -: 3816:					 "argv[n]", n);
       61: 3817:	  strcpy (argv[n], *ptr_argv);
        -: 3818:	}
       61: 3819:      n++;
       61: 3820:      i--;
        -: 3821:    }
       46: 3822:  *argc = n;
       46: 3823:}
        -: 3824:
        -: 3825:
        -: 3826:
        -: 3827:static void
function check_command_line called 89 returned 83% blocks executed 13%
       89: 3828:check_command_line (argc, argv)
        -: 3829:     int argc;
        -: 3830:     char *argv[];
        -: 3831:/*!
        -: 3832:   Gets and manages the arguments from the command line.
        -: 3833:*/
        -: 3834:{
       89: 3835:  register int opt_error = 0;
        -: 3836:  register int len;
        -: 3837:  auto int i;
        -: 3838:  auto int lopt_help;
       89: 3839:  auto char rel_time_offset = '\0';
        -: 3840:#if USE_RC
       89: 3841:  auto char rel_loop_end = '\0';
        -: 3842:#endif
        -: 3843:  auto char *ptr_char;
       89: 3844:  auto char *option = (char *) NULL;
        -: 3845:#if USE_RC
       89: 3846:  auto char *rc_period_argv = (char *) NULL;
       89: 3847:  auto char *rc_period_option = (char *) NULL;
       89: 3848:  auto Bool set_loop_end = FALSE;
       89: 3849:  auto Bool rc_period_is_longopt = FALSE;
        -: 3850:#endif
       89: 3851:  auto Bool is_longopt = FALSE;
       89: 3852:  auto Bool license_flag = FALSE;	/* `-L' */
       89: 3853:  auto Bool version_flag = FALSE;	/* `-V' */
       89: 3854:  auto Bool help_flag = FALSE;	/* `-?' | `-h' */
       89: 3855:  auto Bool ext_help_flag = FALSE;	/* `-??' | `-hh' */
       89: 3856:  auto Bool help_on_help_flag = FALSE;	/* `--long-help=?' */
       89: 3857:  auto Bool skip_option = FALSE;
       89: 3858:  auto Bool lopt_ambig = FALSE;
        -: 3859:
        -: 3860:
        -: 3861:  /*
        -: 3862:     Work on the arguments that have been found in the command line.
        -: 3863:   */
      183: 3864:  while (argc > 1)
branch  0 taken 49%
branch  1 taken 51% (fallthrough)
        -: 3865:    {
       46: 3866:      option = *++argv;
        -: 3867:      /*
        -: 3868:         If a leading switch character is found,
        -: 3869:         check the command line for options.
        -: 3870:       */
       46: 3871:      if (*option == *SWITCH || *option == *SWITCH2)
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
branch  2 taken 20% (fallthrough)
branch  3 taken 80%
        -: 3872:	{
       18: 3873:	  is_longopt = FALSE;
        -: 3874:	  /*
        -: 3875:	     Check the command line for options.
        -: 3876:	   */
       21: 3877:	  for (option++; *option; option++)
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -: 3878:	    {
       18: 3879:	      skip_option = FALSE;
        -: 3880:	      /*
        -: 3881:	         Check for long-style options, e.g. `--help' ...
        -: 3882:	       */
       18: 3883:	      if (*option == *SWITCH)
branch  0 taken 39% (fallthrough)
branch  1 taken 61%
        -: 3884:		{
        7: 3885:		  option--;
        7: 3886:		  if (*option == *SWITCH)
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
        -: 3887:		    {
        5: 3888:		      is_longopt = TRUE;
        5: 3889:		      option += 2;
        -: 3890:		    }
        7: 3891:		  if (*option && is_longopt)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 71% (fallthrough)
branch  3 taken 29%
        -: 3892:		    {
        -: 3893:		      /*
        -: 3894:		         Copy this long-style option into a buffer.
        -: 3895:		       */
        5: 3896:		      len = (int) strlen (option);
        5: 3897:		      if ((Uint) len >= maxlen_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 3898:			resize_all_strings (len + 1, FALSE, __FILE__,
call    0 never executed
        -: 3899:					    (long) __LINE__);
        5: 3900:		      strcpy (s2, option);
        -: 3901:		      /*
        -: 3902:		         Check this long-style option.
        -: 3903:		       */
        5: 3904:		      opt_error = eval_longopt (s2, &lopt_id);
call    0 returned 100%
       10: 3905:		      if (opt_error < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3906:			{
    #####: 3907:			  opt_error = 0;
    #####: 3908:			  switch (lopt_id)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
branch 30 never executed
branch 31 never executed
branch 32 never executed
branch 33 never executed
branch 34 never executed
branch 35 never executed
branch 36 never executed
branch 37 never executed
branch 38 never executed
branch 39 never executed
branch 40 never executed
branch 41 never executed
branch 42 never executed
branch 43 never executed
branch 44 never executed
branch 45 never executed
branch 46 never executed
branch 47 never executed
branch 48 never executed
branch 49 never executed
        -: 3909:			    {
        -: 3910:#if USE_RC
    #####: 3911:			    case SYM_ADJUST_VALUE:
    #####: 3912:			      option = strchr (s2, *LARG_SEP) + 1;
    #####: 3913:			      (void) sscanf (option, "%lf", &adjust_value);
        -: 3914:			      /*
        -: 3915:			         Avoid nonsense data.
        -: 3916:			       */
    #####: 3917:			      if (abs (adjust_value) > DEGS_PER_06_HOURS)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3918:				/*
        -: 3919:				   Error, long-style option is trailed
        -: 3920:				   by an invalid argument.
        -: 3921:				 */
    #####: 3922:				opt_error = 5;
    #####: 3923:			      break;
    #####: 3924:			    case SYM_ATMOSPHERE:
    #####: 3925:			      option = strchr (s2, *LARG_SEP) + 1;
    #####: 3926:			      ptr_char = strchr (option, *SPLIT_SEP);
    #####: 3927:			      if (ptr_char == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 3928:				/*
        -: 3929:				   Error, long-style option is trailed
        -: 3930:				   by an invalid argument.
        -: 3931:				 */
    #####: 3932:				opt_error = 5;
        -: 3933:			      else
    #####: 3934:				*ptr_char = '\0';
    #####: 3935:			      (void) sscanf (option, "%lf", &atm_pressure);
    #####: 3936:			      if (atm_pressure > 0.0)
branch  0 never executed
branch  1 never executed
        -: 3937:				{
        -: 3938:				  /*
        -: 3939:				     Avoid nonsense data
        -: 3940:				     (0.0 mb < pressure <= 1200.0 mb).
        -: 3941:				   */
    #####: 3942:				  if (atm_pressure > 1200.0)
branch  0 never executed
branch  1 never executed
        -: 3943:				    /*
        -: 3944:				       Error, long-style option is trailed
        -: 3945:				       by an invalid argument.
        -: 3946:				     */
    #####: 3947:				    opt_error = 5;
        -: 3948:				  else
        -: 3949:				    {
        -: 3950:				      /*
        -: 3951:				         Convert given Millibar (mb) value to a
        -: 3952:				         Newton per square meter (Nm^-2) value.
        -: 3953:				       */
    #####: 3954:				      atm_pressure *= 100.0;
    #####: 3955:				      ptr_char++;
    #####: 3956:				      if (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 3957:					{
    #####: 3958:					  (void) sscanf (ptr_char, "%lf",
        -: 3959:							 &atm_temperature);
        -: 3960:					  /*
        -: 3961:					     Avoid nonsense data
        -: 3962:					     (-100.0 C <= temperature <= +100.0 C).
        -: 3963:					   */
    #####: 3964:					  if (abs (atm_temperature) > 100.0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3965:					    /*
        -: 3966:					       Error, long-style option is trailed
        -: 3967:					       by an invalid argument.
        -: 3968:					     */
    #####: 3969:					    opt_error = 5;
        -: 3970:					}
        -: 3971:				      else
        -: 3972:					/*
        -: 3973:					   Error, long-style option is trailed
        -: 3974:					   by an invalid argument.
        -: 3975:					 */
    #####: 3976:					opt_error = 5;
        -: 3977:				    }
        -: 3978:				}
        -: 3979:			      else
    #####: 3980:				opt_error = 0;
    #####: 3981:			      break;
    #####: 3982:			    case SYM_EXECUTE_COMMAND:
    #####: 3983:			      rc_execute_command = TRUE;
    #####: 3984:			      break;
    #####: 3985:			    case SYM_extern_static_DVARS:
    #####: 3986:			      rc_export_ldvar_flag = TRUE;
    #####: 3987:			      break;
    #####: 3988:			    case SYM_extern_static_TVARS:
    #####: 3989:			      rc_export_ltvar_flag = TRUE;
    #####: 3990:			      break;
    #####: 3991:			    case SYM_HEADING_TEXT:
    #####: 3992:			      option = strchr (s2, *LARG_SEP) + 1;
    #####: 3993:			      rc_heading_text =
    #####: 3994:				(char *) my_realloc ((VOID_PTR)
call    0 never executed
        -: 3995:						     rc_heading_text,
    #####: 3996:						     strlen (option) + 1 + 2,
        -: 3997:						     ERR_NO_MEMORY_AVAILABLE,
        -: 3998:						     __FILE__,
        -: 3999:						     ((long) __LINE__) - 3L,
        -: 4000:						     "rc_heading_text", 0);
    #####: 4001:			      strcpy (rc_heading_text, "0 ");
    #####: 4002:			      strcat (rc_heading_text, option);
    #####: 4003:			      pseudo_blank_conversion (&rc_heading_text);
call    0 never executed
    #####: 4004:			      break;
    #####: 4005:			    case SYM_IGNORE_CASE:
    #####: 4006:			      rc_ignore_case_flag = TRUE;
    #####: 4007:			      break;
    #####: 4008:			    case SYM_LIMIT:
    #####: 4009:			      rc_limit = TRUE;
    #####: 4010:			      break;
    #####: 4011:			    case SYM_LEAP_DAY:
    #####: 4012:			      rc_feb_29_to_feb_28 = rc_feb_29_to_mar_01 =
        -: 4013:				FALSE;
    #####: 4014:			      if (tolower (*s2) == 'f')
branch  0 never executed
branch  1 never executed
    #####: 4015:				rc_feb_29_to_feb_28 = TRUE;
        -: 4016:			      else
    #####: 4017:				rc_feb_29_to_mar_01 = TRUE;
    #####: 4018:			      break;
    #####: 4019:			    case SYM_PRECISE:
    #####: 4020:			      rc_precise = TRUE;
    #####: 4021:			      break;
    #####: 4022:			    case SYM_REVERT_MATCH:
    #####: 4023:			      rc_revert_match_flag = TRUE;
    #####: 4024:			      break;
    #####: 4025:			    case SYM_BIORHYTHM_AXIS_LEN:
    #####: 4026:			      option = strchr (s2, *LARG_SEP) + 1;
    #####: 4027:			      if (*option == '0')
branch  0 never executed
branch  1 never executed
        -: 4028:				{
    #####: 4029:				  while (*option == '0')
branch  0 never executed
branch  1 never executed
    #####: 4030:				    option++;
    #####: 4031:				  if (!*option)
branch  0 never executed
branch  1 never executed
    #####: 4032:				    option--;
        -: 4033:				}
    #####: 4034:			      rc_bio_axis_len = my_atoi (option);
call    0 never executed
    #####: 4035:			      if (rc_bio_axis_len > BIO_AXIS_MAX
branch  0 never executed
branch  1 never executed
    #####: 4036:				  || rc_bio_axis_len < BIO_AXIS_MIN)
branch  0 never executed
branch  1 never executed
        -: 4037:				/*
        -: 4038:				   Error, long-style option is trailed
        -: 4039:				   by an invalid argument.
        -: 4040:				 */
    #####: 4041:				opt_error = 5;
        -: 4042:			      else
        -: 4043:				/*
        -: 4044:				   Decrease `rc_bio_axis_len' by 1 until
        -: 4045:				   it divides BIO_AXIS_MAX without a remainder.
        -: 4046:				 */
    #####: 4047:				while (BIO_AXIS_MAX % rc_bio_axis_len)
branch  0 never executed
branch  1 never executed
    #####: 4048:				  rc_bio_axis_len--;
    #####: 4049:			      break;
    #####: 4050:			    case SYM_MOONIMAGE_LINES:
    #####: 4051:			      option = strchr (s2, *LARG_SEP) + 1;
    #####: 4052:			      if (*option == '0')
branch  0 never executed
branch  1 never executed
        -: 4053:				{
    #####: 4054:				  while (*option == '0')
branch  0 never executed
branch  1 never executed
    #####: 4055:				    option++;
    #####: 4056:				  if (!*option)
branch  0 never executed
branch  1 never executed
    #####: 4057:				    option--;
        -: 4058:				}
    #####: 4059:			      rc_moonimage_lines = my_atoi (option);
call    0 never executed
    #####: 4060:			      if (rc_moonimage_lines > MOONIMAGE_MAX
branch  0 never executed
branch  1 never executed
    #####: 4061:				  || rc_moonimage_lines < MOONIMAGE_MIN)
branch  0 never executed
branch  1 never executed
        -: 4062:				/*
        -: 4063:				   Error, long-style option is trailed
        -: 4064:				   by an invalid argument.
        -: 4065:				 */
    #####: 4066:				opt_error = 5;
    #####: 4067:			      break;
        -: 4068:#endif /* USE_RC */
        -: 4069:#ifdef GCAL_EMAIL
    #####: 4070:			    case SYM_MAIL:
    #####: 4071:			      option = strchr (s2, *LARG_SEP);
    #####: 4072:			      if (option == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 4073:				{
        -: 4074:# if !defined(AMIGA) || defined(__GNUC__)
        -: 4075:				  /*
        -: 4076:				     Detect whether a $MAILTO environment variable is set.
        -: 4077:				   */
    #####: 4078:				  ptr_char = getenv (ENV_VAR_MAILTO);
call    0 never executed
    #####: 4079:				  if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4080:				    if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 4081:				      option = ptr_char;
    #####: 4082:				  if (option == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 4083:				    {
        -: 4084:				      /*
        -: 4085:				         Detect whether a $USER environment variable is set.
        -: 4086:				       */
    #####: 4087:				      ptr_char = getenv (ENV_VAR_USER);
call    0 never executed
    #####: 4088:				      if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4089:					if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 4090:					  option = ptr_char;
    #####: 4091:				      if (option == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 4092:					{
        -: 4093:					  /*
        -: 4094:					     Detect whether a $LOGNAME environment variable is set.
        -: 4095:					   */
    #####: 4096:					  ptr_char = getenv (ENV_VAR_LOGNAME);
call    0 never executed
    #####: 4097:					  if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4098:					    if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 4099:					      option = ptr_char;
        -: 4100:					}
        -: 4101:				    }
        -: 4102:# else /* AMIGA && !__GNUC__ */
        -: 4103:				  ;	/* Void, nothing to do now. */
        -: 4104:# endif	/* AMIGA && !__GNUC__ */
        -: 4105:				}
        -: 4106:			      else
    #####: 4107:				option++;
    #####: 4108:			      if (option != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4109:				if (*option)
branch  0 never executed
branch  1 never executed
        -: 4110:				  {
    #####: 4111:				    if (email_adr == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4112:				      email_adr =
    #####: 4113:					(char *) my_malloc (strlen (option) +
call    0 never executed
        -: 4114:							    1,
        -: 4115:							    ERR_NO_MEMORY_AVAILABLE,
        -: 4116:							    __FILE__,
        -: 4117:							    ((long) __LINE__)
        -: 4118:							    - 2L, "email_adr",
        -: 4119:							    0);
        -: 4120:				    else
    #####: 4121:				      email_adr =
    #####: 4122:					(char *) my_realloc ((VOID_PTR)
call    0 never executed
        -: 4123:							     email_adr,
    #####: 4124:							     strlen (option) +
        -: 4125:							     1,
        -: 4126:							     ERR_NO_MEMORY_AVAILABLE,
        -: 4127:							     __FILE__,
        -: 4128:							     ((long) __LINE__)
        -: 4129:							     - 3L,
        -: 4130:							     "email_adr", 0);
    #####: 4131:				    strcpy (email_adr, option);
        -: 4132:				  }
    #####: 4133:			      break;
        -: 4134:#endif
    #####: 4135:			    case SYM_DEBUG:
    #####: 4136:			      break;	/* Void, `--debug[=0...WARN_LVL_MAX]' is already managed in main() */
    #####: 4137:			    case SYM_EXIT_STAT_HELP_NON_ZERO:
    #####: 4138:			      exit_stat_help = ERR_EXIT_INFO_TEXTS_NON_ZERO;
    #####: 4139:			      break;
    #####: 4140:			    case SYM_ISO_WEEK_NUMBER:
    #####: 4141:			      if (tolower (*s2) == 'y')
branch  0 never executed
branch  1 never executed
    #####: 4142:				iso_week_number = TRUE;
        -: 4143:			      else
    #####: 4144:				iso_week_number = FALSE;
    #####: 4145:			      break;
        -: 4146:#if USE_RC
    #####: 4147:			    case SYM_CYCLE_END:
        -: 4148:			    case SYM_CYCLE_STEP:
        -: 4149:#endif
        -: 4150:			    case SYM_TIME_OFFSET:
        -: 4151:			      {
    #####: 4152:				register int sign = 0;
    #####: 4153:				register int state = 1;
    #####: 4154:				register int digits = 0;
    #####: 4155:				auto Bool skip = FALSE;
    #####: 4156:				auto Bool is_last = FALSE;
    #####: 4157:				auto Bool time_sep_found = FALSE;
    #####: 4158:				auto Bool is_leading_zero = TRUE;
        -: 4159:
        -: 4160:
        -: 4161:				/*
        -: 4162:				   Scan and parse the argument given to the `--cycle-*'
        -: 4163:				   and `--time-offset' options if they conform to either
        -: 4164:				   the 't'|'@' character or the `[t|@][+|-]MMMM|HH:[MM]'
        -: 4165:				   template.  If a 't' character is found, treat
        -: 4166:				   the time displacement value relative the
        -: 4167:				   actual local time value as given by the system
        -: 4168:				   clock.  If a '@' character is found, treat
        -: 4169:				   the time displacement value relative the
        -: 4170:				   actual gmt value as given by the system
        -: 4171:				   clock.  If [+|-]MMMM is given, skip all possibly
        -: 4172:				   leading zeroes of MMMM.  The HH:[MM] time
        -: 4173:				   separating character ':' is choosen by the
        -: 4174:				   used locale at runtime.
        -: 4175:				 */
    #####: 4176:				i = 0;
    #####: 4177:				switch (lopt_id)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4178:				  {
    #####: 4179:				  case SYM_TIME_OFFSET:
    #####: 4180:				    time_hour_offset = time_min_offset = 0;
        -: 4181:#if USE_RC
    #####: 4182:				    break;
    #####: 4183:				  case SYM_CYCLE_END:
    #####: 4184:				    loop_end = SPECIAL_VALUE;
    #####: 4185:				    set_loop_end = FALSE;
    #####: 4186:				    break;
    #####: 4187:				  case SYM_CYCLE_STEP:
    #####: 4188:				    loop_step = DEFAULT_CYCLE_STEP;
        -: 4189:#endif
        -: 4190:				  }
    #####: 4191:				option = strchr (s2, *LARG_SEP) + 1;
        -: 4192:#if USE_RC
    #####: 4193:				if (*option == RC_TIME_CHAR
branch  0 never executed
branch  1 never executed
    #####: 4194:				    || *option == RC_GMTIME_CHAR)
branch  0 never executed
branch  1 never executed
        -: 4195:#else /* !USE_RC */
        -: 4196:				if (*option == staticTIME_CHAR)
        -: 4197:#endif /* !USE_RC */
        -: 4198:				  {
    #####: 4199:				    if (lopt_id == SYM_TIME_OFFSET)
branch  0 never executed
branch  1 never executed
    #####: 4200:				      rel_time_offset = *option;
        -: 4201:#if USE_RC
    #####: 4202:				    else if (lopt_id == SYM_CYCLE_END)
branch  0 never executed
branch  1 never executed
    #####: 4203:				      rel_loop_end = *option;
        -: 4204:#endif
    #####: 4205:				    option++;
        -: 4206:				  }
    #####: 4207:				else if (lopt_id == SYM_TIME_OFFSET)
branch  0 never executed
branch  1 never executed
    #####: 4208:				  rel_time_offset = '\0';
        -: 4209:#if USE_RC
    #####: 4210:				else if (lopt_id == SYM_CYCLE_END)
branch  0 never executed
branch  1 never executed
    #####: 4211:				  rel_loop_end = '\0';
        -: 4212:#endif
    #####: 4213:				if (*option)
branch  0 never executed
branch  1 never executed
        -: 4214:				  {
    #####: 4215:				    while (*option)
branch  0 never executed
branch  1 never executed
        -: 4216:				      {
    #####: 4217:					skip = FALSE;
    #####: 4218:					switch (state)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 4219:					  {
    #####: 4220:					  case 1:
    #####: 4221:					    if (!isdigit (*option))
branch  0 never executed
branch  1 never executed
        -: 4222:					      {
    #####: 4223:						if (*option == *ASC_LIT
branch  0 never executed
branch  1 never executed
    #####: 4224:						    || *option == *DES_LIT)
branch  0 never executed
branch  1 never executed
        -: 4225:						  {
    #####: 4226:						    if (sign
branch  0 never executed
branch  1 never executed
    #####: 4227:							|| time_sep_found)
branch  0 never executed
branch  1 never executed
    #####: 4228:						      state = 0;
        -: 4229:						    else
    #####: 4230:						      sign++;
    #####: 4231:						    break;
        -: 4232:						  }
        -: 4233:						else
    #####: 4234:						  state++;
        -: 4235:					      }
        -: 4236:					    else
        -: 4237:					      {
    #####: 4238:						if (*option == '0')
branch  0 never executed
branch  1 never executed
        -: 4239:						  {
    #####: 4240:						    if (is_leading_zero)
branch  0 never executed
branch  1 never executed
        -: 4241:						      {
    #####: 4242:							skip = TRUE;
    #####: 4243:							break;
        -: 4244:						      }
    #####: 4245:						    digits++;
        -: 4246:						  }
        -: 4247:						else
    #####: 4248:						  digits++;
    #####: 4249:						is_leading_zero = FALSE;
    #####: 4250:						break;
        -: 4251:					      }
        -: 4252:					    /* Fallthrough. */
        -: 4253:					  case 2:
    #####: 4254:					    if (!digits && !is_leading_zero)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4255:					      state = 0;
    #####: 4256:					    else if (!time_sep_found)
branch  0 never executed
branch  1 never executed
        -: 4257:					      {
    #####: 4258:						if (*option == *time_sep
branch  0 never executed
branch  1 never executed
    #####: 4259:						    || *option ==
branch  0 never executed
branch  1 never executed
    #####: 4260:						    *DEFAULT_TIME_SEP)
        -: 4261:						  {
    #####: 4262:						    if (digits > 2)
branch  0 never executed
branch  1 never executed
    #####: 4263:						      state = 0;
        -: 4264:						    else
        -: 4265:						      {
    #####: 4266:							time_sep_found = TRUE;
    #####: 4267:							digits = 0;
    #####: 4268:							state--;
        -: 4269:						      }
        -: 4270:						  }
        -: 4271:						else
    #####: 4272:						  state = 0;
        -: 4273:					      }
        -: 4274:					    else
        -: 4275:					      {
    #####: 4276:						if (digits > 4)
branch  0 never executed
branch  1 never executed
    #####: 4277:						  state = 0;
        -: 4278:						else
    #####: 4279:						  is_last = TRUE;
        -: 4280:					      }
    #####: 4281:					    break;
    #####: 4282:					  default:
    #####: 4283:					    state = 0;
        -: 4284:					  }
    #####: 4285:					if (state && !skip)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4286:					  s3[i++] = *option;
    #####: 4287:					option++;
        -: 4288:				      }
    #####: 4289:				    if (!state
branch  0 never executed
branch  1 never executed
    #####: 4290:					|| is_last
branch  0 never executed
branch  1 never executed
    #####: 4291:					|| (i
branch  0 never executed
branch  1 never executed
    #####: 4292:					    && !time_sep_found
branch  0 never executed
branch  1 never executed
    #####: 4293:					    && !is_leading_zero
branch  0 never executed
branch  1 never executed
    #####: 4294:					    && !digits)
branch  0 never executed
branch  1 never executed
    #####: 4295:					|| (time_sep_found
branch  0 never executed
branch  1 never executed
    #####: 4296:					    && (digits > 2))
branch  0 never executed
branch  1 never executed
    #####: 4297:					|| ((state == 1) && (digits > 4)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4298:				      /*
        -: 4299:				         Error, invalid condition occurred.
        -: 4300:				       */
    #####: 4301:				      opt_error = 5;
    #####: 4302:				    if (i && !opt_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4303:				      {
    #####: 4304:					s3[i] = '\0';
        -: 4305:					/*
        -: 4306:					   Process the time displacement value.
        -: 4307:					 */
    #####: 4308:					i = atoi (s3);
    #####: 4309:					if (time_sep_found)
branch  0 never executed
branch  1 never executed
        -: 4310:					  {
    #####: 4311:					    i *= MINS_PER_HOUR;
    #####: 4312:					    ptr_char = strchr (s3, *time_sep);
    #####: 4313:					    if (ptr_char == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4314:					      ptr_char =
    #####: 4315:						strchr (s3,
    #####: 4316:							*DEFAULT_TIME_SEP);
    #####: 4317:					    if (*++ptr_char)
branch  0 never executed
branch  1 never executed
        -: 4318:					      {
    #####: 4319:						state = atoi (ptr_char);
    #####: 4320:						if (abs (state) >=
branch  0 never executed
branch  1 never executed
        -: 4321:						    MINS_PER_HOUR)
    #####: 4322:						  opt_error = 5;
    #####: 4323:						else if (!i)
branch  0 never executed
branch  1 never executed
        -: 4324:						  {
    #####: 4325:						    if (*s3 == *DES_LIT)
branch  0 never executed
branch  1 never executed
    #####: 4326:						      i = -state;
        -: 4327:						    else
    #####: 4328:						      i = state;
        -: 4329:						  }
    #####: 4330:						else if (SGN (i) < 0)
branch  0 never executed
branch  1 never executed
    #####: 4331:						  i -= state;
        -: 4332:						else
    #####: 4333:						  i += state;
        -: 4334:					      }
        -: 4335:					  }
    #####: 4336:					if (!opt_error)
branch  0 never executed
branch  1 never executed
    #####: 4337:					  switch (lopt_id)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4338:					    {
    #####: 4339:					    case SYM_TIME_OFFSET:
    #####: 4340:					      time_hour_offset =
branch  0 never executed
branch  1 never executed
    #####: 4341:						MM2HH (abs (i));
    #####: 4342:					      time_min_offset =
    #####: 4343:						abs (i) % MINS_PER_HOUR;
    #####: 4344:					      if (i < 0)
branch  0 never executed
branch  1 never executed
        -: 4345:						{
    #####: 4346:						  time_hour_offset =
    #####: 4347:						    -time_hour_offset;
    #####: 4348:						  time_min_offset =
    #####: 4349:						    -time_min_offset;
        -: 4350:						}
        -: 4351:#if USE_RC
    #####: 4352:					      break;
    #####: 4353:					    case SYM_CYCLE_END:
    #####: 4354:					      loop_end = i;
    #####: 4355:					      set_loop_end = TRUE;
    #####: 4356:					      break;
    #####: 4357:					    case SYM_CYCLE_STEP:
        -: 4358:					      /*
        -: 4359:					         Reduce the given cycle-timestep
        -: 4360:					         value in minutes to a single day.
        -: 4361:					       */
    #####: 4362:					      if (i <= 0)
branch  0 never executed
branch  1 never executed
    #####: 4363:						loop_step =
        -: 4364:						  DEFAULT_CYCLE_STEP;
    #####: 4365:					      else if (i >= MINS_PER_DAY)
branch  0 never executed
branch  1 never executed
    #####: 4366:						loop_step = MINS_PER_DAY - 1;
        -: 4367:					      else
    #####: 4368:						loop_step = i;
        -: 4369:#endif
        -: 4370:					    }
        -: 4371:				      }
        -: 4372:				  }
    #####: 4373:				break;
        -: 4374:			      }
    #####: 4375:			    case SYM_TRANSFORM_YEAR:
    #####: 4376:			      option = strchr (s2, *LARG_SEP) + 1;
    #####: 4377:			      if (*option == '0')
branch  0 never executed
branch  1 never executed
        -: 4378:				{
    #####: 4379:				  while (*option == '0')
branch  0 never executed
branch  1 never executed
    #####: 4380:				    option++;
    #####: 4381:				  if (!*option)
branch  0 never executed
branch  1 never executed
    #####: 4382:				    option--;
        -: 4383:				}
    #####: 4384:			      transform_year = atoi (option);
    #####: 4385:			      if (transform_year > YEAR_MAX
branch  0 never executed
branch  1 never executed
    #####: 4386:				  || transform_year < -YEAR_MAX)
branch  0 never executed
branch  1 never executed
        -: 4387:				/*
        -: 4388:				   Error, long-style option is trailed
        -: 4389:				   by an invalid argument.
        -: 4390:				 */
    #####: 4391:				opt_error = 5;
    #####: 4392:			      break;
    #####: 4393:			    case SYM_TRANSLATE_STRING:
    #####: 4394:			      option = strchr (s2, *LARG_SEP) + 1;
    #####: 4395:			      len = strlen (option);
    #####: 4396:			      if (len & 1)
branch  0 never executed
branch  1 never executed
        -: 4397:				/*
        -: 4398:				   Error, long-style option is trailed
        -: 4399:				   by an invalid argument.
        -: 4400:				 */
    #####: 4401:				opt_error = 5;
        -: 4402:			      else
        -: 4403:				{
    #####: 4404:				  if (translate_string == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4405:				    translate_string =
    #####: 4406:				      (char *) my_malloc (len + 1,
call    0 never executed
        -: 4407:							  ERR_NO_MEMORY_AVAILABLE,
        -: 4408:							  __FILE__,
        -: 4409:							  ((long) __LINE__) -
        -: 4410:							  2L,
        -: 4411:							  "translate_string",
        -: 4412:							  0);
        -: 4413:				  else
    #####: 4414:				    translate_string =
    #####: 4415:				      (char *) my_realloc ((VOID_PTR)
call    0 never executed
        -: 4416:							   translate_string,
        -: 4417:							   len + 1,
        -: 4418:							   ERR_NO_MEMORY_AVAILABLE,
        -: 4419:							   __FILE__,
        -: 4420:							   ((long) __LINE__) -
        -: 4421:							   3L,
        -: 4422:							   "translate_string",
        -: 4423:							   0);
    #####: 4424:				  strcpy (translate_string, option);
        -: 4425:				}
    #####: 4426:			      break;
        -: 4427:			      /*
        -: 4428:			         The common holiday lists.
        -: 4429:			       */
    #####: 4430:			    case SYM_ASTRONOMICAL_HDY:
    #####: 4431:			      hdy_astronomical = TRUE;
    #####: 4432:			      break;
    #####: 4433:			    case SYM_MULTICULTURAL_NEW_YEAR_HDY:
    #####: 4434:			      hdy_multicultural_new_year = TRUE;
    #####: 4435:			      break;
    #####: 4436:			    case SYM_ZODIACAL_MARKER_HDY:
    #####: 4437:			      hdy_zodiacal_marker = TRUE;
    #####: 4438:			      break;
        -: 4439:			      /*
        -: 4440:			         The calendar system specific holiday lists.
        -: 4441:			       */
    #####: 4442:			    case SYM_BAHAI_HDY:
    #####: 4443:			      hdy_bahai = TRUE;
    #####: 4444:			      break;
    #####: 4445:			    case SYM_CELTIC_HDY:
    #####: 4446:			      hdy_celtic = TRUE;
    #####: 4447:			      break;
    #####: 4448:			    case SYM_CHINESE_FLEXIBLE_HDY:
    #####: 4449:			      hdy_chinese_flexible = TRUE;
    #####: 4450:			      break;
    #####: 4451:			    case SYM_CHINESE_HDY:
    #####: 4452:			      hdy_chinese = TRUE;
    #####: 4453:			      break;
    #####: 4454:			    case SYM_CHRISTIAN_HDY:
    #####: 4455:			      hdy_christian = TRUE;
    #####: 4456:			      break;
    #####: 4457:			    case SYM_HEBREW_HDY:
    #####: 4458:			      hdy_hebrew = TRUE;
    #####: 4459:			      break;
    #####: 4460:			    case SYM_ISLAMIC_HDY:
    #####: 4461:			      hdy_islamic = TRUE;
    #####: 4462:			      break;
    #####: 4463:			    case SYM_JAPANESE_FLEXIBLE_HDY:
    #####: 4464:			      hdy_japanese_flexible = TRUE;
    #####: 4465:			      break;
    #####: 4466:			    case SYM_JAPANESE_HDY:
    #####: 4467:			      hdy_japanese = TRUE;
    #####: 4468:			      break;
    #####: 4469:			    case SYM_ORTHODOX_NEW_HDY:
    #####: 4470:			      hdy_orthodox_new = TRUE;
    #####: 4471:			      break;
    #####: 4472:			    case SYM_ORTHODOX_OLD_HDY:
    #####: 4473:			      hdy_orthodox_old = TRUE;
    #####: 4474:			      break;
    #####: 4475:			    case SYM_PERSIAN_HDY:
    #####: 4476:			      hdy_persian = TRUE;
    #####: 4477:			      break;
        -: 4478:			      /*
        -: 4479:			         The calendar system specific month lists.
        -: 4480:			       */
    #####: 4481:			    case SYM_BAHAI_MTH:
    #####: 4482:			      mth_bahai = TRUE;
    #####: 4483:			      break;
    #####: 4484:			    case SYM_CHINESE_FLEXIBLE_MTH:
    #####: 4485:			      mth_chinese_flexible = TRUE;
    #####: 4486:			      break;
    #####: 4487:			    case SYM_CHINESE_MTH:
    #####: 4488:			      mth_chinese = TRUE;
    #####: 4489:			      break;
    #####: 4490:			    case SYM_COPTIC_MTH:
    #####: 4491:			      mth_coptic = TRUE;
    #####: 4492:			      break;
    #####: 4493:			    case SYM_ETHIOPIC_MTH:
    #####: 4494:			      mth_ethiopic = TRUE;
    #####: 4495:			      break;
    #####: 4496:			    case SYM_FRENCH_REVOLUTIONARY_MTH:
    #####: 4497:			      mth_french_revolutionary = TRUE;
    #####: 4498:			      break;
    #####: 4499:			    case SYM_HEBREW_MTH:
    #####: 4500:			      mth_hebrew = TRUE;
    #####: 4501:			      break;
    #####: 4502:			    case SYM_INDIAN_CIVIL_MTH:
    #####: 4503:			      mth_indian_civil = TRUE;
    #####: 4504:			      break;
    #####: 4505:			    case SYM_ISLAMIC_MTH:
    #####: 4506:			      mth_islamic = TRUE;
    #####: 4507:			      break;
    #####: 4508:			    case SYM_JAPANESE_FLEXIBLE_MTH:
    #####: 4509:			      mth_japanese_flexible = TRUE;
    #####: 4510:			      break;
    #####: 4511:			    case SYM_JAPANESE_MTH:
    #####: 4512:			      mth_japanese = TRUE;
    #####: 4513:			      break;
    #####: 4514:			    case SYM_OLD_ARMENIC_MTH:
    #####: 4515:			      mth_old_armenic = TRUE;
    #####: 4516:			      break;
    #####: 4517:			    case SYM_OLD_EGYPTIC_MTH:
    #####: 4518:			      mth_old_egyptic = TRUE;
    #####: 4519:			      break;
    #####: 4520:			    case SYM_PERSIAN_MTH:
    #####: 4521:			      mth_persian = TRUE;
    #####: 4522:			      break;
    #####: 4523:			    default:
    #####: 4524:			      option = s2;
        -: 4525:			      /*
        -: 4526:			         Now we have decoded a long-style option into the
        -: 4527:			         according short-style option, let's JUMP to that
        -: 4528:			         part where the short options are decoded/evaluated
        -: 4529:			         resp., processed (to JUMP isn't best coding style,
        -: 4530:			         I know [Hi Mr.Dijkstra], but it's the easiest to
        -: 4531:			         do now  =8^)
        -: 4532:			       */
    #####: 4533:			      goto LABEL_short_option;
        -: 4534:			    }
        -: 4535:			}
        -: 4536:		      else
        5: 4537:			option = s2;
        -: 4538:		    }
        -: 4539:		  else
        -: 4540:		    /*
        -: 4541:		       Hmm, seems that a just processed short-style option having
        -: 4542:		       permitted modifiers has an invalid switch character
        -: 4543:		       within its modifiers.
        -: 4544:		     */
        2: 4545:		    opt_error = 5;
        7: 4546:		  skip_option = TRUE;
        -: 4547:		}
        -: 4548:	      else
        -: 4549:		/*
        -: 4550:		   Check for short options...
        -: 4551:		 */
       11: 4552:	      LABEL_short_option:
       11: 4553:		switch (*option)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 73%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
branch 28 taken 0%
branch 29 taken 0%
branch 30 taken 0%
branch 31 taken 0%
branch 32 taken 0%
branch 33 taken 0%
branch 34 taken 0%
branch 35 taken 0%
branch 36 taken 0%
branch 37 taken 27%
        -: 4554:		  {
    #####: 4555:		  case '?':
        -: 4556:		  case 'h':
    #####: 4557:		    skip_option = help_flag = TRUE;
    #####: 4558:		    option++;
    #####: 4559:		    if (*option)
branch  0 never executed
branch  1 never executed
        -: 4560:		      {
    #####: 4561:			if (*option == '?' || *option == 'h')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4562:			  {
    #####: 4563:			    ext_help_flag = TRUE;
    #####: 4564:			    lopt_help = SYM_NIL;
    #####: 4565:			    option++;
    #####: 4566:			    if (*option && is_longopt)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4567:			      {
        -: 4568:				/*
        -: 4569:				   Copy the long-style option argument into buffer.
        -: 4570:				 */
    #####: 4571:				len = (int) strlen (option);
    #####: 4572:				if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 4573:				  resize_all_strings (len + 1, FALSE,
call    0 never executed
        -: 4574:						      __FILE__,
        -: 4575:						      (long) __LINE__);
    #####: 4576:				strcpy (s3, option);
        -: 4577:				/*
        -: 4578:				   Get the reference number of the long-style option
        -: 4579:				   argument which is a long-style option itself.
        -: 4580:				 */
    #####: 4581:				lopt_ambig =
    #####: 4582:				  (Bool) (eval_longopt (s3, &lopt_help) == 1);
call    0 never executed
    #####: 4583:				if (lopt_help == SYM_NIL)
branch  0 never executed
branch  1 never executed
        -: 4584:				  /*
        -: 4585:				     Error, no help related to this argument found,
        -: 4586:				     so we display the "help on help" screen now.
        -: 4587:				   */
    #####: 4588:				  help_on_help_flag = TRUE;
        -: 4589:			      }
    #####: 4590:			    else if (*option)
branch  0 never executed
branch  1 never executed
        -: 4591:			      /*
        -: 4592:			         Error, invalid option modifier given.
        -: 4593:			       */
    #####: 4594:			      opt_error = 2;
        -: 4595:			  }
        -: 4596:			else
        -: 4597:			  /*
        -: 4598:			     Error, no semi-long option name `-??' or `-hh' given.
        -: 4599:			   */
    #####: 4600:			  opt_error = 2;
        -: 4601:		      }
    #####: 4602:		    break;
    #####: 4603:		  case 'G':
        -: 4604:		  case 'K':
        -: 4605:		  case 'L':
        -: 4606:		  case 'O':
        -: 4607:		  case 'V':
        -: 4608:		  case 'X':
        -: 4609:#if USE_PAGER
        -: 4610:		  case 'p':
        -: 4611:#endif
        -: 4612:		  case 'u':
    #####: 4613:		    option++;
    #####: 4614:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 4615:		      {
    #####: 4616:			option--;
    #####: 4617:			switch (*option)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -: 4618:			  {
    #####: 4619:			  case 'G':
    #####: 4620:			    hd_suppr_list_sep_flag = TRUE;
    #####: 4621:			    break;
    #####: 4622:			  case 'K':
    #####: 4623:			    cal_with_week_number = TRUE;
    #####: 4624:			    break;
    #####: 4625:			  case 'L':
    #####: 4626:			    license_flag = TRUE;
    #####: 4627:			    break;
    #####: 4628:			  case 'O':
    #####: 4629:			    orthodox_calendar = TRUE;
    #####: 4630:			    break;
    #####: 4631:			  case 'V':
    #####: 4632:			    version_flag = TRUE;
    #####: 4633:			    break;
    #####: 4634:			  case 'X':
    #####: 4635:			    hd_title_flag = FALSE;
    #####: 4636:			    break;
        -: 4637:#if USE_PAGER
    #####: 4638:			  case 'p':
    #####: 4639:			    pager_flag = TRUE;
    #####: 4640:			    break;
        -: 4641:#endif
    #####: 4642:			  case 'u':
    #####: 4643:			    suppr_cal_flag = TRUE;
    #####: 4644:			    break;
    #####: 4645:			  default:
        -: 4646:			    /*
        -: 4647:			       This case MUST be an internal error!
        -: 4648:			     */
    #####: 4649:			    abort ();
call    0 never executed
        -: 4650:			  }
    #####: 4651:			skip_option = TRUE;
        -: 4652:		      }
        -: 4653:		    else
        -: 4654:		      /*
        -: 4655:		         Error, invalid option modifier given.
        -: 4656:		       */
    #####: 4657:		      opt_error = 2;
    #####: 4658:		    break;
    #####: 4659:		  case 'R':
    #####: 4660:		    option++;
    #####: 4661:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 4662:		      /*
        -: 4663:		         Error, option character is not trailed by an argument.
        -: 4664:		       */
    #####: 4665:		      opt_error = 4;
        -: 4666:		    else
        -: 4667:		      {
    #####: 4668:			if (rsp_filename == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4669:			  rsp_filename =
    #####: 4670:			    (char *) my_malloc (strlen (option) + 1,
call    0 never executed
        -: 4671:						ERR_NO_MEMORY_AVAILABLE,
        -: 4672:						__FILE__,
        -: 4673:						((long) __LINE__) - 2L,
        -: 4674:						"rsp_filename", 0);
        -: 4675:			else
    #####: 4676:			  rsp_filename =
    #####: 4677:			    (char *) my_realloc ((VOID_PTR) rsp_filename,
call    0 never executed
    #####: 4678:						 strlen (option) + 1,
        -: 4679:						 ERR_NO_MEMORY_AVAILABLE,
        -: 4680:						 __FILE__,
        -: 4681:						 ((long) __LINE__) - 3L,
        -: 4682:						 "rsp_filename", 0);
    #####: 4683:			strcpy (rsp_filename, option);
    #####: 4684:			skip_option = TRUE;
        -: 4685:		      }
    #####: 4686:		    break;
        -: 4687:#ifdef GCAL_SHELL
    #####: 4688:		  case 'S':
    #####: 4689:		    option++;
    #####: 4690:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 4691:		      /*
        -: 4692:		         Error, option character is not trailed by an argument.
        -: 4693:		       */
    #####: 4694:		      opt_error = 4;
        -: 4695:		    else
        -: 4696:		      {
    #####: 4697:			if (shl_filename == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4698:			  shl_filename =
    #####: 4699:			    (char *) my_malloc (strlen (option) + 1,
call    0 never executed
        -: 4700:						ERR_NO_MEMORY_AVAILABLE,
        -: 4701:						__FILE__,
        -: 4702:						((long) __LINE__) - 2L,
        -: 4703:						"shl_filename", 0);
        -: 4704:			else
    #####: 4705:			  shl_filename =
    #####: 4706:			    (char *) my_realloc ((VOID_PTR) shl_filename,
call    0 never executed
    #####: 4707:						 strlen (option) + 1,
        -: 4708:						 ERR_NO_MEMORY_AVAILABLE,
        -: 4709:						 __FILE__,
        -: 4710:						 ((long) __LINE__) - 3L,
        -: 4711:						 "shl_filename", 0);
    #####: 4712:			strcpy (shl_filename, option);
    #####: 4713:			skip_option = TRUE;
        -: 4714:		      }
    #####: 4715:		    break;
        -: 4716:#endif
    #####: 4717:		  case 'H':
    #####: 4718:		    option++;
    #####: 4719:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 4720:		      /*
        -: 4721:		         Error, option character is not trailed by an argument.
        -: 4722:		       */
    #####: 4723:		      opt_error = 4;
        -: 4724:		    else
        -: 4725:		      {
    #####: 4726:			len = (int) strlen (option);
        -: 4727:			/*
        -: 4728:			   Check if the special argument `no' is given:
        -: 4729:			   If only `long-option=NO' instead of both long-style
        -: 4730:			   and short-style option; like `short-optionNO';
        -: 4731:			   should be valid, extend following if() statement
        -: 4732:			   like this:
        -: 4733:			   if (is_longopt && ...
        -: 4734:			 */
    #####: 4735:			if ((len == 2)
branch  0 never executed
branch  1 never executed
    #####: 4736:			    && (tolower (*option) == 'n')
branch  0 never executed
branch  1 never executed
    #####: 4737:			    && (tolower (*(option + 1)) == 'o'))
branch  0 never executed
branch  1 never executed
    #####: 4738:			  highlight_flag = FALSE;
        -: 4739:			else
        -: 4740:			  /*
        -: 4741:			     Check if the special argument `yes' is given:
        -: 4742:			     If only `long-option=YES' instead of both
        -: 4743:			     long-style and short-style option; like
        -: 4744:			     `short-optionYES'; should be valid, extend
        -: 4745:			     following if() statement like this:
        -: 4746:			     if (is_longopt && ...
        -: 4747:			   */
    #####: 4748:			if ((len == 3)
branch  0 never executed
branch  1 never executed
    #####: 4749:			      && (tolower (*option) == 'y')
branch  0 never executed
branch  1 never executed
    #####: 4750:			      && (tolower (*(option + 1)) == 'e')
branch  0 never executed
branch  1 never executed
    #####: 4751:			      && (tolower (*(option + 2)) == 's'))
branch  0 never executed
branch  1 never executed
        -: 4752:			  {
    #####: 4753:			    highlight_flag = TRUE;
    #####: 4754:			    is_tty = (int) TRUE;
        -: 4755:			  }
        -: 4756:			else
        -: 4757:			  {
    #####: 4758:			    if (hl_seq == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4759:			      hl_seq =
    #####: 4760:				(char *) my_malloc (strlen (option) + 1,
call    0 never executed
        -: 4761:						    ERR_NO_MEMORY_AVAILABLE,
        -: 4762:						    __FILE__,
        -: 4763:						    ((long) __LINE__) - 2L,
        -: 4764:						    "hl_seq", 0);
        -: 4765:			    else
    #####: 4766:			      hl_seq = (char *) my_realloc ((VOID_PTR) hl_seq,
call    0 never executed
    #####: 4767:							    strlen (option) +
        -: 4768:							    1,
        -: 4769:							    ERR_NO_MEMORY_AVAILABLE,
        -: 4770:							    __FILE__,
        -: 4771:							    ((long) __LINE__)
        -: 4772:							    - 3L, "hl_seq",
        -: 4773:							    0);
    #####: 4774:			    strcpy (hl_seq, option);
    #####: 4775:			    highlight_flag = TRUE;
        -: 4776:			  }
        -: 4777:		      }
    #####: 4778:		    skip_option = TRUE;
    #####: 4779:		    break;
    #####: 4780:		  case 'i':
    #####: 4781:		    option++;
        -: 4782:#ifdef GCAL_NLS
    #####: 4783:		    if (is_en)
branch  0 never executed
branch  1 never executed
        -: 4784:		      {
    #####: 4785:			special_calsheet_flag = FALSE;
    #####: 4786:			if (!year_flag)
branch  0 never executed
branch  1 never executed
    #####: 4787:			  out_rows = S_OUT_ROWS;
        -: 4788:		      }
        -: 4789:		    else
        -: 4790:		      {
    #####: 4791:			special_calsheet_flag = TRUE;
    #####: 4792:			if (!year_flag)
branch  0 never executed
branch  1 never executed
    #####: 4793:			  out_rows = J_OUT_ROWS;
        -: 4794:		      }
        -: 4795:#else /* !GCAL_NLS */
        -: 4796:		    special_calsheet_flag = FALSE;
        -: 4797:		    if (!year_flag)
        -: 4798:		      out_rows = S_OUT_ROWS;
        -: 4799:#endif	/* !GCAL_NLS */
        -: 4800:
    #####: 4801:		    if (*option)
branch  0 never executed
branch  1 never executed
        -: 4802:		      {
    #####: 4803:			if (*option == '-')
branch  0 never executed
branch  1 never executed
        -: 4804:			  {
    #####: 4805:			    option++;
    #####: 4806:			    if (*option)
branch  0 never executed
branch  1 never executed
        -: 4807:			      /*
        -: 4808:			         Error, option character is trailed
        -: 4809:			         by an invalid argument.
        -: 4810:			       */
    #####: 4811:			      opt_error = 5;
        -: 4812:			  }
        -: 4813:			else
        -: 4814:			  /*
        -: 4815:			     Error, option character is trailed by
        -: 4816:			     an invalid modifier.
        -: 4817:			   */
    #####: 4818:			  opt_error = 5;
        -: 4819:		      }
    #####: 4820:		    option--;
    #####: 4821:		    break;
    #####: 4822:		  case 'n':
        -: 4823:		  case 'N':
    #####: 4824:		    skip_option = holiday_flag = TRUE;
    #####: 4825:		    hd_sort_des_flag = FALSE;
    #####: 4826:		    hd_legal_days_only =
    #####: 4827:		      (Bool) ((*option == 'N') ? TRUE : FALSE);
    #####: 4828:		    option++;
    #####: 4829:		    if (*option)
branch  0 never executed
branch  1 never executed
        -: 4830:		      {
    #####: 4831:			if (*option == *DES_LIT)
branch  0 never executed
branch  1 never executed
    #####: 4832:			  hd_sort_des_flag = TRUE;
        -: 4833:			else
        -: 4834:			  /*
        -: 4835:			     Error, option character is trailed
        -: 4836:			     by an invalid modifier.
        -: 4837:			   */
    #####: 4838:			  opt_error = 5;
        -: 4839:		      }
    #####: 4840:		    break;
    #####: 4841:		  case 'q':
    #####: 4842:		    option++;
    #####: 4843:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 4844:		      /*
        -: 4845:		         Error, option character is not trailed
        -: 4846:		         by an argument.
        -: 4847:		       */
    #####: 4848:		      opt_error = 4;
        -: 4849:		    else
        -: 4850:		      /*
        -: 4851:		         Check for country code id's which are listed in the
        -: 4852:		         `cc_holidays' table.  If more than one country code
        -: 4853:		         is specified, it must be connected by a CONNECT_SEP.
        -: 4854:		       */
        -: 4855:		      {
        -: 4856:			auto const Cc_struct *ptr_cc;
        -: 4857:
        -: 4858:
    #####: 4859:			*s1 = '\0';
    #####: 4860:			ptr_char = option;
    #####: 4861:			while (*ptr_char && !opt_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4862:			  do
        -: 4863:			    {
        -: 4864:			      /*
        -: 4865:			         Copy a single, given country code into `s2'.
        -: 4866:			       */
    #####: 4867:			      i = 0;
    #####: 4868:			      while (*ptr_char && (*ptr_char != *CONNECT_SEP))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4869:				s2[i++] = (char) toupper (*ptr_char++);
    #####: 4870:			      s2[i] = '\0';
        -: 4871:			      /*
        -: 4872:			         Now skip a possibly trailing CONNECT_SEP.
        -: 4873:			       */
    #####: 4874:			      if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 4875:				ptr_char++;
    #####: 4876:			      ptr_cc = binsearch_cc_id (s2);
call    0 never executed
    #####: 4877:			      if (ptr_cc == (Cc_struct *) NULL)
branch  0 never executed
branch  1 never executed
        -: 4878:				{
        -: 4879:				  /*
        -: 4880:				     Error, country code not found.
        -: 4881:				   */
    #####: 4882:				  opt_error = 5;
    #####: 4883:				  break;
        -: 4884:				}
        -: 4885:			      else
        -: 4886:				/*
        -: 4887:				   Country code found, but insert it into `s1'
        -: 4888:				   only in case it is not already listed there.
        -: 4889:				 */
    #####: 4890:			      if (strstr (s1, s2) == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 4891:				{
    #####: 4892:				  strcat (s1, s2);
    #####: 4893:				  if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 4894:				    strcat (s1, CONNECT_SEP);
        -: 4895:				}
        -: 4896:			    }
    #####: 4897:			  while (*ptr_char);
branch  0 never executed
branch  1 never executed
    #####: 4898:			if (!opt_error)
branch  0 never executed
branch  1 never executed
        -: 4899:			  {
    #####: 4900:			    if (cc == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 4901:			      cc = (char *) my_malloc (strlen (s1) + 1,
call    0 never executed
        -: 4902:						       ERR_NO_MEMORY_AVAILABLE,
        -: 4903:						       __FILE__,
        -: 4904:						       ((long) __LINE__) - 2L,
        -: 4905:						       "cc", 0);
        -: 4906:			    else
    #####: 4907:			      cc = (char *) my_realloc ((VOID_PTR) cc,
call    0 never executed
    #####: 4908:							strlen (s1) + 1,
        -: 4909:							ERR_NO_MEMORY_AVAILABLE,
        -: 4910:							__FILE__,
        -: 4911:							((long) __LINE__) -
        -: 4912:							3L, "cc", 0);
    #####: 4913:			    strcpy (cc, s1);
        -: 4914:			  }
        -: 4915:		      }
    #####: 4916:		    skip_option = TRUE;
    #####: 4917:		    break;
    #####: 4918:		  case '!':
    #####: 4919:		    if (!is_longopt)
branch  0 never executed
branch  1 never executed
        -: 4920:		      /*
        -: 4921:		         Error, invalid short-style option character given.
        -: 4922:		       */
    #####: 4923:		      opt_error = 2;
        -: 4924:		    else
        -: 4925:		      {
        -: 4926:			/*
        -: 4927:			   Get the argument of the `--date-format=PRESET_VALUE|ARG' long-style option.
        -: 4928:			 */
    #####: 4929:			option++;
    #####: 4930:			if ((Uint) * option < LARG_MAX - 1)
branch  0 never executed
branch  1 never executed
        -: 4931:			  {
    #####: 4932:			    date_format = supported_date_format;
    #####: 4933:			    date_format += ((Uint) * option - 1);
    #####: 4934:			    if (date_format->df_id == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 4935:			      /*
        -: 4936:			         Error, index of an "empty" table element referenced.
        -: 4937:			       */
    #####: 4938:			      opt_error = 5;
        -: 4939:			  }
        -: 4940:			else
        -: 4941:			  {
        -: 4942:			    /*
        -: 4943:			       Respect this given argument now.
        -: 4944:			     */
    #####: 4945:			    users_date_format.df_info = _("command line");
    #####: 4946:			    if (users_date_format.df_format == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 4947:			      users_date_format.df_format
    #####: 4948:				= (char *) my_malloc (strlen (option) + 1,
call    0 never executed
        -: 4949:						      ERR_NO_MEMORY_AVAILABLE,
        -: 4950:						      __FILE__,
        -: 4951:						      ((long) __LINE__) - 2L,
        -: 4952:						      "users_date_format.df_format",
        -: 4953:						      0);
        -: 4954:			    else
        -: 4955:			      users_date_format.df_format
    #####: 4956:				=
    #####: 4957:				(char *) my_realloc ((VOID_PTR)
call    0 never executed
    #####: 4958:						     users_date_format.
        -: 4959:						     df_format,
    #####: 4960:						     strlen (option) + 1,
        -: 4961:						     ERR_NO_MEMORY_AVAILABLE,
        -: 4962:						     __FILE__,
        -: 4963:						     ((long) __LINE__) - 3L,
        -: 4964:						     "users_date_format.df_format",
        -: 4965:						     0);
    #####: 4966:			    strcpy (users_date_format.df_format, option);
    #####: 4967:			    date_format = &users_date_format;
        -: 4968:			  }
    #####: 4969:			if (!opt_error)
branch  0 never executed
branch  1 never executed
        -: 4970:			  {
        -: 4971:			    /*
        -: 4972:			       Test if the date format given in command line is valid.
        -: 4973:			     */
    #####: 4974:			    if (!is_correct_date_format
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 4975:				(date_format->df_format, &use_day_suffix,
        -: 4976:				 &use_short3_day_name, &use_day_zeroleaded,
        -: 4977:				 &use_year_zeroleaded))
    #####: 4978:			      errtxt_dformat = _("command line");
        -: 4979:			    else
    #####: 4980:			      errtxt_dformat = (char *) NULL;
        -: 4981:			  }
    #####: 4982:			skip_option = TRUE;
        -: 4983:		      }
    #####: 4984:		    break;
    #####: 4985:		  case '$':
    #####: 4986:		    if (!is_longopt)
branch  0 never executed
branch  1 never executed
        -: 4987:		      /*
        -: 4988:		         Error, invalid short-style option character given.
        -: 4989:		       */
    #####: 4990:		      opt_error = 2;
        -: 4991:		    else
        -: 4992:		      {
        -: 4993:			/*
        -: 4994:			   Get the argument of the `--gregorian-reform=PRESET_VALUE|ARG' long-style option.
        -: 4995:			 */
    #####: 4996:			option++;
    #####: 4997:			if ((Uint) * option < LARG_MAX - 1)
branch  0 never executed
branch  1 never executed
        -: 4998:			  {
    #####: 4999:			    greg = greg_reform_date;
    #####: 5000:			    greg += ((Uint) * option - 1);
    #####: 5001:			    if (!greg->year)
branch  0 never executed
branch  1 never executed
        -: 5002:			      /*
        -: 5003:			         Error, index of an "empty" table element referenced.
        -: 5004:			       */
    #####: 5005:			      opt_error = 5;
        -: 5006:			  }
        -: 5007:			else
        -: 5008:			  {
    #####: 5009:			    auto Bool ok = FALSE;
        -: 5010:
        -: 5011:
        -: 5012:			    /*
        -: 5013:			       Check whether the argument is a valid Gregorian
        -: 5014:			       Reformation date, which must consist of the year,
        -: 5015:			       the month, the first day and the last day (all
        -: 5016:			       these date elements must be numbers and separated
        -: 5017:			       by a SPLIT_SEP) the Gregorian Reformation has
        -: 5018:			       occurred, like:  YYYYY,MM,DD,DD (MAX==10002,12,31,31)
        -: 5019:			     */
    #####: 5020:			    users_greg.year = users_greg.month =
    #####: 5021:			      users_greg.first_day = users_greg.last_day = 0;
    #####: 5022:			    ptr_char = option;
        -: 5023:			    do
        -: 5024:			      {
    #####: 5025:				i = 0;
    #####: 5026:				while (!ok && !opt_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5027:				  {
    #####: 5028:				    if (isdigit (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 5029:					&& (i <= len_year_max))
branch  0 never executed
branch  1 never executed
    #####: 5030:				      s1[i++] = *ptr_char;
        -: 5031:				    else
        -: 5032:				      {
    #####: 5033:					if (isdigit (*ptr_char))
branch  0 never executed
branch  1 never executed
        -: 5034:					  /*
        -: 5035:					     Error, single date element too long.
        -: 5036:					   */
    #####: 5037:					  opt_error = 5;
        -: 5038:					else
    #####: 5039:					  if (i && (*ptr_char == *SPLIT_SEP))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5040:					  {
    #####: 5041:					    ptr_char++;
    #####: 5042:					    if (*ptr_char == *SPLIT_SEP)
branch  0 never executed
branch  1 never executed
        -: 5043:					      /*
        -: 5044:					         Error, argument contains two
        -: 5045:					         successive SPLIT_SEPs.
        -: 5046:					       */
    #####: 5047:					      opt_error = 5;
        -: 5048:					    else
        -: 5049:					      /*
        -: 5050:					         Scanning of single date element
        -: 5051:					         completed.
        -: 5052:					       */
    #####: 5053:					      break;
        -: 5054:					  }
    #####: 5055:					else if (!i && *ptr_char)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5056:					  /*
        -: 5057:					     Error, either argument starts
        -: 5058:					     with a SPLIT_SEP or contains
        -: 5059:					     invalid characters.
        -: 5060:					   */
    #####: 5061:					  opt_error = 5;
        -: 5062:					else
        -: 5063:					  /*
        -: 5064:					     Scanning of all date elements
        -: 5065:					     completed.
        -: 5066:					   */
    #####: 5067:					  ok = TRUE;
        -: 5068:				      }
    #####: 5069:				    if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 5070:				      ptr_char++;
        -: 5071:				  }
    #####: 5072:				if (!opt_error)
branch  0 never executed
branch  1 never executed
        -: 5073:				  {
    #####: 5074:				    s1[i] = '\0';
    #####: 5075:				    len = i;
    #####: 5076:				    i = atoi (s1);
    #####: 5077:				    if (i)
branch  0 never executed
branch  1 never executed
        -: 5078:				      {
    #####: 5079:					if (!users_greg.year)
branch  0 never executed
branch  1 never executed
        -: 5080:					  {
    #####: 5081:					    if (len > len_year_max)
branch  0 never executed
branch  1 never executed
    #####: 5082:					      if (atol (s1) > YEAR_MAX + 3)
branch  0 never executed
branch  1 never executed
        -: 5083:						/*
        -: 5084:						   Error, invalid year.
        -: 5085:						 */
    #####: 5086:						opt_error = 5;
    #####: 5087:					    users_greg.year = i;
        -: 5088:					  }
    #####: 5089:					else if (!users_greg.month)
branch  0 never executed
branch  1 never executed
    #####: 5090:					  users_greg.month = i;
    #####: 5091:					else if (!users_greg.first_day)
branch  0 never executed
branch  1 never executed
    #####: 5092:					  users_greg.first_day = i;
    #####: 5093:					else if (!users_greg.last_day)
branch  0 never executed
branch  1 never executed
    #####: 5094:					  users_greg.last_day = i;
        -: 5095:					else
        -: 5096:					  /*
        -: 5097:					     Error, argument contains too many
        -: 5098:					     date elements.
        -: 5099:					   */
    #####: 5100:					  opt_error = 5;
        -: 5101:				      }
        -: 5102:				    else
        -: 5103:				      /*
        -: 5104:				         Error, argument contains invalid
        -: 5105:				         date element.
        -: 5106:				       */
    #####: 5107:				      opt_error = 5;
        -: 5108:				  }
        -: 5109:			      }
    #####: 5110:			    while (!ok && !opt_error);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5111:			    /*
        -: 5112:			       Now we have decoded the argument, so let's check
        -: 5113:			       if the single date elements are valid.
        -: 5114:			     */
    #####: 5115:			    if (!opt_error)
branch  0 never executed
branch  1 never executed
        -: 5116:			      {
    #####: 5117:				if (users_greg.month
branch  0 never executed
branch  1 never executed
    #####: 5118:				    && users_greg.first_day
branch  0 never executed
branch  1 never executed
    #####: 5119:				    && users_greg.last_day
branch  0 never executed
branch  1 never executed
    #####: 5120:				    && (users_greg.year <= YEAR_MAX + 3)
branch  0 never executed
branch  1 never executed
    #####: 5121:				    && (users_greg.month <= MONTH_MAX)
branch  0 never executed
branch  1 never executed
    #####: 5122:				    && (users_greg.last_day >=
branch  0 never executed
branch  1 never executed
    #####: 5123:					users_greg.first_day)
    #####: 5124:				    &&
branch  0 never executed
branch  1 never executed
    #####: 5125:				    (((users_greg.month == 2)
    #####: 5126:				      && (users_greg.last_day <=
branch  0 never executed
branch  1 never executed
    #####: 5127:					  ((users_greg.year & 3) ? 28 : 29)))
branch  0 never executed
branch  1 never executed
    #####: 5128:				     || ((users_greg.month != 2)
branch  0 never executed
branch  1 never executed
    #####: 5129:					 && (users_greg.last_day <=
branch  0 never executed
branch  1 never executed
    #####: 5130:					     dvec[users_greg.month - 1]))))
        -: 5131:				  /*
        -: 5132:				     The given argument is valid, so respect
        -: 5133:				     this given date of Gregorian Reformation.
        -: 5134:				   */
    #####: 5135:				  greg = &users_greg;
        -: 5136:				else
        -: 5137:				  /*
        -: 5138:				     Error, invalid date element found.
        -: 5139:				   */
    #####: 5140:				  opt_error = 5;
        -: 5141:			      }
        -: 5142:			  }
    #####: 5143:			skip_option = TRUE;
        -: 5144:		      }
    #####: 5145:		    break;
    #####: 5146:		  case 'j':
    #####: 5147:		    option++;
    #####: 5148:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5149:		      {
    #####: 5150:			cal_special_flag = TRUE;
    #####: 5151:			cal_both_dates_flag = FALSE;
        -: 5152:		      }
        -: 5153:		    else
        -: 5154:		      {
    #####: 5155:			if (*option == 'b')
branch  0 never executed
branch  1 never executed
        -: 5156:			  {
    #####: 5157:			    option++;
    #####: 5158:			    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5159:			      {
    #####: 5160:				cal_special_flag = FALSE;
    #####: 5161:				cal_both_dates_flag = TRUE;
        -: 5162:			      }
        -: 5163:			    else
        -: 5164:			      /*
        -: 5165:			         Error, option character is trailed
        -: 5166:			         by an invalid modifier.
        -: 5167:			       */
    #####: 5168:			      opt_error = 5;
        -: 5169:			  }
        -: 5170:			else
        -: 5171:			  {
    #####: 5172:			    switch (*option)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 5173:			      {
    #####: 5174:			      case 'n':
    #####: 5175:				option++;
    #####: 5176:				if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5177:				  {
    #####: 5178:				    hd_special_flag = TRUE;
    #####: 5179:				    hd_both_dates_flag = FALSE;
        -: 5180:				  }
    #####: 5181:				else if (*option == 'b')
branch  0 never executed
branch  1 never executed
        -: 5182:				  {
    #####: 5183:				    hd_special_flag = FALSE;
    #####: 5184:				    hd_both_dates_flag = TRUE;
        -: 5185:				  }
        -: 5186:				else
        -: 5187:				  /*
        -: 5188:				     Error, option character is trailed
        -: 5189:				     by an invalid modifier.
        -: 5190:				   */
    #####: 5191:				  opt_error = 5;
    #####: 5192:				break;
        -: 5193:#if USE_RC
    #####: 5194:			      case 'c':
    #####: 5195:				option++;
    #####: 5196:				if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5197:				  {
    #####: 5198:				    rc_special_flag = TRUE;
    #####: 5199:				    rc_both_dates_flag = FALSE;
        -: 5200:				  }
    #####: 5201:				else if (*option == 'b')
branch  0 never executed
branch  1 never executed
        -: 5202:				  {
    #####: 5203:				    rc_special_flag = FALSE;
    #####: 5204:				    rc_both_dates_flag = TRUE;
        -: 5205:				  }
        -: 5206:				else
        -: 5207:				  /*
        -: 5208:				     Error, option character is trailed
        -: 5209:				     by an invalid modifier.
        -: 5210:				   */
    #####: 5211:				  opt_error = 5;
    #####: 5212:				break;
        -: 5213:#endif
    #####: 5214:			      default:
        -: 5215:				/*
        -: 5216:				   Error, option character is trailed
        -: 5217:				   by an invalid modifier.
        -: 5218:				 */
    #####: 5219:				opt_error = 5;
        -: 5220:			      }
        -: 5221:			  }
        -: 5222:		      }
    #####: 5223:		    if (!*option)
branch  0 never executed
branch  1 never executed
    #####: 5224:		      option--;
    #####: 5225:		    break;
    #####: 5226:		  case 'b':
    #####: 5227:		    skip_option = year_flag = TRUE;
    #####: 5228:		    option++;
    #####: 5229:		    if (*option == '0')
branch  0 never executed
branch  1 never executed
        -: 5230:		      {
    #####: 5231:			while (*option == '0')
branch  0 never executed
branch  1 never executed
    #####: 5232:			  option++;
    #####: 5233:			if (!*option)
branch  0 never executed
branch  1 never executed
    #####: 5234:			  option--;
        -: 5235:		      }
    #####: 5236:		    out_rows = my_atoi (option);
call    0 never executed
    #####: 5237:		    if (out_rows > MONTH_MAX
branch  0 never executed
branch  1 never executed
    #####: 5238:			|| out_rows < MONTH_MIN
branch  0 never executed
branch  1 never executed
    #####: 5239:			|| out_rows == 5
branch  0 never executed
branch  1 never executed
    #####: 5240:			|| ((out_rows > 6) && (out_rows < MONTH_MAX)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5241:		      {
    #####: 5242:			if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5243:			  /*
        -: 5244:			     Error, option character is not trailed
        -: 5245:			     by an argument.
        -: 5246:			   */
    #####: 5247:			  opt_error = 4;
        -: 5248:			else
        -: 5249:			  /*
        -: 5250:			     Error, option character is trailed
        -: 5251:			     by an invalid argument.
        -: 5252:			   */
    #####: 5253:			  opt_error = 5;
        -: 5254:		      }
    #####: 5255:		    break;
    #####: 5256:		  case 's':
    #####: 5257:		    option++;
    #####: 5258:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5259:		      /*
        -: 5260:		         Error, option character is not trailed by an argument.
        -: 5261:		       */
    #####: 5262:		      opt_error = 4;
        -: 5263:		    else
        -: 5264:		      {
    #####: 5265:			start_day = my_atoi (option);
call    0 never executed
        -: 5266:			/*
        -: 5267:			   Check for delivered weekday name.
        -: 5268:			 */
    #####: 5269:			if (!start_day)
branch  0 never executed
branch  1 never executed
    #####: 5270:			  start_day = compare_d_m_name (option, DAy);
call    0 never executed
    #####: 5271:			if (!start_day)
branch  0 never executed
branch  1 never executed
        -: 5272:			  {
        -: 5273:			    /*
        -: 5274:			       Check if the 'today' text is given.
        -: 5275:			     */
    #####: 5276:			    len = (int) strlen (option);
    #####: 5277:			    if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 5278:			      resize_all_strings (len + 1, FALSE, __FILE__,
call    0 never executed
        -: 5279:						  (long) __LINE__);
    #####: 5280:			    strcpy (s1, option);
    #####: 5281:			    if (strlen (s1) > strlen ("today"))
branch  0 never executed
branch  1 never executed
        -: 5282:			      /*
        -: 5283:			         Error, option character is trailed
        -: 5284:			         by an invalid argument.
        -: 5285:			       */
    #####: 5286:			      opt_error = 5;
        -: 5287:			    else
    #####: 5288:			      if (isdigit (*option)
branch  0 never executed
branch  1 never executed
    #####: 5289:				  || !strncasecmp (s1, "today", len))
branch  0 never executed
branch  1 never executed
        -: 5290:			      /*
        -: 5291:			         Set a special value for a given `-s0' argument.
        -: 5292:			       */
    #####: 5293:			      start_day = SPECIAL_VALUE;
        -: 5294:			    else
        -: 5295:			      /*
        -: 5296:			         Error, option character is trailed
        -: 5297:			         by an invalid argument.
        -: 5298:			       */
    #####: 5299:			      opt_error = 5;
        -: 5300:			  }
    #####: 5301:			else if (start_day > DAY_MAX || start_day < DAY_MIN)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5302:			  /*
        -: 5303:			     Error, option character is trailed
        -: 5304:			     by an invalid argument.
        -: 5305:			   */
    #####: 5306:			  opt_error = 5;
        -: 5307:		      }
    #####: 5308:		    skip_option = TRUE;
    #####: 5309:		    break;
        -: 5310:#if USE_RC
    #####: 5311:		  case 'r':
        -: 5312:		  case 'v':
        -: 5313:		    /*
        -: 5314:		       If the define_global_text_variable option `-r<def:def...>'
        -: 5315:		       or the define_global_date_variable option `-v<def:def...>'
        -: 5316:		       is given, skip/ignore that option because it's already
        -: 5317:		       managed by the `main()' function.  Only check if NO
        -: 5318:		       definitions are given because this is an error!
        -: 5319:		     */
    #####: 5320:		    option++;
    #####: 5321:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5322:		      /*
        -: 5323:		         Error, option character is not trailed by an argument.
        -: 5324:		       */
    #####: 5325:		      opt_error = 4;
    #####: 5326:		    skip_option = TRUE;
    #####: 5327:		    break;
    #####: 5328:		  case 'f':
        -: 5329:		  case 'F':
    #####: 5330:		    if (isupper (*option))
branch  0 never executed
branch  1 never executed
    #####: 5331:		      rc_all_dates_flag = TRUE;
    #####: 5332:		    option++;
    #####: 5333:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5334:		      /*
        -: 5335:		         Error, option character is not trailed by an argument.
        -: 5336:		       */
    #####: 5337:		      opt_error = 4;
        -: 5338:		    else
        -: 5339:		      {
    #####: 5340:			len = (int) strlen (option);
        -: 5341:			/*
        -: 5342:			   Check if a file name argument with a leading
        -: 5343:			   CONNECT_SEP like '+foo' is given.
        -: 5344:			 */
    #####: 5345:			if (*option == *CONNECT_SEP)
branch  0 never executed
branch  1 never executed
        -: 5346:			  /*
        -: 5347:			     Error, option character is trailed
        -: 5348:			     by an invalid argument.
        -: 5349:			   */
    #####: 5350:			  opt_error = 5;
        -: 5351:			else
        -: 5352:			  {
    #####: 5353:			    if (len > 1)
branch  0 never executed
branch  1 never executed
        -: 5354:			      {
        -: 5355:				/*
        -: 5356:				   Check if a file name argument with a trailing
        -: 5357:				   CONNECT_SEP like 'foo+' is given.
        -: 5358:				 */
    #####: 5359:				if ((*(option + (len - 1)) == *CONNECT_SEP)
branch  0 never executed
branch  1 never executed
    #####: 5360:				    && (*(option + (len - 2)) != QUOTE_CHAR))
branch  0 never executed
branch  1 never executed
        -: 5361:				  /*
        -: 5362:				     Error, option character is trailed
        -: 5363:				     by an invalid argument.
        -: 5364:				   */
    #####: 5365:				  opt_error = 5;
        -: 5366:				else
        -: 5367:				  {
        -: 5368:				    /*
        -: 5369:				       Check if a file name list argument containing
        -: 5370:				       attached unquoted CONNECT_SEP like
        -: 5371:				       'foo+bar+++file' is given.
        -: 5372:				     */
    #####: 5373:				    ptr_char = strchr (option, *CONNECT_SEP);
    #####: 5374:				    if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 5375:				      {
    #####: 5376:					ptr_char--;
    #####: 5377:					if (*ptr_char == QUOTE_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 5378:					  ptr_char++;
    #####: 5379:					ptr_char++;
    #####: 5380:					while (*ptr_char && !opt_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5381:					  {
    #####: 5382:					    if (*ptr_char == QUOTE_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 5383:					      ptr_char++;
        -: 5384:					    else
    #####: 5385:					      if (*ptr_char == *CONNECT_SEP)
branch  0 never executed
branch  1 never executed
        -: 5386:					      {
    #####: 5387:						ptr_char++;
    #####: 5388:						if (*ptr_char == QUOTE_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 5389:						  ptr_char++;
        -: 5390:						else
    #####: 5391:						  if (*ptr_char ==
branch  0 never executed
branch  1 never executed
    #####: 5392:						      *CONNECT_SEP)
        -: 5393:						  /*
        -: 5394:						     Error, option character is trailed
        -: 5395:						     by an invalid argument.
        -: 5396:						   */
    #####: 5397:						  opt_error = 5;
        -: 5398:					      }
    #####: 5399:					    if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 5400:					      ptr_char++;
        -: 5401:					  }
        -: 5402:				      }
        -: 5403:				  }
        -: 5404:			      }
    #####: 5405:			    if (!opt_error)
branch  0 never executed
branch  1 never executed
        -: 5406:			      {
    #####: 5407:				if (rc_filename == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 5408:				  rc_filename = (char *) my_malloc (len + 1,
call    0 never executed
        -: 5409:								    ERR_NO_MEMORY_AVAILABLE,
        -: 5410:								    __FILE__,
        -: 5411:								    ((long)
        -: 5412:								     __LINE__)
        -: 5413:								    - 2L,
        -: 5414:								    "rc_filename",
        -: 5415:								    0);
        -: 5416:				else
    #####: 5417:				  rc_filename =
    #####: 5418:				    (char *) my_realloc ((VOID_PTR)
call    0 never executed
        -: 5419:							 rc_filename, len + 1,
        -: 5420:							 ERR_NO_MEMORY_AVAILABLE,
        -: 5421:							 __FILE__,
        -: 5422:							 ((long) __LINE__) -
        -: 5423:							 3L, "rc_filename",
        -: 5424:							 0);
    #####: 5425:				strcpy (rc_filename, option);
    #####: 5426:				skip_option = rc_use_flag = TRUE;
        -: 5427:			      }
        -: 5428:			  }
        -: 5429:		      }
    #####: 5430:		    break;
        8: 5431:		  case '#':
        8: 5432:		    option++;
        8: 5433:		    if (!*option)
branch  0 taken 63% (fallthrough)
branch  1 taken 38%
        -: 5434:		      /*
        -: 5435:		         Error, option character is not trailed by an argument.
        -: 5436:		       */
        5: 5437:		      opt_error = 4;
        -: 5438:		    else
        -: 5439:		      {
        -: 5440:			/*
        -: 5441:			   If the first `-# ARG' resp., `--here=ARG' option
        -: 5442:			   is found, create and open a temporary file for
        -: 5443:			   storing it.
        -: 5444:			 */
        3: 5445:			if (rc_here_fn == (char *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 5446:			  {
        3: 5447:			    ptr_char = TMPFILENAME;
call    0 returned 100%
        3: 5448:			    if (ptr_char == (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5449:			      my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 5450:					((long) __LINE__) - 2L, "tmpnam()=",
        -: 5451:					0);
        3: 5452:			    rc_here_fn =
        3: 5453:			      (char *) my_malloc (strlen (ptr_char) + 1,
call    0 returned 100%
        -: 5454:						  ERR_NO_MEMORY_AVAILABLE,
        -: 5455:						  __FILE__,
        -: 5456:						  ((long) __LINE__) - 2L,
        -: 5457:						  "rc_here_fn", 0);
        3: 5458:			    strcpy (rc_here_fn, ptr_char);
        3: 5459:			    rc_here_fp = fopen (rc_here_fn, "w");
call    0 returned 100%
        3: 5460:			    if (rc_here_fp == (FILE *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5461:			      my_error (ERR_WRITE_FILE, __FILE__,
call    0 never executed
        -: 5462:					((long) __LINE__) - 2L, rc_here_fn,
        -: 5463:					0);
        -: 5464:			  }
        -: 5465:			/*
        -: 5466:			   Copy this long-style option into a buffer.
        -: 5467:			 */
        3: 5468:			len = (int) strlen (option);
        3: 5469:			if ((Uint) len >= maxlen_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5470:			  resize_all_strings (len + 1, FALSE, __FILE__,
call    0 never executed
        -: 5471:					      (long) __LINE__);
        3: 5472:			strcpy (s2, option);
        3: 5473:			pseudo_blank_conversion (&s2);
call    0 returned 100%
        -: 5474:			/*
        -: 5475:			   And write the option argument into the temporary file.
        -: 5476:			 */
        3: 5477:			i = fprintf (rc_here_fp, "%s\n", s2);
call    0 returned 100%
        3: 5478:			if (i == EOF)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5479:			  my_error (ERR_WRITE_FILE, __FILE__,
call    0 never executed
        -: 5480:				    ((long) __LINE__) - 2L, rc_here_fn, 0);
        -: 5481:		      }
        8: 5482:		    skip_option = rc_use_flag = TRUE;
        8: 5483:		    break;
    #####: 5484:		  case 'D':
    #####: 5485:		    option++;
    #####: 5486:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5487:		      /*
        -: 5488:		         Error, option character is not trailed by an argument.
        -: 5489:		       */
    #####: 5490:		      opt_error = 4;
        -: 5491:		    else
        -: 5492:		      {
        -: 5493:			/*
        -: 5494:			   Check for %? special_texts (without the leading
        -: 5495:			   `%' character) that disable a fixed date.
        -: 5496:			 */
    #####: 5497:			ptr_char = option;
    #####: 5498:			while (*ptr_char && !opt_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5499:			  if (*ptr_char == RC_EX_LHDY_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5500:			      || *ptr_char == RC_EX_NLHDY_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5501:			      || *ptr_char == RC_EX_AHDY_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5502:			      || *ptr_char == RC_EX_NAHDY_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5503:			      || *ptr_char == RC_EX_MON_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5504:			      || *ptr_char == RC_EX_NMON_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5505:			      || *ptr_char == RC_EX_TUE_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5506:			      || *ptr_char == RC_EX_NTUE_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5507:			      || *ptr_char == RC_EX_WED_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5508:			      || *ptr_char == RC_EX_NWED_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5509:			      || *ptr_char == RC_EX_THU_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5510:			      || *ptr_char == RC_EX_NTHU_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5511:			      || *ptr_char == RC_EX_FRI_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5512:			      || *ptr_char == RC_EX_NFRI_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5513:			      || *ptr_char == RC_EX_SAT_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5514:			      || *ptr_char == RC_EX_NSAT_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5515:			      || *ptr_char == RC_EX_SUN_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5516:			      || *ptr_char == RC_EX_NSUN_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5517:			      || *ptr_char == RC_EX_MON_2_THU_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5518:			      || *ptr_char == RC_EX_NMON_2_THU_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5519:			      || *ptr_char == RC_EX_MON_2_FRI_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5520:			      || *ptr_char == RC_EX_NMON_2_FRI_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 5521:			    ptr_char++;
        -: 5522:			  else
        -: 5523:			    /*
        -: 5524:			       Error, invalid %? special text character given.
        -: 5525:			     */
    #####: 5526:			    opt_error = 5;
    #####: 5527:			if (!opt_error)
branch  0 never executed
branch  1 never executed
        -: 5528:			  {
    #####: 5529:			    if (rc_filter_day == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 5530:			      rc_filter_day =
    #####: 5531:				(char *) my_malloc (strlen (option) + 1,
call    0 never executed
        -: 5532:						    ERR_NO_MEMORY_AVAILABLE,
        -: 5533:						    __FILE__,
        -: 5534:						    ((long) __LINE__) - 2L,
        -: 5535:						    "rc_filter_day", 0);
        -: 5536:			    else
    #####: 5537:			      rc_filter_day =
    #####: 5538:				(char *) my_realloc ((VOID_PTR) rc_filter_day,
call    0 never executed
    #####: 5539:						     strlen (option) + 1,
        -: 5540:						     ERR_NO_MEMORY_AVAILABLE,
        -: 5541:						     __FILE__,
        -: 5542:						     ((long) __LINE__) - 3L,
        -: 5543:						     "rc_filter_day", 0);
    #####: 5544:			    strcpy (rc_filter_day, option);
        -: 5545:			  }
        -: 5546:		      }
    #####: 5547:		    skip_option = TRUE;
    #####: 5548:		    break;
    #####: 5549:		  case 'P':
    #####: 5550:		    option++;
    #####: 5551:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5552:		      /*
        -: 5553:		         Error, option character is not trailed by an argument.
        -: 5554:		       */
    #####: 5555:		      opt_error = 4;
        -: 5556:		    else
        -: 5557:		      {
        -: 5558:			/*
        -: 5559:			   Check for %?[DATE][#[DATE]] special_texts (without the
        -: 5560:			   leading `%' character) that disable a fixed date.
        -: 5561:			   If more than one special text is specified, it must
        -: 5562:			   be separated by a SPLIT_SEP.
        -: 5563:			 */
    #####: 5564:			ptr_char = option;
    #####: 5565:			while (*ptr_char && !opt_error)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5566:			  if (*ptr_char == RC_IDATE_CHAR
branch  0 never executed
branch  1 never executed
    #####: 5567:			      || *ptr_char == RC_EDATE_CHAR)
branch  0 never executed
branch  1 never executed
        -: 5568:			    {
    #####: 5569:			      ptr_char++;
    #####: 5570:			      while (*ptr_char && (*ptr_char != *SPLIT_SEP))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 5571:				ptr_char++;
    #####: 5572:			      if (!*ptr_char || *ptr_char == *SPLIT_SEP)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5573:				{
    #####: 5574:				  if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 5575:				    ptr_char++;
        -: 5576:				}
        -: 5577:			      else
        -: 5578:				/*
        -: 5579:				   Error, invalid %?[DATE][#[DATE]]
        -: 5580:				   special text given.
        -: 5581:				 */
    #####: 5582:				opt_error = 5;
        -: 5583:			    }
        -: 5584:			  else
        -: 5585:			    /*
        -: 5586:			       Error, invalid %?[DATE][#[DATE]]
        -: 5587:			       special text given.
        -: 5588:			     */
    #####: 5589:			    opt_error = 5;
    #####: 5590:			if (!opt_error)
branch  0 never executed
branch  1 never executed
        -: 5591:			  {
    #####: 5592:			    if (rc_filter_period == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 5593:			      rc_filter_period =
    #####: 5594:				(char *) my_malloc (strlen (option) + 1,
call    0 never executed
        -: 5595:						    ERR_NO_MEMORY_AVAILABLE,
        -: 5596:						    __FILE__,
        -: 5597:						    ((long) __LINE__) - 2L,
        -: 5598:						    "rc_filter_period", 0);
        -: 5599:			    else
    #####: 5600:			      rc_filter_period =
    #####: 5601:				(char *) my_realloc ((VOID_PTR)
call    0 never executed
        -: 5602:						     rc_filter_period,
    #####: 5603:						     strlen (option) + 1,
        -: 5604:						     ERR_NO_MEMORY_AVAILABLE,
        -: 5605:						     __FILE__,
        -: 5606:						     ((long) __LINE__) - 3L,
        -: 5607:						     "rc_filter_period", 0);
    #####: 5608:			    strcpy (rc_filter_period, option);
        -: 5609:			  }
        -: 5610:		      }
    #####: 5611:		    skip_option = TRUE;
    #####: 5612:		    break;
    #####: 5613:		  case 'I':
    #####: 5614:		    option++;
    #####: 5615:		    if (!*option)
branch  0 never executed
branch  1 never executed
        -: 5616:		      /*
        -: 5617:		         Error, option character is not trailed by an argument.
        -: 5618:		       */
    #####: 5619:		      opt_error = 4;
        -: 5620:		    else
        -: 5621:		      {
    #####: 5622:			if (rc_filter_text == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 5623:			  rc_filter_text =
    #####: 5624:			    (char *) my_malloc (strlen (option) + 1,
call    0 never executed
        -: 5625:						ERR_NO_MEMORY_AVAILABLE,
        -: 5626:						__FILE__,
        -: 5627:						((long) __LINE__) - 2L,
        -: 5628:						"rc_filter_text", 0);
        -: 5629:			else
    #####: 5630:			  rc_filter_text =
    #####: 5631:			    (char *) my_realloc ((VOID_PTR) rc_filter_text,
call    0 never executed
    #####: 5632:						 strlen (option) + 1,
        -: 5633:						 ERR_NO_MEMORY_AVAILABLE,
        -: 5634:						 __FILE__,
        -: 5635:						 ((long) __LINE__) - 3L,
        -: 5636:						 "rc_filter_text", 0);
    #####: 5637:			strcpy (rc_filter_text, option);
        -: 5638:		      }
    #####: 5639:		    skip_option = TRUE;
    #####: 5640:		    break;
    #####: 5641:		  case 'g':
    #####: 5642:		    option++;
    #####: 5643:		    if (*option)
branch  0 never executed
branch  1 never executed
        -: 5644:		      {
    #####: 5645:			if (rc_grp_sep == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 5646:			  rc_grp_sep =
    #####: 5647:			    (char *) my_malloc (strlen (option) + 1 + 2,
call    0 never executed
        -: 5648:						ERR_NO_MEMORY_AVAILABLE,
        -: 5649:						__FILE__,
        -: 5650:						((long) __LINE__) - 2L,
        -: 5651:						"rc_grp_sep", 0);
        -: 5652:			else
    #####: 5653:			  rc_grp_sep =
    #####: 5654:			    (char *) my_realloc ((VOID_PTR) rc_grp_sep,
call    0 never executed
    #####: 5655:						 strlen (option) + 1 + 2,
        -: 5656:						 ERR_NO_MEMORY_AVAILABLE,
        -: 5657:						 __FILE__,
        -: 5658:						 ((long) __LINE__) - 3L,
        -: 5659:						 "rc_grp_sep", 0);
    #####: 5660:			strcpy (rc_grp_sep, "0 ");
    #####: 5661:			strcat (rc_grp_sep, option);
    #####: 5662:			pseudo_blank_conversion (&rc_grp_sep);
call    0 never executed
        -: 5663:		      }
        -: 5664:		    else
        -: 5665:		      {
    #####: 5666:			if (rc_grp_sep == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 5667:			  rc_grp_sep =
    #####: 5668:			    (char *) my_malloc (strlen (RC_GROUP_SEP) + 1 + 2,
call    0 never executed
        -: 5669:						ERR_NO_MEMORY_AVAILABLE,
        -: 5670:						__FILE__,
        -: 5671:						((long) __LINE__) - 2L,
        -: 5672:						"rc_grp_sep", 0);
        -: 5673:			else
    #####: 5674:			  rc_grp_sep =
    #####: 5675:			    (char *) my_realloc ((VOID_PTR) rc_grp_sep,
call    0 never executed
        -: 5676:						 strlen (RC_GROUP_SEP) + 1 +
        -: 5677:						 2, ERR_NO_MEMORY_AVAILABLE,
        -: 5678:						 __FILE__,
        -: 5679:						 ((long) __LINE__) - 3L,
        -: 5680:						 "rc_grp_sep", 0);
    #####: 5681:			strcpy (rc_grp_sep, "0 ");
    #####: 5682:			strcat (rc_grp_sep, RC_GROUP_SEP);
        -: 5683:		      }
    #####: 5684:		    skip_option = TRUE;
    #####: 5685:		    break;
    #####: 5686:		  case 'a':
    #####: 5687:		    rc_enable_fn_flag = TRUE;
    #####: 5688:		    break;
    #####: 5689:		  case 'A':
    #####: 5690:		    rc_alternative_format_flag = TRUE;
    #####: 5691:		    break;
    #####: 5692:		  case 'd':
    #####: 5693:		    rc_have_today_in_list = 1;
    #####: 5694:		    break;
    #####: 5695:		  case 'e':
        -: 5696:		  case 'E':
    #####: 5697:		    if (isupper (*option))
branch  0 never executed
branch  1 never executed
        -: 5698:		      {
    #####: 5699:			rc_enable_hdl_flag = TRUE;
    #####: 5700:			rc_enable_hda_flag = FALSE;
        -: 5701:		      }
        -: 5702:		    else
        -: 5703:		      {
    #####: 5704:			rc_enable_hdl_flag = FALSE;
    #####: 5705:			rc_enable_hda_flag = TRUE;
        -: 5706:		      }
    #####: 5707:		    break;
    #####: 5708:		  case 'o':
    #####: 5709:		    rc_omit_date_flag = TRUE;
    #####: 5710:		    break;
    #####: 5711:		  case 'l':
        -: 5712:		    /*
        -: 5713:		       Assume the user wants to have a list
        -: 5714:		       of periods instead of a single period!
        -: 5715:		     */
    #####: 5716:		    rc_period_list = TRUE;
    #####: 5717:		    break;
    #####: 5718:		  case 'k':
    #####: 5719:		    rc_week_number_flag = TRUE;
    #####: 5720:		    break;
    #####: 5721:		  case 'U':
    #####: 5722:		    rc_suppr_date_part_flag = TRUE;
    #####: 5723:		    break;
    #####: 5724:		  case 'Q':
    #####: 5725:		    rc_suppr_list_sep_flag = TRUE;
    #####: 5726:		    break;
    #####: 5727:		  case 'J':
    #####: 5728:		    rc_suppr_text_part_flag = TRUE;
    #####: 5729:		    break;
    #####: 5730:		  case 'x':
    #####: 5731:		    rc_title_flag = FALSE;
    #####: 5732:		    break;
    #####: 5733:		  case 'z':
    #####: 5734:		    rc_count_flag = TRUE;
    #####: 5735:		    break;
    #####: 5736:		  case 'Z':
    #####: 5737:		    rc_zero_dates_flag = TRUE;
    #####: 5738:		    break;
    #####: 5739:		  case 'c':
        -: 5740:		  case 'C':
    #####: 5741:		    rc_use_flag = TRUE;
    #####: 5742:		    if (isupper (*option))
branch  0 never executed
branch  1 never executed
    #####: 5743:		      rc_all_dates_flag = TRUE;
    #####: 5744:		    option++;
    #####: 5745:		    if (*option == *DES_LIT)
branch  0 never executed
branch  1 never executed
        -: 5746:		      {
    #####: 5747:			rc_sort_des_flag = TRUE;
    #####: 5748:			while (*option == *DES_LIT)
branch  0 never executed
branch  1 never executed
    #####: 5749:			  option++;
        -: 5750:		      }
    #####: 5751:		    option--;
    #####: 5752:		    break;
    #####: 5753:		  case '0':
        -: 5754:		  case '1':
        -: 5755:		  case '2':
        -: 5756:		  case '3':
        -: 5757:		  case '4':
        -: 5758:		  case '5':
        -: 5759:		  case '6':
        -: 5760:		  case '7':
        -: 5761:		  case '8':
        -: 5762:		  case '9':
        -: 5763:		  case RC_HDY_CHAR:
        -: 5764:		  case RC_NWD_CHAR:
    #####: 5765:		    skip_option = rc_period_flag = TRUE;
        -: 5766:		    /*
        -: 5767:		       Store some actual values now by reason this part
        -: 5768:		       is managed at a later place in the sequence,
        -: 5769:		       and it is necessary to restore them there.
        -: 5770:		     */
    #####: 5771:		    if (rc_period_argv == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 5772:		      rc_period_argv = (char *) my_malloc (strlen (*argv) + 1,
call    0 never executed
        -: 5773:							   ERR_NO_MEMORY_AVAILABLE,
        -: 5774:							   __FILE__,
        -: 5775:							   ((long) __LINE__) -
        -: 5776:							   2L,
        -: 5777:							   "rc_period_argv",
        -: 5778:							   0);
        -: 5779:		    else
    #####: 5780:		      rc_period_argv =
call    0 never executed
    #####: 5781:			(char *) my_realloc ((VOID_PTR) rc_period_argv,
    #####: 5782:					     strlen (*argv) + 1,
        -: 5783:					     ERR_NO_MEMORY_AVAILABLE,
        -: 5784:					     __FILE__, ((long) __LINE__) - 3L,
        -: 5785:					     "rc_period_argv", 0);
    #####: 5786:		    strcpy (rc_period_argv, *argv);
    #####: 5787:		    if (rc_period_option == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 5788:		      rc_period_option =
call    0 never executed
    #####: 5789:			(char *) my_malloc (strlen (option) + 1,
        -: 5790:					    ERR_NO_MEMORY_AVAILABLE, __FILE__,
        -: 5791:					    ((long) __LINE__) - 2L,
        -: 5792:					    "rc_period_option", 0);
        -: 5793:		    else
    #####: 5794:		      rc_period_option =
call    0 never executed
    #####: 5795:			(char *) my_realloc ((VOID_PTR) rc_period_option,
    #####: 5796:					     strlen (option) + 1,
        -: 5797:					     ERR_NO_MEMORY_AVAILABLE,
        -: 5798:					     __FILE__, ((long) __LINE__) - 3L,
        -: 5799:					     "rc_period_option", 0);
    #####: 5800:		    strcpy (rc_period_option, option);
    #####: 5801:		    rc_period_is_longopt = is_longopt;
    #####: 5802:		    break;
    #####: 5803:		  case 't':
        -: 5804:		  case 'T':
    #####: 5805:		    rc_clean_flags ();
call    0 never executed
    #####: 5806:		    skip_option = rc_use_flag = rc_tomorrow_flag = TRUE;
    #####: 5807:		    if (isupper (*option))
branch  0 never executed
branch  1 never executed
    #####: 5808:		      rc_all_dates_flag = TRUE;
    #####: 5809:		    option++;
    #####: 5810:		    if (*option)
branch  0 never executed
branch  1 never executed
        -: 5811:		      /*
        -: 5812:		         Error, invalid option modifier given.
        -: 5813:		       */
    #####: 5814:		      opt_error = 5;
    #####: 5815:		    break;
    #####: 5816:		  case 'w':
        -: 5817:		  case 'W':
        -: 5818:		  case 'm':
        -: 5819:		  case 'M':
        -: 5820:		  case 'y':
        -: 5821:		  case 'Y':
    #####: 5822:		    rc_clean_flags ();
call    0 never executed
    #####: 5823:		    switch (*option)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 5824:		      {
    #####: 5825:		      case 'w':
        -: 5826:		      case 'W':
    #####: 5827:			rc_week_flag = TRUE;
    #####: 5828:			break;
    #####: 5829:		      case 'm':
        -: 5830:		      case 'M':
    #####: 5831:			rc_month_flag = TRUE;
    #####: 5832:			break;
    #####: 5833:		      default:
    #####: 5834:			rc_year_flag = TRUE;
        -: 5835:		      }
    #####: 5836:		    skip_option = rc_use_flag = TRUE;
    #####: 5837:		    if (isupper (*option))
branch  0 never executed
branch  1 never executed
    #####: 5838:		      rc_all_dates_flag = TRUE;
    #####: 5839:		    opt_error = further_check (&option);
call    0 never executed
    #####: 5840:		    break;
        -: 5841:#endif /* USE_RC */
        3: 5842:		  default:
        -: 5843:		    /*
        -: 5844:		       Error, any unmanaged options are always invalid.
        -: 5845:		     */
        3: 5846:		    if (is_longopt)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5847:		      opt_error = 5;
        -: 5848:		    else
        3: 5849:		      opt_error = 2;
        -: 5850:		  }
       18: 5851:	      if (opt_error)
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -: 5852:		{
       15: 5853:		  ptr_char = *argv;
        -: 5854:#if USE_RC
       15: 5855:		LABEL_option_error:
        -: 5856:#endif
        -: 5857:		  /*
        -: 5858:		     Remove leading switch characters of the given option
        -: 5859:		     in some cases.
        -: 5860:		   */
       15: 5861:		  if (!is_longopt)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
       23: 5862:		    while (*ptr_char == *SWITCH)
branch  0 taken 23%
branch  1 taken 77% (fallthrough)
        3: 5863:		      ptr_char++;
       15: 5864:		  if (*ptr_char == *SWITCH2)
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        7: 5865:		    if (*(ptr_char + 1) != *SWITCH2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7: 5866:		      ptr_char++;
        -: 5867:		  /*
        -: 5868:		     Allocate proper string space for the option error text.
        -: 5869:		   */
       15: 5870:		  switch (opt_error)
branch  0 taken 100%
branch  1 taken 0%
        -: 5871:		    {
       15: 5872:		    case 1:
        -: 5873:		    case 2:
        -: 5874:		    case 3:
        -: 5875:		    case 4:
        -: 5876:		    case 5:
        -: 5877:		    case 6:
       15: 5878:		      if (is_longopt && (opt_error == 3))
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 5879:			len = (int) strlen (option) + LEN_SINGLE_LINE;
        -: 5880:		      else
       15: 5881:			len = (int) strlen (ptr_char) + LEN_SINGLE_LINE;
       15: 5882:		      if ((Uint) len >= maxlen_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5883:			resize_all_strings (len + 1, FALSE, __FILE__,
call    0 never executed
        -: 5884:					    (long) __LINE__);
       15: 5885:		      break;
       15: 5886:		    default:
        -: 5887:		      ;		/* Void, nothing to do now */
        -: 5888:		    }
        -: 5889:		  /*
        -: 5890:		     Construct the option error text.
        -: 5891:		   */
       15: 5892:		  switch (opt_error)
branch  0 taken 13%
branch  1 taken 40%
branch  2 taken 0%
branch  3 taken 33%
branch  4 taken 13%
branch  5 taken 0%
branch  6 taken 0%
        -: 5893:		    {
        2: 5894:		    case 1:
        2: 5895:		      sprintf (s1, _("%s: option `%s' is ambiguous"),
        -: 5896:			       prgr_name, ptr_char);
        2: 5897:		      break;
        6: 5898:		    case 2:
        6: 5899:		      if (is_longopt)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        3: 5900:			sprintf (s1, _("%s: unrecognized option `%s'"),
        -: 5901:				 prgr_name, ptr_char);
        -: 5902:		      else
        3: 5903:			sprintf (s1, _("%s: invalid option -- %s"),
        -: 5904:				 prgr_name, ptr_char);
        6: 5905:		      break;
    #####: 5906:		    case 3:
    #####: 5907:		      if (is_longopt)
branch  0 never executed
branch  1 never executed
    #####: 5908:			sprintf (s1,
        -: 5909:				 _
        -: 5910:				 ("%s: option `--%s' doesn't allow an argument"),
        -: 5911:				 prgr_name, option);
        -: 5912:		      else
    #####: 5913:			sprintf (s1,
        -: 5914:				 _
        -: 5915:				 ("%s: option `%s' doesn't allow an argument"),
        -: 5916:				 prgr_name, ptr_char);
    #####: 5917:		      break;
        5: 5918:		    case 4:
        5: 5919:		      if (is_longopt)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 5920:			sprintf (s1,
        -: 5921:				 _("%s: option `%s' requires an argument"),
        -: 5922:				 prgr_name, ptr_char);
        -: 5923:		      else
        5: 5924:			sprintf (s1,
        -: 5925:				 _("%s: option requires an argument -- %s"),
        -: 5926:				 prgr_name, ptr_char);
        5: 5927:		      break;
        2: 5928:		    case 5:
        2: 5929:		      sprintf (s1,
        -: 5930:			       _("%s: option with invalid argument -- %s"),
        -: 5931:			       prgr_name, ptr_char);
        2: 5932:		      break;
    #####: 5933:		    case 6:
    #####: 5934:		      sprintf (s1,
        -: 5935:			       _("%s: option with ambiguous argument -- %s"),
        -: 5936:			       prgr_name, ptr_char);
    #####: 5937:		      break;
    #####: 5938:		    default:
        -: 5939:		      /*
        -: 5940:		         This case must be an internal error
        -: 5941:		       */
    #####: 5942:		      my_error (opt_error, __FILE__, ((long) __LINE__) - 4L,
call    0 never executed
        -: 5943:				"", 0);
        -: 5944:		    }
        -: 5945:		  /*
        -: 5946:		     Display the option error text and exit with error.
        -: 5947:		   */
       15: 5948:		  fprintf (stderr, "%s\n%s\n%s\n", s1, usage_msg (),
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -: 5949:			   lopt_msg ());
       15: 5950:		  my_exit (ERR_INVALID_OPTION);
call    0 returned 0%
        -: 5951:		}
        3: 5952:	      if (skip_option)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 5953:		{
        9: 5954:		  while (*option)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        3: 5955:		    option++;
        3: 5956:		  option--;
        -: 5957:		}
        -: 5958:	    }
        3: 5959:	  argc--;
        -: 5960:	}
        -: 5961:      else
        -: 5962:	{
        -: 5963:#if USE_RC
       28: 5964:	  if (**argv == RC_ADATE_CHAR)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 5965:	    /*
        -: 5966:	       If an actual date modifier %DATE is given, skip/ignore this
        -: 5967:	       option, because we evaluate it some lines later.
        -: 5968:	     */
    #####: 5969:	    argc--;
        -: 5970:	  else
        -: 5971:#endif /* USE_RC */
       28: 5972:	  if (**argv == RSP_CHAR)
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        -: 5973:	    /*
        -: 5974:	       If a response file @FILE is given, skip/ignore this
        -: 5975:	       option, because we don't manage nested response files!
        -: 5976:	     */
        2: 5977:	    argc--;
        -: 5978:	  else
        -: 5979:	    /*
        -: 5980:	       If a command is given, skip processing the options.
        -: 5981:	     */
       26: 5982:	    break;
        -: 5983:	}
        -: 5984:    }
        -: 5985:#if USE_RC
        -: 5986:  /*
        -: 5987:     Read the internal system date an evaluate
        -: 5988:     a possibly given actual date modifier %DATE.
        -: 5989:   */
       74: 5990:  if (!get_actual_date ())
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -: 5991:    {
        -: 5992:      /*
        -: 5993:         Error, invalid actual date modifier %DATE given.
        -: 5994:       */
    #####: 5995:      fprintf (stderr, _("%s: invalid date given -- %c%s\n%s\n%s\n"),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 5996:	       prgr_name, RC_ADATE_CHAR, rc_adate, usage_msg (), lopt_msg ());
    #####: 5997:      my_exit (ERR_INVALID_OPTION);
call    0 never executed
        -: 5998:    }
        -: 5999:#else /* !USE_RC */
        -: 6000:  /*
        -: 6001:     Read the actual system date and time that is reported by the operating system.
        -: 6002:   */
        -: 6003:  (void) get_actual_date ();
        -: 6004:#endif /* !USE_RC */
       74: 6005:  is_leap_year = (days_of_february (act_year) == 29);
call    0 returned 100%
        -: 6006:  /*
        -: 6007:     Set the starting day of week if it is not set by a command line argument.
        -: 6008:   */
       74: 6009:  buf_start_day = start_day;
       74: 6010:  if (start_day == SPECIAL_VALUE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6011:    /*
        -: 6012:       Set starting day of week to actual weekday.
        -: 6013:     */
    #####: 6014:    start_day = weekday_of_date (act_day, act_month, act_year);
call    0 never executed
       74: 6015:  else if (!start_day)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 6016:    {
        -: 6017:      /*
        -: 6018:         Set starting day of week to language/territory default value.
        -: 6019:       */
        -: 6020:#if defined GCAL_NLS
        -: 6021:# if HAVE__NL_TIME_FIRST_WEEKDAY
       74: 6022:      start_day = (nl_langinfo (_NL_TIME_FIRST_WEEKDAY)[0] + 5) % 7 + 1;
call    0 returned 100%
        -: 6023:# else
        -: 6024:      start_day = DAY_MAX;
        -: 6025:# endif
        -: 6026:#else /* !GCAL_NLS */
        -: 6027:#error MUST USE _NL_TIME_FIRST_WEEKDAY !
        -: 6028:      start_day = DAY_MAX;
        -: 6029:#endif	/* !GCAL_NLS */
        -: 6030:    }
        -: 6031:  /*
        -: 6032:     Post-process a time offset argument, which is based relative to
        -: 6033:     the actual time ('t' | '@' found), of the `--time-offset' option NOW.
        -: 6034:   */
       74: 6035:  if (rel_time_offset)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6036:    {
    #####: 6037:      if (!time_hour_offset && !time_min_offset)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6038:	{
        -: 6039:#if USE_RC
    #####: 6040:	  if (rel_time_offset == RC_GMTIME_CHAR)
branch  0 never executed
branch  1 never executed
        -: 6041:	    {
    #####: 6042:	      time_hour_offset = gmt_hour;
    #####: 6043:	      time_min_offset = gmt_min;
        -: 6044:	    }
        -: 6045:	  else
        -: 6046:#endif
        -: 6047:	    {
    #####: 6048:	      time_hour_offset = act_hour;
    #####: 6049:	      time_min_offset = act_min;
        -: 6050:	    }
        -: 6051:	}
        -: 6052:      else
        -: 6053:	{
        -: 6054:#if USE_RC
    #####: 6055:	  if (rel_time_offset == RC_GMTIME_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 6056:	    i =
    #####: 6057:	      HHMM2MM (gmt_hour, gmt_min) + HHMM2MM (time_hour_offset,
        -: 6058:						     time_min_offset);
        -: 6059:	  else
        -: 6060:#endif
    #####: 6061:	    i =
    #####: 6062:	      HHMM2MM (act_hour, act_min) + HHMM2MM (time_hour_offset,
        -: 6063:						     time_min_offset);
    #####: 6064:	  time_hour_offset = MM2HH (abs (i));
branch  0 never executed
branch  1 never executed
    #####: 6065:	  time_min_offset = abs (i) % MINS_PER_HOUR;
    #####: 6066:	  if (i < 0)
branch  0 never executed
branch  1 never executed
        -: 6067:	    {
    #####: 6068:	      time_hour_offset = -time_hour_offset;
    #####: 6069:	      time_min_offset = -time_min_offset;
        -: 6070:	    }
        -: 6071:	}
        -: 6072:    }
        -: 6073:#if USE_RC
       74: 6074:  time_offset = HHMM2DAY (time_hour_offset, time_min_offset);
        -: 6075:  /*
        -: 6076:     Post-process a cycle-ending time argument, which is based relative to
        -: 6077:     the actual time ('t' | '@' found), of the `--cycle-end' option NOW.
        -: 6078:   */
       74: 6079:  if (rel_loop_end)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6080:    {
    #####: 6081:      if (rel_loop_end == RC_GMTIME_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 6082:	i = HHMM2MM (gmt_hour, gmt_min);
        -: 6083:      else
    #####: 6084:	i = HHMM2MM (act_hour, act_min);
    #####: 6085:      if (!set_loop_end && (loop_end == SPECIAL_VALUE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6086:	loop_end = i;
        -: 6087:      else
    #####: 6088:	loop_end = i + loop_end;
    #####: 6089:      set_loop_end = TRUE;
        -: 6090:    }
       74: 6091:  if (set_loop_end)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6092:    {
        -: 6093:      /*
        -: 6094:         Reduce the given cycle-ending time value in minutes to a single day.
        -: 6095:       */
    #####: 6096:      if (loop_end < 0)
branch  0 never executed
branch  1 never executed
    #####: 6097:	loop_end = 0;
    #####: 6098:      else if (loop_end >= MINS_PER_DAY)
branch  0 never executed
branch  1 never executed
    #####: 6099:	loop_end = MINS_PER_DAY - 1;
        -: 6100:    }
        -: 6101:  /*
        -: 6102:     Post-check for arguments of the `--period-of-fixed-dates=ARG' option NOW.
        -: 6103:   */
       74: 6104:  if (rc_period_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6105:    {
    #####: 6106:      if (!rc_use_flag)
branch  0 never executed
branch  1 never executed
        -: 6107:	/*
        -: 6108:	   Error, use of fixed dates list neither implicitly nor explicitly
        -: 6109:	   specified (e.g., option like `-10' or `-*w10fr' given).
        -: 6110:	 */
    #####: 6111:	opt_error = 2;
        -: 6112:      else
        -: 6113:	{
    #####: 6114:	  register int act_is_leap_year = (days_of_february (act_year) == 29);
call    0 never executed
    #####: 6115:	  auto int wmax = WEEK_MAX;
    #####: 6116:	  auto char dvar = '\0';
    #####: 6117:	  auto Bool nth_day_of_year_flag = FALSE;
        -: 6118:
        -: 6119:
    #####: 6120:	  if (act_year == greg->year)
branch  0 never executed
branch  1 never executed
    #####: 6121:	    wmax = ((DAY_LAST + (days_of_february (greg->year) == 29)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 6122:		     - (greg->last_day - greg->first_day + 1)) / DAY_MAX) + 1;
    #####: 6123:	  rc_clean_flags ();
call    0 never executed
    #####: 6124:	  i = 0;
    #####: 6125:	  rc_period = 0;
    #####: 6126:	  rc_period_flag = TRUE;
    #####: 6127:	  option = rc_period_option;
        -: 6128:	  /*
        -: 6129:	     Before I forget... All mode specifying characters
        -: 6130:	     ('d' or 'w') may be given in upper or lower
        -: 6131:	     case letters, i.e. they are managed case insensitive!
        -: 6132:	   */
        -: 6133:	  /*
        -: 6134:	     Check if @e|t|DVAR[[-]N[WW[W]]] or *d|wN[WW[W]] is given.
        -: 6135:	   */
    #####: 6136:	  if (*option == RC_HDY_CHAR || *option == RC_NWD_CHAR)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6137:	    dvar = *option;
        -: 6138:	  else
        -: 6139:	    /*
        -: 6140:	       Compute the period for the Nd modifier.
        -: 6141:	     */
    #####: 6142:	    rc_period = atoi (option);
    #####: 6143:	  if (!dvar)
branch  0 never executed
branch  1 never executed
        -: 6144:	    {
        -: 6145:	      /*
        -: 6146:	         Check if a N+ modifier is given.
        -: 6147:	       */
    #####: 6148:	      rc_fwdf_buffer = rc_forwards_flag =
    #####: 6149:		(Bool) (strchr (option, *ASC_LIT) != (char *) NULL);
        -: 6150:	      /*
        -: 6151:	         Check if a N- modifier is given.
        -: 6152:	       */
    #####: 6153:	      rc_bwdf_buffer = rc_backwards_flag =
    #####: 6154:		(Bool) (strchr (option, *DES_LIT) != (char *) NULL);
        -: 6155:	      /*
        -: 6156:	         Check if a Nw modifier is given.
        -: 6157:	       */
    #####: 6158:	      ptr_char = strrchr (option, 'w');
    #####: 6159:	      if (ptr_char == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 6160:		ptr_char = strrchr (option, 'W');
    #####: 6161:	      if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 6162:		{
    #####: 6163:		  ptr_char++;
    #####: 6164:		  if (!*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 6165:		    rc_week_year_flag = TRUE;
        -: 6166:		}
        -: 6167:	      /*
        -: 6168:	         Check if a Nd modifier is given.
        -: 6169:	       */
    #####: 6170:	      ptr_char = strrchr (option, 'd');
    #####: 6171:	      if (ptr_char == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 6172:		ptr_char = strrchr (option, 'D');
    #####: 6173:	      if (ptr_char != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 6174:		{
    #####: 6175:		  ptr_char++;
    #####: 6176:		  if (!*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 6177:		    nth_day_of_year_flag = TRUE;
        -: 6178:		}
    #####: 6179:	      i = (int) rc_forwards_flag + rc_backwards_flag
    #####: 6180:		+ rc_week_year_flag + nth_day_of_year_flag;
        -: 6181:	    }
        -: 6182:	  /*
        -: 6183:	     Compute the period for a Nd modifier.
        -: 6184:	   */
    #####: 6185:	  if (rc_period == 999)
branch  0 never executed
branch  1 never executed
    #####: 6186:	    rc_period = DAY_LAST + act_is_leap_year;
    #####: 6187:	  if (!dvar
branch  0 never executed
branch  1 never executed
    #####: 6188:	      && (i > 1
branch  0 never executed
branch  1 never executed
    #####: 6189:		  || ((rc_period > DAY_LAST + act_is_leap_year)
branch  0 never executed
branch  1 never executed
    #####: 6190:		      && (rc_forwards_flag
branch  0 never executed
branch  1 never executed
    #####: 6191:			  || rc_backwards_flag
branch  0 never executed
branch  1 never executed
    #####: 6192:			  || nth_day_of_year_flag))
branch  0 never executed
branch  1 never executed
    #####: 6193:		  || (rc_week_year_flag
branch  0 never executed
branch  1 never executed
    #####: 6194:		      && (rc_period > wmax + 1) && (rc_period != 99))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6195:	    /*
        -: 6196:	       Error, illegal fixed date period modifier given.
        -: 6197:	     */
    #####: 6198:	    opt_error = 5;
        -: 6199:	  else
        -: 6200:	    {
        -: 6201:	      /*
        -: 6202:	         Found one of these fixed date period modifiers:
        -: 6203:	         @e|t|DVAR[[-]N[WW[W]]]
        -: 6204:	         *d|wN[WW[W]]
        -: 6205:	         MMDD
        -: 6206:	         MMWW[W]N
        -: 6207:	       */
    #####: 6208:	      if (!rc_week_year_flag
branch  0 never executed
branch  1 never executed
    #####: 6209:		  && !rc_forwards_flag && !rc_backwards_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6210:		{
    #####: 6211:		  auto int y = act_year;
        -: 6212:		  auto int n;
        -: 6213:		  auto char hc;
        -: 6214:		  auto Bool is_weekday_mode;
        -: 6215:
        -: 6216:
    #####: 6217:		  if (!nth_day_of_year_flag)
branch  0 never executed
branch  1 never executed
        -: 6218:		    {
    #####: 6219:		      len = (int) strlen (option) + len_year_max;
    #####: 6220:		      if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 6221:			resize_all_strings (len + 1, FALSE, __FILE__,
call    0 never executed
        -: 6222:					    (long) __LINE__);
    #####: 6223:		      sprintf (s2, "%0*d%s", len_year_max, y, option);
        -: 6224:		      /*
        -: 6225:		         The `rc_get_date()' arguments `wmax', `hc' and `i' are
        -: 6226:		         only dummys and must be given.  They are not respected!
        -: 6227:		       */
    #####: 6228:		      (void) rc_get_date (s2, lineptrs, FALSE,
call    0 never executed
        -: 6229:					  &is_weekday_mode, &day, &month, &y,
        -: 6230:					  &n, &wmax, &hc, &i, &i,
        -: 6231:					  _("Internal"), -1L, s2, FALSE);
    #####: 6232:		      if (y != SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
        -: 6233:			{
    #####: 6234:			  if (!dvar)
branch  0 never executed
branch  1 never executed
        -: 6235:			    {
        -: 6236:			      /*
        -: 6237:			         MMWW[W]N or MMDD given.
        -: 6238:			       */
    #####: 6239:			      if (!month)
branch  0 never executed
branch  1 never executed
    #####: 6240:				month = act_month;
    #####: 6241:			      if (month < MONTH_MIN || month > MONTH_MAX)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6242:				/*
        -: 6243:				   Error, invalid month given.
        -: 6244:				 */
    #####: 6245:				opt_error = 5;
        -: 6246:			      else
        -: 6247:				{
    #####: 6248:				  i = dvec[month - 1];
    #####: 6249:				  if (month == 2)
branch  0 never executed
branch  1 never executed
    #####: 6250:				    i += act_is_leap_year;
    #####: 6251:				  if (is_weekday_mode)
branch  0 never executed
branch  1 never executed
        -: 6252:				    {
        -: 6253:				      /*
        -: 6254:				         MMWW[W]N given.
        -: 6255:				       */
    #####: 6256:				      if (n == 9)
branch  0 never executed
branch  1 never executed
    #####: 6257:					day =
    #####: 6258:					  eval_holiday (i, month, act_year,
call    0 never executed
        -: 6259:							day, FALSE);
        -: 6260:				      else
        -: 6261:					{
    #####: 6262:					  day =
    #####: 6263:					    eval_holiday (DAY_MIN, month,
call    0 never executed
        -: 6264:							  act_year, day,
        -: 6265:							  TRUE);
    #####: 6266:					  day += (DAY_MAX * (n - 1));
    #####: 6267:					  if (day > i)
branch  0 never executed
branch  1 never executed
        -: 6268:					    /*
        -: 6269:					       Error, month contains no such
        -: 6270:					       "N'th weekday of month".
        -: 6271:					     */
    #####: 6272:					    opt_error = 5;
        -: 6273:					  else
        -: 6274:					    {
        -: 6275:					      /*
        -: 6276:					         Now check if the given date is valid.
        -: 6277:					       */
    #####: 6278:					      if (!day
branch  0 never executed
branch  1 never executed
    #####: 6279:						  || !valid_date (day, month,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6280:								  act_year))
        -: 6281:						/*
        -: 6282:						   Error, invalid date given.
        -: 6283:						 */
    #####: 6284:						opt_error = 5;
        -: 6285:					    }
        -: 6286:					}
        -: 6287:				    }
        -: 6288:				  else
        -: 6289:				    {
        -: 6290:				      /*
        -: 6291:				         MMDD given.
        -: 6292:				       */
    #####: 6293:				      if (day == 99)
branch  0 never executed
branch  1 never executed
    #####: 6294:					day = i;
    #####: 6295:				      if (!day)
branch  0 never executed
branch  1 never executed
    #####: 6296:					day = act_day;
    #####: 6297:				      if (day < DAY_MIN || day > i)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6298:					/*
        -: 6299:					   Error, invalid day given.
        -: 6300:					 */
    #####: 6301:					opt_error = 5;
        -: 6302:				    }
        -: 6303:				}
        -: 6304:			    }
    #####: 6305:			  else if (!day || !month)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6306:			    /*
        -: 6307:			       Error, either invalid date variable or
        -: 6308:			       invalid mode specifier given (not d|w).
        -: 6309:			     */
    #####: 6310:			    opt_error = 5;
    #####: 6311:			  if (!opt_error)
branch  0 never executed
branch  1 never executed
    #####: 6312:			    rc_period = day_of_year (day, month, act_year);
call    0 never executed
        -: 6313:			}
        -: 6314:		      else
        -: 6315:			/*
        -: 6316:			   Error, invalid date given.
        -: 6317:			 */
    #####: 6318:			opt_error = 5;
        -: 6319:		    }
    #####: 6320:		  else if (!rc_period)
branch  0 never executed
branch  1 never executed
        -: 6321:		    /*
        -: 6322:		       Error, zero date is invalid.
        -: 6323:		     */
    #####: 6324:		    opt_error = 5;
    #####: 6325:		  if (!opt_error)
branch  0 never executed
branch  1 never executed
        -: 6326:		    {
    #####: 6327:		      i = day_of_year (act_day, act_month, act_year);
call    0 never executed
    #####: 6328:		      if (rc_period >= i)
branch  0 never executed
branch  1 never executed
        -: 6329:			{
    #####: 6330:			  rc_period -= i;
        -: 6331:			  /*
        -: 6332:			     Set `rc_forwards_flag' only if the recomputed
        -: 6333:			     `rc_period' is not zero (it is in case @t
        -: 6334:			     is given and the actual date is the last day
        -: 6335:			     of the year, so we have to manage this like
        -: 6336:			     simple `-c' is given in command line.
        -: 6337:			   */
    #####: 6338:			  if (!rc_period)
branch  0 never executed
branch  1 never executed
    #####: 6339:			    rc_period_flag = FALSE;
        -: 6340:			  else
    #####: 6341:			    rc_forwards_flag = TRUE;
        -: 6342:			}
        -: 6343:		      else
        -: 6344:			{
    #####: 6345:			  rc_period = i - rc_period;
    #####: 6346:			  rc_backwards_flag = TRUE;
        -: 6347:			}
        -: 6348:		    }
        -: 6349:		}
        -: 6350:	      else
        -: 6351:		{
        -: 6352:		  /*
        -: 6353:		     Nw|+|- given.
        -: 6354:		   */
    #####: 6355:		  i = 0;
    #####: 6356:		  while (isdigit (*option))
branch  0 never executed
branch  1 never executed
        -: 6357:		    {
    #####: 6358:		      i++;
    #####: 6359:		      option++;
        -: 6360:		    }
    #####: 6361:		  option--;
    #####: 6362:		  if (!rc_period && !rc_week_year_flag)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6363:		    /*
        -: 6364:		       Error, zero length date of fixed date period given.
        -: 6365:		     */
    #####: 6366:		    opt_error = 5;
        -: 6367:		  else
    #####: 6368:		    opt_error = further_check (&option);
call    0 never executed
        -: 6369:		}
        -: 6370:	    }
        -: 6371:	}
    #####: 6372:      if (opt_error)
branch  0 never executed
branch  1 never executed
        -: 6373:	{
    #####: 6374:	  ptr_char = rc_period_argv;
    #####: 6375:	  is_longopt = rc_period_is_longopt;
        -: 6376:	  /*
        -: 6377:	     Sorry! Sorry!  This is so unprofessional!!  :)
        -: 6378:	   */
    #####: 6379:	  goto LABEL_option_error;
        -: 6380:	}
        -: 6381:      else
        -: 6382:	{
    #####: 6383:	  free (rc_period_argv);
    #####: 6384:	  free (rc_period_option);
        -: 6385:	}
        -: 6386:    }
        -: 6387:#endif /* USE_RC */
       74: 6388:  if (help_flag || license_flag || version_flag)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -: 6389:    {
        -: 6390:#if USE_PAGER
        -: 6391:      /*
        -: 6392:         No program output yet and output goes to a tty:
        -: 6393:         Set the standard stream buffers to unbuffered mode,
        -: 6394:         then get actual settings of the tty (needed if paging is wanted).
        -: 6395:       */
    #####: 6396:      if (is_tty1
branch  0 never executed
branch  1 never executed
        -: 6397:# ifdef GCAL_EPAGER
    #####: 6398:	  && (ext_pager == (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 6399:# endif
    #####: 6400:	  && is_tty2)
branch  0 never executed
branch  1 never executed
        -: 6401:	{
    #####: 6402:	  setbuf (stdout, (char *) NULL);
call    0 never executed
    #####: 6403:	  setbuf (stdin, (char *) NULL);
call    0 never executed
    #####: 6404:	  get_tty_scr_size (&tty_rows, &tty_cols);
call    0 never executed
        -: 6405:	}
    #####: 6406:      else if (help_on_help_flag)
branch  0 never executed
branch  1 never executed
        -: 6407:	/*
        -: 6408:	   We have to use the actual screen size in this case!
        -: 6409:	 */
    #####: 6410:	get_tty_scr_size (&tty_rows, &tty_cols);
call    0 never executed
        -: 6411:#endif /* USE_PAGER */
        -: 6412:      /*
        -: 6413:         Get the highlighting sequences of the terminal.
        -: 6414:       */
    #####: 6415:      get_tty_hls (hl_seq);
call    0 never executed
        -: 6416:#ifdef GCAL_EPAGER
    #####: 6417:      if (is_tty1
branch  0 never executed
branch  1 never executed
    #####: 6418:	  && is_tty2
branch  0 never executed
branch  1 never executed
    #####: 6419:	  && pager_flag
branch  0 never executed
branch  1 never executed
    #####: 6420:	  && (ext_pager != (char *) NULL) && (email_adr == (char *) NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6421:	{
    #####: 6422:	  child_pid = fork ();
call    0 never executed
    #####: 6423:	  switch (child_pid)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 6424:	    {
    #####: 6425:	    case -1:
        -: 6426:	      /*
        -: 6427:	         Error, `fork()' function failed.
        -: 6428:	       */
    #####: 6429:	      my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 6430:			((long) __LINE__) - 7L, "fork() child_pid=",
        -: 6431:			child_pid);
        -: 6432:	      /* Not reached. */
    #####: 6433:	    case 0:
        -: 6434:	      /*
        -: 6435:	         Child process (read from pipe):
        -: 6436:	         Connect PIPE-STDIN to SYS-STDIN in a safe way
        -: 6437:	         and launch external pager program.
        -: 6438:	       */
    #####: 6439:	      close (pipe_fd[1]);
call    0 never executed
    #####: 6440:	      if (pipe_fd[0])
branch  0 never executed
branch  1 never executed
        -: 6441:		{
    #####: 6442:		  close (0);
call    0 never executed
    #####: 6443:		  dup (pipe_fd[0]);
call    0 never executed
    #####: 6444:		  close (pipe_fd[0]);
call    0 never executed
        -: 6445:		}
    #####: 6446:	      if (pg_argv == (char **) NULL)
branch  0 never executed
branch  1 never executed
        -: 6447:		{
    #####: 6448:		  i = execlp (ext_pager, ext_pager, (char *) NULL);
        -: 6449:		  /*
        -: 6450:		     Error, `execlp()' function failed
        -: 6451:		     (this line should never be executed).
        -: 6452:		   */
    #####: 6453:		  len = (int) strlen (ext_pager) + LEN_SINGLE_LINE;
    #####: 6454:		  if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 6455:		    resize_all_strings (len + 1, FALSE, __FILE__,
call    0 never executed
        -: 6456:					(long) __LINE__);
    #####: 6457:		  sprintf (s1, "execlp(%s)=", ext_pager);
    #####: 6458:		  my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 6459:			    ((long) __LINE__) - 9L, s1, i);
        -: 6460:		}
        -: 6461:	      else
        -: 6462:		{
    #####: 6463:		  i = execvp (ext_pager, pg_argv);
        -: 6464:		  /*
        -: 6465:		     Error, `execvp()' function failed
        -: 6466:		     (this line should never be executed).
        -: 6467:		   */
    #####: 6468:		  len = (int) strlen (ext_pager) + LEN_SINGLE_LINE;
    #####: 6469:		  if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 6470:		    resize_all_strings (len + 1, FALSE, __FILE__,
call    0 never executed
        -: 6471:					(long) __LINE__);
    #####: 6472:		  sprintf (s1, "execvp(%s)=", ext_pager);
    #####: 6473:		  my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__,
call    0 never executed
        -: 6474:			    ((long) __LINE__) - 9L, s1, i);
        -: 6475:		}
        -: 6476:	      /* Not reached. */
        -: 6477:	    default:
        -: 6478:	      /*
        -: 6479:	         Parent process (write to pipe):
        -: 6480:	         Connect PIPE-stdout to SYS-stdout in a safe way
        -: 6481:	         and initiate the action.
        -: 6482:	       */
    #####: 6483:	      close (pipe_fd[0]);
call    0 never executed
    #####: 6484:	      if (pipe_fd[1] != 1)
branch  0 never executed
branch  1 never executed
        -: 6485:		{
    #####: 6486:		  close (1);
call    0 never executed
    #####: 6487:		  if (!dup (pipe_fd[1]))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6488:		    {
    #####: 6489:		      dup (pipe_fd[1]);
call    0 never executed
    #####: 6490:		      close (0);
call    0 never executed
        -: 6491:		    }
    #####: 6492:		  close (pipe_fd[1]);
call    0 never executed
        -: 6493:		}
        -: 6494:	    }
        -: 6495:	}
        -: 6496:#endif /* GCAL_EPAGER */
    #####: 6497:      if (help_flag)
branch  0 never executed
branch  1 never executed
        -: 6498:	{
    #####: 6499:	  if (help_on_help_flag)
branch  0 never executed
branch  1 never executed
        -: 6500:	    /*
        -: 6501:	       "Help on help" page wanted (`--long-help=?').
        -: 6502:	     */
        -: 6503:#if USE_PAGER
    #####: 6504:	    my_help_on_help (stdout, s3, lopt_ambig, tty_cols);
call    0 never executed
        -: 6505:#else /* !USE_PAGER */
        -: 6506:	    my_help_on_help (stdout, s3, lopt_ambig, SCREEN_COLS);
        -: 6507:#endif /* !USE_PAGER */
    #####: 6508:	  else if (ext_help_flag)
branch  0 never executed
branch  1 never executed
        -: 6509:	    /*
        -: 6510:	       "Extended" help pages wanted (`--long-help[=ARG]|[=?']
        -: 6511:	       or `-hh' or `-??' or `-h?' or `-?h').
        -: 6512:	     */
    #####: 6513:	    my_extended_help (stdout, lopt_help);
call    0 never executed
        -: 6514:	  else
        -: 6515:	    /*
        -: 6516:	       "Basic" help page wanted (`--help' or `-h' or `-?').
        -: 6517:	     */
    #####: 6518:	    my_basic_help (stdout);
call    0 never executed
        -: 6519:	}
        -: 6520:      else
        -: 6521:	{
    #####: 6522:	  if (license_flag)
branch  0 never executed
branch  1 never executed
        -: 6523:	    /*
        -: 6524:	       License text wanted (`--license' or `-L').
        -: 6525:	     */
    #####: 6526:	    my_license (stdout);
call    0 never executed
    #####: 6527:	  else if (version_flag)
branch  0 never executed
branch  1 never executed
        -: 6528:	    /*
        -: 6529:	       Version text wanted (`--version' or `-V').
        -: 6530:	     */
    #####: 6531:	    my_version (stdout);
call    0 never executed
        -: 6532:	}
        -: 6533:#ifdef GCAL_EPAGER
    #####: 6534:      if (is_tty1
branch  0 never executed
branch  1 never executed
    #####: 6535:	  && is_tty2
branch  0 never executed
branch  1 never executed
    #####: 6536:	  && pager_flag
branch  0 never executed
branch  1 never executed
    #####: 6537:	  && (ext_pager != (char *) NULL) && (email_adr == (char *) NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6538:	{
        -: 6539:	  /*
        -: 6540:	     We work unbuffered in this case so we have to flush the
        -: 6541:	     stdout buffer for showing all contents of it.
        -: 6542:	   */
    #####: 6543:	  fflush (stdout);
call    0 never executed
        -: 6544:	  /*
        -: 6545:	     And reconnect the SYS-STDIN/SYS-STDOUT file descriptors.
        -: 6546:	   */
    #####: 6547:	  close (0);
call    0 never executed
    #####: 6548:	  dup (sys_fd[0]);
call    0 never executed
    #####: 6549:	  close (1);
call    0 never executed
    #####: 6550:	  dup (sys_fd[1]);
call    0 never executed
        -: 6551:	  /*
        -: 6552:	     And wait until the child has performed all actions.
        -: 6553:	   */
    #####: 6554:	  while (wait ((int *) NULL) != child_pid)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 6555:	    ;
        -: 6556:# if HAVE_SIGNAL && defined(SIGPIPE)
        -: 6557:	  /*
        -: 6558:	     Reset the SIGPIPE signal.
        -: 6559:	   */
    #####: 6560:	  (void) signal (SIGPIPE, SIG_DFL);
call    0 never executed
        -: 6561:# endif
        -: 6562:	}
        -: 6563:#endif /* GCAL_EPAGER */
    #####: 6564:      my_exit (exit_stat_help);
call    0 never executed
        -: 6565:    }
       74: 6566:  month = 0;
       74: 6567:  if (argc > 1)
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
        -: 6568:    {
       26: 6569:      auto Bool is_list = FALSE;
       26: 6570:      auto Bool is_range = FALSE;
       26: 6571:      auto Bool month_set = FALSE;
       26: 6572:      auto Bool year_sep_found = FALSE;
        -: 6573:
        -: 6574:
       26: 6575:      for (; argc > 1; argc--, argv++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -: 6576:	{
       26: 6577:	  if (!month)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 6578:	    {
       26: 6579:	      option = *argv;
       26: 6580:	      if (*option == *MONTH3_LIT)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        1: 6581:		break;
        -: 6582:	      else
       92: 6583:		while (*option)
branch  0 taken 63%
branch  1 taken 37% (fallthrough)
        -: 6584:		  {
       42: 6585:		    if (*option == *MLIST_SEP || *option == *YLIST_SEP)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 6586:		      is_list = TRUE;
       42: 6587:		    else if (*option == *MRANGE_SEP || *option == *YRANGE_SEP)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 6588:		      is_range = TRUE;
       42: 6589:		    else if (*option == *YEAR_SEP)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 6590:		      year_sep_found = TRUE;
       42: 6591:		    else if (*option == *FYEAR_SEP)
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        1: 6592:		      is_fiscal_year = TRUE;
       42: 6593:		    option++;
        -: 6594:		  }
       25: 6595:	      option = *argv;
       25: 6596:	      if (!is_list
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25: 6597:		  && !is_range
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25: 6598:		  && !year_sep_found && !is_fiscal_year && !my_atoi (option))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
call    4 returned 100%
branch  5 taken 100% (fallthrough)
branch  6 taken 0%
        -: 6599:		{
       24: 6600:		  month = compare_d_m_name (option, MOnth);
call    0 returned 100%
       24: 6601:		  if (month)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6602:		    {
    #####: 6603:		      month_set = TRUE;
    #####: 6604:		      continue;
        -: 6605:		    }
        -: 6606:		}
        -: 6607:	    }
       25: 6608:	  if (!month)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 6609:	    {
       25: 6610:	      build_month_list (argv);
call    0 returned 100%
       25: 6611:	      if (!(*month_list).ml_month)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25: 6612:		month = atoi (*argv);
        -: 6613:	      else
    #####: 6614:		month = (*month_list).ml_month;
       25: 6615:	      if (month < MONTH_MIN || month > MONTH_MAX)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 6616:		{
       25: 6617:		  if (!is_fiscal_year)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
       24: 6618:		    year = month;
       25: 6619:		  month = 0;
       25: 6620:		  break;
        -: 6621:		}
        -: 6622:	    }
    #####: 6623:	  else if (!year)
branch  0 never executed
branch  1 never executed
        -: 6624:	    {
    #####: 6625:	      if ((*month_list).ml_year && (is_list || is_range))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 6626:		year = (*month_list).ml_year;
        -: 6627:	      else
    #####: 6628:		year = my_atoi (*argv);
call    0 never executed
        -: 6629:	      /*
        -: 6630:	         Check if a `MM YYYY-YYYY' or a `MM-MM YYYY+YYYY' command
        -: 6631:	         is given (MM|MM-MM is already managed), if so, evaluate
        -: 6632:	         the year range part.
        -: 6633:	       */
    #####: 6634:	      if (month
branch  0 never executed
branch  1 never executed
    #####: 6635:		  && isdigit (**argv)
branch  0 never executed
branch  1 never executed
    #####: 6636:		  && (strchr (*argv, *MRANGE_SEP) != (char *) NULL
branch  0 never executed
branch  1 never executed
    #####: 6637:		      || strchr (*argv, *YRANGE_SEP) != (char *) NULL))
branch  0 never executed
branch  1 never executed
        -: 6638:		{
    #####: 6639:		  i = 0;
    #####: 6640:		  while (isdigit (*(*(argv) + i)))
branch  0 never executed
branch  1 never executed
        -: 6641:		    {
    #####: 6642:		      s2[i] = *(*(argv) + i);
    #####: 6643:		      i++;
        -: 6644:		    }
    #####: 6645:		  if (*(*(argv) + i) == *MRANGE_SEP
branch  0 never executed
branch  1 never executed
    #####: 6646:		      || *(*(argv) + i) == *YRANGE_SEP)
branch  0 never executed
branch  1 never executed
        -: 6647:		    {
    #####: 6648:		      s2[i++] = '\0';
    #####: 6649:		      year = my_atoi (s2);
call    0 never executed
    #####: 6650:		      if (!year)
branch  0 never executed
branch  1 never executed
    #####: 6651:			year = act_year;
    #####: 6652:		      (*month_list).ml_year = year;
    #####: 6653:		      year = my_atoi (*(argv) + i);
call    0 never executed
    #####: 6654:		      if (!year)
branch  0 never executed
branch  1 never executed
    #####: 6655:			year = act_year;
    #####: 6656:		      month_list[1].ml_year = year;
    #####: 6657:		      if (*(*(argv) + i - 1) == *MRANGE_SEP)
branch  0 never executed
branch  1 never executed
        -: 6658:			{
    #####: 6659:			  (*month_list).ml_month = month_list[1].ml_month =
        -: 6660:			    month;
    #####: 6661:			  is_special_range = TRUE;
        -: 6662:			}
        -: 6663:		      else
        -: 6664:			{
    #####: 6665:			  i = 0;
    #####: 6666:			  while (month_list[i].ml_month)
branch  0 never executed
branch  1 never executed
    #####: 6667:			    i++;
    #####: 6668:			  if (!i)
branch  0 never executed
branch  1 never executed
        -: 6669:			    {
        -: 6670:			      /*
        -: 6671:			         `MM YYYY+YYYY' command given, treat it like
        -: 6672:			         the `MM YYYY-YYYY' command.
        -: 6673:			       */
    #####: 6674:			      (*month_list).ml_month =
    #####: 6675:				month_list[1].ml_month = month;
    #####: 6676:			      is_special_range = TRUE;
        -: 6677:			    }
        -: 6678:			  else
        -: 6679:			    {
        -: 6680:			      /*
        -: 6681:			         `MM-MM YYYY+YYYY' command given.
        -: 6682:			       */
    #####: 6683:			      i--;
    #####: 6684:			      month_list[1].ml_month = month_list[i].ml_month;
    #####: 6685:			      is_multi_range = TRUE;
        -: 6686:			    }
        -: 6687:			}
        -: 6688:		    }
        -: 6689:		  else
        -: 6690:		    {
    #####: 6691:		      year = month;
    #####: 6692:		      month = 0;
        -: 6693:		    }
    #####: 6694:		  break;
        -: 6695:		}
        -: 6696:	    }
        -: 6697:	}
        -: 6698:      /*
        -: 6699:         `.' or `..' or `.+' or `.-' argument found: 3 month mode wanted
        -: 6700:       */
       26: 6701:      if (*option == *MONTH3_LIT)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -: 6702:	{
        1: 6703:	  len = (int) strlen (option);
        1: 6704:	  if (len <= 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 6705:	    {
        1: 6706:	      if (*(option + 1) == *MONTH3_LIT)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 6707:		is_3month_mode2 = TRUE;
        -: 6708:	      else
        1: 6709:		is_3month_mode = TRUE;
        1: 6710:	      is_fiscal_year = TRUE;
        1: 6711:	      year_flag = FALSE;
        1: 6712:	      month = act_month;
        -: 6713:	      /*
        -: 6714:	         Check if an explicit year trails the 3 month mode command.
        -: 6715:	       */
        1: 6716:	      if (argc > 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6717:		{
    #####: 6718:		  argv++;
    #####: 6719:		  year = atoi (*argv);
    #####: 6720:		  if (!year)
branch  0 never executed
branch  1 never executed
    #####: 6721:		    year = act_year;
        -: 6722:		}
        -: 6723:	      else
        1: 6724:		year = act_year;
        1: 6725:	      if (is_3month_mode)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 6726:		{
        -: 6727:		  /*
        -: 6728:		     Either `.' or `.+' or `.-' 3 month mode command found.
        -: 6729:		   */
        1: 6730:		  if (!*(option + 1))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6731:		    {
        -: 6732:		      /*
        -: 6733:		         `.' 3 month mode command found.
        -: 6734:		       */
    #####: 6735:		      month--;
    #####: 6736:		      if (!month)
branch  0 never executed
branch  1 never executed
        -: 6737:			{
    #####: 6738:			  month = MONTH_MAX;
    #####: 6739:			  year--;
        -: 6740:			}
        -: 6741:		    }
        1: 6742:		  else if (*(option + 1) == *DES_LIT)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6743:		    {
        -: 6744:		      /*
        -: 6745:		         `.-' 3 month mode command found.
        -: 6746:		       */
    #####: 6747:		      month -= 2;
    #####: 6748:		      if (month < MONTH_MIN)
branch  0 never executed
branch  1 never executed
        -: 6749:			{
    #####: 6750:			  month = MONTH_MAX + month;
    #####: 6751:			  year--;
        -: 6752:			}
        -: 6753:		    }
        1: 6754:		  else if (*(option + 1) == *ASC_LIT)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 6755:		    /*
        -: 6756:		       `.+' 3 month mode command found.
        -: 6757:		     */
        -: 6758:		    ;		/* Void, nothing to do! */
        -: 6759:		  else
        -: 6760:		    {
        -: 6761:		      /*
        -: 6762:		         Error, invalid modifier trails the dot character:
        -: 6763:		         Print default month calendar only.
        -: 6764:		       */
        1: 6765:		      is_fiscal_year = FALSE;
        1: 6766:		      year = act_year;
        1: 6767:		      month = act_month;
        -: 6768:		    }
        1: 6769:		  if (year < YEAR_MIN)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6770:		    {
    #####: 6771:		      year = YEAR_MIN;
    #####: 6772:		      month = act_month;
        -: 6773:		    }
        -: 6774:		}
        -: 6775:	      else
        -: 6776:		/*
        -: 6777:		   `..' 3 month mode command found.
        -: 6778:		 */
    #####: 6779:		month = ((month + 1) - ((month - 1) % 3)) - 1;
        -: 6780:	    }
        -: 6781:	}
        -: 6782:      else
       25: 6783:	if (!month
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25: 6784:	    && !year
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25: 6785:	    && !month_set && !(*month_list).ml_month && !is_fiscal_year)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 96% (fallthrough)
branch  5 taken 4%
        -: 6786:	{
       24: 6787:	  year = month;
       24: 6788:	  month = 0;
        -: 6789:	}
        -: 6790:    }
       74: 6791:}
        -: 6792:
        -: 6793:
        -: 6794:
        -: 6795:static void
function build_month_list called 25 returned 100% blocks executed 25%
       25: 6796:build_month_list (argv)
        -: 6797:     char *argv[];
        -: 6798:/*!
        -: 6799:   If more than a single month/year is wanted (means list or ranges of
        -: 6800:     months or years), fill the global data structure `month_list[]'; which
        -: 6801:     is used in the `print_calendar()' function; according the values found
        -: 6802:     in the command line.
        -: 6803:*/
        -: 6804:{
        -: 6805:  register int i;
        -: 6806:  register int j;
        -: 6807:  register int k;
        -: 6808:  auto const char *option;
       25: 6809:  auto Bool is_list = FALSE;
       25: 6810:  auto Bool is_range = FALSE;
       25: 6811:  auto Bool year_sep_found = FALSE;
        -: 6812:  auto Bool buf_is_ext_year;
        -: 6813:
        -: 6814:
       25: 6815:  option = *argv;
       67: 6816:  for (; *option && !is_list && !is_range; option++)
branch  0 taken 63% (fallthrough)
branch  1 taken 37%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
       42: 6817:    if (*option == *MLIST_SEP || *option == *YLIST_SEP)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 6818:      {
    #####: 6819:	is_list = TRUE;
    #####: 6820:	if (*option == *YLIST_SEP)
branch  0 never executed
branch  1 never executed
    #####: 6821:	  is_ext_list = is_ext_year = TRUE;
        -: 6822:      }
       42: 6823:    else if (*option == *MRANGE_SEP || *option == *YRANGE_SEP)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 6824:      {
    #####: 6825:	is_range = TRUE;
    #####: 6826:	if (*option == *YRANGE_SEP)
branch  0 never executed
branch  1 never executed
    #####: 6827:	  is_ext_range = is_ext_year = TRUE;
        -: 6828:      }
       42: 6829:    else if (*option == *YEAR_SEP)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 6830:      year_sep_found = TRUE;
       25: 6831:  buf_is_ext_year = is_ext_year;
       25: 6832:  if (year_sep_found
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       25: 6833:      || (is_fiscal_year
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        1: 6834:	  && (is_ext_list
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 6835:	      || is_ext_year
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 6836:	      || (!is_list
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 6837:		  && !is_range)))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       24: 6838:      || (!is_fiscal_year && (is_list || is_range)))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -: 6839:    {
        1: 6840:      i = 0;
        1: 6841:      option = *argv;
        3: 6842:      while (*option)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -: 6843:	{
        1: 6844:	  year_sep_found = FALSE;
        1: 6845:	  j = 0;
        3: 6846:	  while (*option
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1: 6847:		 && !year_sep_found
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 6848:		 && ((!is_list
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 6849:		      && !is_range)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
    #####: 6850:		     || ((is_list
branch  0 never executed
branch  1 never executed
    #####: 6851:			  && ((*option != *MLIST_SEP)
branch  0 never executed
branch  1 never executed
    #####: 6852:			      && (*option != *YLIST_SEP)))
branch  0 never executed
branch  1 never executed
    #####: 6853:			 || (is_range
branch  0 never executed
branch  1 never executed
    #####: 6854:			     && ((*option != *MRANGE_SEP)
branch  0 never executed
branch  1 never executed
    #####: 6855:				 && (*option != *YRANGE_SEP))))))
branch  0 never executed
branch  1 never executed
        -: 6856:	    {
        2: 6857:	      year_sep_found = (Bool) (*option == *YEAR_SEP
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 6858:				       || *option == *FYEAR_SEP);
        1: 6859:	      s1[j++] = *option++;
        -: 6860:	    }
        1: 6861:	  if (year_sep_found)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 6862:	    s1[j - 1] = '\0';
        -: 6863:	  else
    #####: 6864:	    s1[j] = '\0';
        1: 6865:	  if (!*s1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 6866:	    {
        1: 6867:	      if (is_fiscal_year)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 6868:		{
        1: 6869:		  j = atoi (option);
        1: 6870:		  if (j)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6871:		    {
    #####: 6872:		      is_ext_year = FALSE;
    #####: 6873:		      month_list[i++].ml_month = act_month;
        -: 6874:		    }
        -: 6875:		}
        -: 6876:	      else
        -: 6877:		{
    #####: 6878:		  j = 0;
    #####: 6879:		  while (*option)
branch  0 never executed
branch  1 never executed
    #####: 6880:		    option++;
        -: 6881:		}
        -: 6882:	    }
        -: 6883:	  else
    #####: 6884:	    j = my_atoi (s1);
call    0 never executed
        1: 6885:	  if (is_ext_year)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6886:	    {
    #####: 6887:	      if (is_fiscal_year)
branch  0 never executed
branch  1 never executed
        -: 6888:		{
    #####: 6889:		  if ((j >= MONTH_MIN) && (j <= MONTH_MAX))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6890:		    month_list[i++].ml_month = j;
        -: 6891:		  else
        -: 6892:		    {
        -: 6893:		      /*
        -: 6894:		         Is the argument a valid month name?
        -: 6895:		       */
    #####: 6896:		      j = compare_d_m_name (s1, MOnth);
call    0 never executed
    #####: 6897:		      if (j)
branch  0 never executed
branch  1 never executed
    #####: 6898:			month_list[i++].ml_month = j;
        -: 6899:		      else
        -: 6900:			/*
        -: 6901:			   Are we at the end of the argument?
        -: 6902:			 */
    #####: 6903:		      if (!*option)
branch  0 never executed
branch  1 never executed
        -: 6904:			{
    #####: 6905:			  if (is_ext_list || is_ext_range)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 6906:			    {
    #####: 6907:			      if (!is_ext_list)
branch  0 never executed
branch  1 never executed
    #####: 6908:				month_list[i].ml_month =
    #####: 6909:				  month_list[i - 1].ml_month;
        -: 6910:			      else
    #####: 6911:				month_list[i].ml_month = MONTH_MIN;
    #####: 6912:			      j = my_atoi (s1);
call    0 never executed
    #####: 6913:			      if (j)
branch  0 never executed
branch  1 never executed
    #####: 6914:				month_list[i++].ml_year = j;
        -: 6915:			      else
    #####: 6916:				month_list[i].ml_month = 0;
        -: 6917:			    }
        -: 6918:			}
        -: 6919:		      else
        -: 6920:			/*
        -: 6921:			   Not at the end of the argument:
        -: 6922:			   Fiscal year list wanted and standard year given.
        -: 6923:			 */
    #####: 6924:		      if (!year_sep_found)
branch  0 never executed
branch  1 never executed
        -: 6925:			{
    #####: 6926:			  j = my_atoi (s1);
call    0 never executed
    #####: 6927:			  if (j)
branch  0 never executed
branch  1 never executed
    #####: 6928:			    month_list[i++].ml_month = j;
        -: 6929:			}
        -: 6930:		      else
        -: 6931:			/*
        -: 6932:			   Otherwise ignore given argument.
        -: 6933:			 */
    #####: 6934:			year_sep_found = FALSE;
        -: 6935:		    }
        -: 6936:		}
        -: 6937:	      else
        -: 6938:		{
    #####: 6939:		  if (year_sep_found)
branch  0 never executed
branch  1 never executed
        -: 6940:		    {
        -: 6941:		      /*
        -: 6942:		         Error, list/range of extended years given like
        -: 6943:		         5/1999;may/7777... or 5/1999+may/7777
        -: 6944:		         --> respect the year part of the date only.
        -: 6945:		       */
    #####: 6946:		      j = 0;
    #####: 6947:		      while (*option
branch  0 never executed
branch  1 never executed
    #####: 6948:			     && ((is_list
branch  0 never executed
branch  1 never executed
    #####: 6949:				  && (*option != *YLIST_SEP))
branch  0 never executed
branch  1 never executed
    #####: 6950:				 || (is_range && (*option != *YRANGE_SEP))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6951:			s1[j++] = *option++;
    #####: 6952:		      s1[j] = '\0';
    #####: 6953:		      j = my_atoi (s1);
call    0 never executed
        -: 6954:		    }
    #####: 6955:		  if (j)
branch  0 never executed
branch  1 never executed
    #####: 6956:		    month_list[i++].ml_month = j;
    #####: 6957:		  else if (is_list)
branch  0 never executed
branch  1 never executed
    #####: 6958:		    month_list[i++].ml_month = act_year;
        -: 6959:		}
    #####: 6960:	      if (year_sep_found)
branch  0 never executed
branch  1 never executed
        -: 6961:		{
    #####: 6962:		  while (*option == *YEAR_SEP || *option == *FYEAR_SEP)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6963:		    option++;
    #####: 6964:		  if (!is_fiscal_year)
branch  0 never executed
branch  1 never executed
        -: 6965:		    {
    #####: 6966:		      year_sep_found = FALSE;
    #####: 6967:		      while (*option
branch  0 never executed
branch  1 never executed
    #####: 6968:			     && ((is_list
branch  0 never executed
branch  1 never executed
    #####: 6969:				  && (*option != *YLIST_SEP))
branch  0 never executed
branch  1 never executed
    #####: 6970:				 || (is_range && (*option != *YRANGE_SEP))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6971:			option++;
        -: 6972:		    }
        -: 6973:		}
        -: 6974:	    }
        1: 6975:	  else if (*s1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 6976:	    {
    #####: 6977:	      if ((j >= MONTH_MIN) && (j <= MONTH_MAX))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 6978:		month_list[i++].ml_month = j;
        -: 6979:	      else
        -: 6980:		{
    #####: 6981:		  j = compare_d_m_name (s1, MOnth);
call    0 never executed
    #####: 6982:		  if (j)
branch  0 never executed
branch  1 never executed
    #####: 6983:		    month_list[i++].ml_month = j;
        -: 6984:		}
        -: 6985:	      /*
        -: 6986:	         Check if range of a selected month of years is given like:
        -: 6987:	         MM YYYY-YYYY or MM/YYYY-YYYY; e.g.: 5/1999-2011
        -: 6988:	         which means all May months starting in 1999 and ending in 2011.
        -: 6989:	       */
    #####: 6990:	      if (i
branch  0 never executed
branch  1 never executed
    #####: 6991:		  && is_range
branch  0 never executed
branch  1 never executed
    #####: 6992:		  && !year_sep_found && (*month_list).ml_year && !*option)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 6993:		{
    #####: 6994:		  if (j)
branch  0 never executed
branch  1 never executed
    #####: 6995:		    i--;
        -: 6996:		  else
    #####: 6997:		    j = my_atoi (s1);
call    0 never executed
    #####: 6998:		  if (j)
branch  0 never executed
branch  1 never executed
        -: 6999:		    {
    #####: 7000:		      month_list[i].ml_month = month_list[i - 1].ml_month;
    #####: 7001:		      month_list[i++].ml_year = j;
    #####: 7002:		      is_ext_range = FALSE;
    #####: 7003:		      is_special_range = TRUE;
        -: 7004:		    }
        -: 7005:		}
        -: 7006:	    }
        1: 7007:	  if (year_sep_found)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 7008:	    {
        1: 7009:	      if (j)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7010:		{
    #####: 7011:		  j = 0;
    #####: 7012:		  while (*option == *YEAR_SEP || *option == *FYEAR_SEP)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7013:		    option++;
    #####: 7014:		  if (!is_list && !is_range)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7015:		    while (*option)
branch  0 never executed
branch  1 never executed
    #####: 7016:		      s1[j++] = *option++;
    #####: 7017:		  else if (is_fiscal_year && (is_ext_list || is_ext_range))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7018:		    while (*option
branch  0 never executed
branch  1 never executed
    #####: 7019:			   && ((is_list
branch  0 never executed
branch  1 never executed
    #####: 7020:				&& (*option != *YLIST_SEP))
branch  0 never executed
branch  1 never executed
    #####: 7021:			       || (is_range && (*option != *YRANGE_SEP))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7022:		      s1[j++] = *option++;
        -: 7023:		  else
    #####: 7024:		    while (*option
branch  0 never executed
branch  1 never executed
    #####: 7025:			   && ((is_list
branch  0 never executed
branch  1 never executed
    #####: 7026:				&& (*option != *MLIST_SEP))
branch  0 never executed
branch  1 never executed
    #####: 7027:			       || (is_range && (*option != *MRANGE_SEP))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7028:		      s1[j++] = *option++;
    #####: 7029:		  s1[j] = '\0';
    #####: 7030:		  j = my_atoi (s1);
call    0 never executed
    #####: 7031:		  if (j)
branch  0 never executed
branch  1 never executed
        -: 7032:		    {
    #####: 7033:		      month_list[i - 1].ml_year = j;
    #####: 7034:		      if (is_list && !is_ext_range)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7035:			is_ext_list = TRUE;
    #####: 7036:		      else if (is_range && !is_ext_list)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7037:			is_ext_range = TRUE;
        -: 7038:		    }
    #####: 7039:		  else if (is_fiscal_year)
branch  0 never executed
branch  1 never executed
    #####: 7040:		    month_list[i - 1].ml_year = act_year;
        -: 7041:		}
        -: 7042:	      else
        -: 7043:		{
        1: 7044:		  if (is_fiscal_year)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 7045:		    while (*option
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 7046:			   && ((is_list
branch  0 never executed
branch  1 never executed
    #####: 7047:				&& (*option != *YLIST_SEP))
branch  0 never executed
branch  1 never executed
    #####: 7048:			       || (is_range && (*option != *YRANGE_SEP))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7049:		      option++;
        -: 7050:		  else
    #####: 7051:		    while (*option
branch  0 never executed
branch  1 never executed
    #####: 7052:			   && ((is_list
branch  0 never executed
branch  1 never executed
    #####: 7053:				&& (*option != *MLIST_SEP))
branch  0 never executed
branch  1 never executed
    #####: 7054:			       || (is_range && (*option != *MRANGE_SEP))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7055:		      option++;
        -: 7056:		}
        -: 7057:	    }
        2: 7058:	  while (*option == *MLIST_SEP
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        1: 7059:		 || *option == *MRANGE_SEP
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        1: 7060:		 || *option == *YLIST_SEP || *option == *YRANGE_SEP)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
    #####: 7061:	    option++;
        -: 7062:	  /*
        -: 7063:	     A list/range of fiscal years is wanted and the specified
        -: 7064:	     list/range of years is incomplete --> avoid error.
        -: 7065:	   */
        1: 7066:	  if (i && is_fiscal_year && !month_list[i - 1].ml_year)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7067:	    {
    #####: 7068:	      month_list[i - 1].ml_year = month_list[i - 1].ml_month;
    #####: 7069:	      month_list[i - 1].ml_month = MONTH_MIN;
        -: 7070:	    }
        1: 7071:	  is_ext_year = buf_is_ext_year;
        1: 7072:	  if ((Uint) i >= month_list_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7073:	    {
        -: 7074:	      /*
        -: 7075:	         Resize the `month_list[]' table.
        -: 7076:	       */
    #####: 7077:	      month_list_max <<= 1;
    #####: 7078:	      if (month_list_max * sizeof (Ml_struct) > testval)
branch  0 never executed
branch  1 never executed
    #####: 7079:		month_list_max--;
    #####: 7080:	      month_list = (Ml_struct *) my_realloc ((VOID_PTR) month_list,
call    0 never executed
    #####: 7081:						     month_list_max *
        -: 7082:						     sizeof (Ml_struct),
        -: 7083:						     ERR_NO_MEMORY_AVAILABLE,
        -: 7084:						     __FILE__,
        -: 7085:						     ((long) __LINE__) - 3L,
        -: 7086:						     "month_list[month_list_max]",
        -: 7087:						     month_list_max);
        -: 7088:	      /*
        -: 7089:	         Initialize the `month_list[]' structure elements.
        -: 7090:	       */
    #####: 7091:	      for (k = i; k < (int) month_list_max; k++)
branch  0 never executed
branch  1 never executed
    #####: 7092:		month_list[k].ml_year = month_list[k].ml_month = 0;
        -: 7093:	    }
        -: 7094:	}
        1: 7095:      if (is_range && !is_ext_range && !is_special_range)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7096:	{
        -: 7097:	  /*
        -: 7098:	     Fiscal year wanted and a range of months is specified only
        -: 7099:	     --> avoid error.
        -: 7100:	   */
    #####: 7101:	  if (is_fiscal_year)
branch  0 never executed
branch  1 never executed
    #####: 7102:	    is_ext_year = TRUE;
        -: 7103:	  else
        -: 7104:	    {
        -: 7105:	      /*
        -: 7106:	         Ok, compute the range of months and put it in the `month_list[]' table.
        -: 7107:	       */
    #####: 7108:	      j = (*month_list).ml_month;
    #####: 7109:	      k = month_list[1].ml_month;
    #####: 7110:	      i = 0;
    #####: 7111:	      while (month_list[i].ml_month)
branch  0 never executed
branch  1 never executed
    #####: 7112:		month_list[i++].ml_month = 0;
    #####: 7113:	      if (!j && !k)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7114:		(*month_list).ml_month = act_month;
        -: 7115:	      else
        -: 7116:		{
    #####: 7117:		  if (!j)
branch  0 never executed
branch  1 never executed
    #####: 7118:		    j = MONTH_MIN;
    #####: 7119:		  if (!k)
branch  0 never executed
branch  1 never executed
    #####: 7120:		    k = MONTH_MAX;
    #####: 7121:		  i = 0;
    #####: 7122:		  if (j > k)
branch  0 never executed
branch  1 never executed
    #####: 7123:		    for (; j >= k; i++, j--)
branch  0 never executed
branch  1 never executed
    #####: 7124:		      month_list[i].ml_month = j;
        -: 7125:		  else
    #####: 7126:		    for (; j <= k; i++, j++)
branch  0 never executed
branch  1 never executed
    #####: 7127:		      month_list[i].ml_month = j;
        -: 7128:		}
        -: 7129:	    }
        -: 7130:	}
        -: 7131:      /*
        -: 7132:         Fiscal/standard year wanted and an invalid range is specified
        -: 7133:         --> avoid error.
        -: 7134:       */
        1: 7135:      if (is_ext_range && month_list[2].ml_month)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 7136:	month_list[1].ml_month = 0;
        -: 7137:      /*
        -: 7138:         Standard year wanted and the list/range of years is incomplete
        -: 7139:         --> avoid error.
        -: 7140:       */
        1: 7141:      if (!month_list[1].ml_month
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 7142:	  && (is_ext_list || is_ext_range || is_special_range || is_ext_year))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        -: 7143:	{
    #####: 7144:	  is_ext_list = is_ext_range = is_special_range = is_ext_year = FALSE;
    #####: 7145:	  (*month_list).ml_month = act_month;
    #####: 7146:	  (*month_list).ml_year = act_year;
        -: 7147:	}
        -: 7148:    }
       25: 7149:}
        -: 7150:
        -: 7151:
        -: 7152:
        -: 7153:static void
function eliminate_invalid_data called 74 returned 100% blocks executed 62%
       74: 7154:eliminate_invalid_data ()
        -: 7155:/*!
        -: 7156:   Eliminates invalid command line argument values
        -: 7157:     and sets some internal variables according to the command line arguments.
        -: 7158:*/
        -: 7159:{
        -: 7160:  register int i;
        -: 7161:  register int len;
        -: 7162:
        -: 7163:
        -: 7164:  /*
        -: 7165:     Correction of month and year.
        -: 7166:   */
       74: 7167:  if (!month && !year)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 7168:    {
       73: 7169:      month = act_month;
       73: 7170:      year = act_year;
        -: 7171:    }
        1: 7172:  else if (year < YEAR_MIN || year > YEAR_MAX)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 7173:    {
    #####: 7174:      if (month && year)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7175:	month = act_month;
    #####: 7176:      year = act_year;
        -: 7177:    }
       74: 7178:  if (year_flag && month)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 7179:    month = 0;
       74: 7180:  if (month && !(*month_list).ml_month)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       74: 7181:    (*month_list).ml_month = month;
       74: 7182:  if (year && !(*month_list).ml_year)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       74: 7183:    (*month_list).ml_year = year;
        -: 7184:  /*
        -: 7185:     Set amount of month rows and columns according to the selected
        -: 7186:     or default year calendar sheet format.
        -: 7187:   */
       74: 7188:  if (is_3month_mode || is_3month_mode2)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 7189:    {
        -: 7190:      /*
        -: 7191:         Set fixed amount of month rows and columns for 3 month mode
        -: 7192:         calendar sheets; the `-b<>' option is ignored.
        -: 7193:       */
        2: 7194:      if (special_calsheet_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7195:	{
    #####: 7196:	  if (cal_special_flag)
branch  0 never executed
branch  1 never executed
        -: 7197:	    {
    #####: 7198:	      out_rows = JI3_OUT_ROWS;
    #####: 7199:	      out_cols = JI3_OUT_COLS;
        -: 7200:	    }
    #####: 7201:	  else if (cal_both_dates_flag)
branch  0 never executed
branch  1 never executed
        -: 7202:	    {
    #####: 7203:	      out_rows = BI3_OUT_ROWS;
    #####: 7204:	      out_cols = BI3_OUT_COLS;
        -: 7205:	    }
        -: 7206:	  else
        -: 7207:	    {
    #####: 7208:	      out_rows = SI3_OUT_ROWS;
    #####: 7209:	      out_cols = SI3_OUT_COLS;
        -: 7210:	    }
        -: 7211:	}
        -: 7212:      else
        -: 7213:	{
        1: 7214:	  if (cal_special_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7215:	    {
    #####: 7216:	      out_rows = J3_OUT_ROWS;
    #####: 7217:	      out_cols = J3_OUT_COLS;
        -: 7218:	    }
        1: 7219:	  else if (cal_both_dates_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7220:	    {
    #####: 7221:	      out_rows = B3_OUT_ROWS;
    #####: 7222:	      out_cols = B3_OUT_COLS;
        -: 7223:	    }
        -: 7224:	  else
        -: 7225:	    {
        1: 7226:	      out_rows = S3_OUT_ROWS;
        1: 7227:	      out_cols = S3_OUT_COLS;
        -: 7228:	    }
        -: 7229:	}
        -: 7230:    }
        -: 7231:  else
        -: 7232:    {
        -: 7233:      /*
        -: 7234:         Set the number of month columns according to year calendar sheet style
        -: 7235:         that is either given by the `-b<>' option or by the default value.
        -: 7236:       */
       73: 7237:      switch (out_rows)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
        -: 7238:	{
    #####: 7239:	case MONTH_MIN:
    #####: 7240:	  out_cols = MONTH_MAX;
    #####: 7241:	  break;
    #####: 7242:	case 2:
    #####: 7243:	  out_cols = 6;
    #####: 7244:	  break;
       73: 7245:	case 3:
       73: 7246:	  out_cols = S_OUT_COLS;
       73: 7247:	  break;
    #####: 7248:	case 4:
    #####: 7249:	  out_cols = J_OUT_COLS;
    #####: 7250:	  break;
    #####: 7251:	case 6:
    #####: 7252:	  out_cols = 2;
    #####: 7253:	  break;
    #####: 7254:	case MONTH_MAX:
    #####: 7255:	  out_cols = MONTH_MIN;
    #####: 7256:	  break;
    #####: 7257:	default:
        -: 7258:	  /*
        -: 7259:	     This case MUST be an internal error!
        -: 7260:	   */
    #####: 7261:	  abort ();
call    0 never executed
        -: 7262:	}
        -: 7263:      /*
        -: 7264:         If no `-b<>' option is given, set the year calendar sheet style
        -: 7265:         according to the `-j' or `jb' options if given.
        -: 7266:       */
       73: 7267:      if (!year_flag)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 7268:	{
       73: 7269:	  if (special_calsheet_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7270:	    {
    #####: 7271:	      if (cal_special_flag)
branch  0 never executed
branch  1 never executed
        -: 7272:		{
    #####: 7273:		  out_rows = JI_OUT_ROWS;
    #####: 7274:		  out_cols = JI_OUT_COLS;
        -: 7275:		}
    #####: 7276:	      else if (cal_both_dates_flag)
branch  0 never executed
branch  1 never executed
        -: 7277:		{
    #####: 7278:		  out_rows = BI_OUT_ROWS;
    #####: 7279:		  out_cols = BI_OUT_COLS;
        -: 7280:		}
        -: 7281:	    }
        -: 7282:	  else
        -: 7283:	    {
       73: 7284:	      if (cal_special_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7285:		{
    #####: 7286:		  out_rows = J_OUT_ROWS;
    #####: 7287:		  out_cols = J_OUT_COLS;
        -: 7288:		}
       73: 7289:	      else if (cal_both_dates_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7290:		{
    #####: 7291:		  out_rows = B_OUT_ROWS;
    #####: 7292:		  out_cols = B_OUT_COLS;
        -: 7293:		}
        -: 7294:	    }
        -: 7295:	}
        -: 7296:    }
        -: 7297:  /*
        -: 7298:     Set the length of a single day "cell" used within the calendar
        -: 7299:     sheets according to the selected mode (means either NO `-j' option,
        -: 7300:     `-j' or the `-jb' option).
        -: 7301:   */
       74: 7302:  if (cal_special_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7303:    /*
        -: 7304:       +1 because the day of year consists of 3 digits maximum
        -: 7305:       plus a separating space (==> 4).
        -: 7306:     */
    #####: 7307:    format_len = FORMAT_LEN_MIN + 1;
       74: 7308:  else if (cal_both_dates_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 7309:    /*
        -: 7310:       +5 because such a date consists of the day of month (2 digits
        -: 7311:       maximum) plus the day of year (3 digits maximum) plus two
        -: 7312:       textual parantheses plus a separating space (==> 8).
        -: 7313:     */
    #####: 7314:    format_len = FORMAT_LEN_MIN + 5;
        -: 7315:  else
        -: 7316:    /*
        -: 7317:       The day of month consists of 2 digits maximum
        -: 7318:       plus a separating space (==> 3).
        -: 7319:     */
       74: 7320:    format_len = FORMAT_LEN_MIN;
        -: 7321:  /*
        -: 7322:     Now get the maximum length of a textual day name,
        -: 7323:     which is returned by the function `day_name()'.
        -: 7324:   */
       74: 7325:  len_dayname_max = 0;
      592: 7326:  for (i = DAY_MIN; i <= DAY_MAX; i++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -: 7327:    {
      518: 7328:      len = (int) strlen (day_name (i));
call    0 returned 100%
      518: 7329:      if (len > len_dayname_max)
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
      222: 7330:	len_dayname_max = len;
        -: 7331:    }
        -: 7332:  /*
        -: 7333:     Now get the maximum length of a textual month name,
        -: 7334:     which is returned by the function `month_name()'.
        -: 7335:   */
       74: 7336:  len_monthname_max = 0;
      962: 7337:  for (i = MONTH_MIN; i <= MONTH_MAX; i++)
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -: 7338:    {
      888: 7339:      len = (int) strlen (month_name (i));
call    0 returned 100%
      888: 7340:      if (len > len_monthname_max)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
      222: 7341:	len_monthname_max = len;
        -: 7342:    }
        -: 7343:  /*
        -: 7344:     Now get the length of a textual day suffix, which is returned
        -: 7345:     by the function `day_suffix()'.  We check the length of the
        -: 7346:     ordinal number suffixes:  1st 2nd 3rd 4th.
        -: 7347:   */
       74: 7348:  len_suffix_max = 0;
      370: 7349:  for (i = DAY_MIN; i <= 4; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -: 7350:    {
      296: 7351:      len = (int) strlen (day_suffix (i));
call    0 returned 100%
      296: 7352:      if (len > len_suffix_max)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       74: 7353:	len_suffix_max = len;
        -: 7354:    }
       74: 7355:}
        -: 7356:
        -: 7357:
        -: 7358:
        -: 7359:static void
function pseudo_blank_conversion called 3 returned 100% blocks executed 54%
        3: 7360:pseudo_blank_conversion (text)
        -: 7361:     char **text;
        -: 7362:/*!
        -: 7363:   Perform conversion of quoted or unquoted PSEUDO_BLANK characters
        -: 7364:     in TEXT to real ' ' blank characters.
        -: 7365:*/
        -: 7366:{
        3: 7367:  if (strchr (*text, PSEUDO_BLANK) != (char *) NULL)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -: 7368:    {
        -: 7369:      auto char *ptr_char;
        -: 7370:      auto char *ptr2_char;
        -: 7371:
        -: 7372:
        -: 7373:      /*
        -: 7374:         Manage quoted or unquoted PSEUDO_BLANK characters.
        -: 7375:       */
        2: 7376:      ptr_char = ptr2_char = *text;
        6: 7377:      while (*ptr2_char)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -: 7378:	{
        2: 7379:	  if (*ptr2_char == PSEUDO_BLANK)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 7380:	    {
        2: 7381:	      ptr2_char++;
        2: 7382:	      *ptr_char++ = ' ';
        -: 7383:	    }
    #####: 7384:	  else if (*ptr2_char == QUOTE_CHAR)
branch  0 never executed
branch  1 never executed
        -: 7385:	    {
    #####: 7386:	      ptr2_char++;
    #####: 7387:	      if (*ptr2_char == PSEUDO_BLANK)
branch  0 never executed
branch  1 never executed
    #####: 7388:		*ptr_char++ = *ptr2_char++;
        -: 7389:	      else
    #####: 7390:		*ptr_char++ = QUOTE_CHAR;
        -: 7391:	    }
        -: 7392:	  else
    #####: 7393:	    *ptr_char++ = *ptr2_char++;
        -: 7394:	}
        2: 7395:      *ptr_char = '\0';
        -: 7396:    }
        3: 7397:}
        -: 7398:
        -: 7399:
        -: 7400:
        -: 7401:#if USE_RC
        -: 7402:static int
function further_check called 0 returned 0% blocks executed 0%
    #####: 7403:further_check (option)
        -: 7404:     char **option;
        -: 7405:/*!
        -: 7406:   Checks whether invalid characters trail the
        -: 7407:     argument of the `--period-of-fixed-dates=ARG' option.
        -: 7408:     If so, return a non-zero value, otherwise zero.
        -: 7409:*/
        -: 7410:{
    #####: 7411:  register int opt_error = 0;
        -: 7412:
        -: 7413:
    #####: 7414:  (*option)++;
    #####: 7415:  if (**option)
branch  0 never executed
branch  1 never executed
        -: 7416:    {
    #####: 7417:      rc_week_year_flag = (Bool) (tolower (**option) == 'w');
    #####: 7418:      rc_forwards_flag = (Bool) (**option == *ASC_LIT);
    #####: 7419:      rc_backwards_flag = (Bool) (**option == *DES_LIT);
    #####: 7420:      (*option)++;
    #####: 7421:      if (**option
branch  0 never executed
branch  1 never executed
    #####: 7422:	  || (!rc_week_year_flag && !rc_forwards_flag && !rc_backwards_flag))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7423:	/*
        -: 7424:	   Error, either argument is trailed by an illegal
        -: 7425:	   character or no mode specifying character (w|+|-) given.
        -: 7426:	 */
    #####: 7427:	opt_error = 5;
        -: 7428:    }
        -: 7429:
    #####: 7430:  return (opt_error);
        -: 7431:}
        -: 7432:#endif
