        -:    0:Source:../../src/hd-use.c
        -:    0:Programs:20
        -:    1:/*!
        -:    2:*  \file hd-use.c
        -:    3:*  \brief Manage the eternal holiday list.
        -:    4:*/
        -:    5:/*
        -:    6:*  Copyright (c) 1994, 95, 96, 1997, 2000, 2011 Thomas Esken
        -:    7:*  Copyright (c) 2010, 2011, 2013 Free Software Foundation, Inc.
        -:    8:*
        -:    9:*  This software doesn't claim completeness, correctness or usability.
        -:   10:*  On principle I will not be liable for ANY damages or losses (implicit
        -:   11:*  or explicit), which result from using or handling my software.
        -:   12:*  If you use this software, you agree without any exception to this
        -:   13:*  agreement, which binds you LEGALLY !!
        -:   14:*
        -:   15:*  This program is free software; you can redistribute it and/or modify
        -:   16:*  it under the terms of the `GNU General Public License' as published by
        -:   17:*  the `Free Software Foundation'; either version 3, or (at your option)
        -:   18:*  any later version.
        -:   19:*
        -:   20:*  You should have received a copy of the `GNU General Public License'
        -:   21:*  along with this program; if not, write to the:
        -:   22:*
        -:   23:*/
        -:   24:
        -:   25:
        -:   26:/*
        -:   27:*  Include header files.
        -:   28:*/
        -:   29:#include "tailor.h"
        -:   30:#if HAVE_CTYPE_H
        -:   31:# include <ctype.h>
        -:   32:#endif
        -:   33:#include "common.h"
        -:   34:#if USE_RC
        -:   35:# include "rc-defs.h"
        -:   36:#endif /* USE_RC */
        -:   37:#include "globals.h"
        -:   38:#include "hd-astro.h"
        -:   39:#include "hd-defs.h"
        -:   40:#include "hd-data.h"
        -:   41:#include "tty.h"
        -:   42:#include "utils.h"
        -:   43:#include "hd-use.h"
        -:   44:
        -:   45:
        -:   46:
        -:   47:/*
        -:   48:*  GLOBAL variables definitions.
        -:   49:*/
        -:   50:/*! Stores the fixed eternal holiday list texts. */
        -:   51:char *hd_table[HD_ELEMS_MAX] = { (char *) NULL };
        -:   52:
        -:   53:/*! Vector of holiday dates (legal days). */
        -:   54:char hd_ldays[HD_MAX] = { '\0' };
        -:   55:
        -:   56:/*! Vector of holiday dates (memorial days). */
        -:   57:char hd_mdays[HD_MAX] = { '\0' };
        -:   58:
        -:   59:
        -:   60:
        -:   61:/*
        -:   62:*  Function implementations.
        -:   63:*/
        -:   64:int
function eval_holiday called 0 returned 0% blocks executed 0%
    #####:   65:eval_holiday (day, month, year, wd, forwards)
        -:   66:     int day;
        -:   67:     const int month;
        -:   68:     const int year;
        -:   69:     const int wd;
        -:   70:     const Bool forwards;
        -:   71:/*!
        -:   72:   Detects first (FORWARDS==TRUE) or last (FORWARDS==FALSE) appearance
        -:   73:     of weekday `wd' in given date starting the search at `day'
        -:   74:     and returns the day number of `wd' in month.
        -:   75:*/
        -:   76:{
        -:   77:  LOOP
        -:   78:  {
    #####:   79:    if (weekday_of_date (day, month, year) == wd)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   80:      break;
        -:   81:    else
    #####:   82:      (forwards) ? day++ : day--;
branch  0 never executed
branch  1 never executed
        -:   83:  }
        -:   84:  /*
        -:   85:     Correction for missing days during Gregorian Reformation.
        -:   86:   */
    #####:   87:  if ((year == greg->year)
branch  0 never executed
branch  1 never executed
    #####:   88:      && (month == greg->month)
branch  0 never executed
branch  1 never executed
    #####:   89:      && (day >= greg->first_day) && (day <= greg->last_day))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   90:    day =
    #####:   91:      (forwards) ? eval_holiday (greg->last_day + 1, month, year, wd,
    #####:   92:				 forwards) : eval_holiday (greg->first_day -
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:   93:							   1, month, year, wd,
        -:   94:							   forwards);
        -:   95:
    #####:   96:  return (day);
        -:   97:}
        -:   98:
        -:   99:
        -:  100:
        -:  101:int
function orthodox_easter called 0 returned 0% blocks executed 0%
    #####:  102:orthodox_easter (year, greg_diff, greg_year, greg_month, greg_first_day,
        -:  103:		 greg_last_day)
        -:  104:     const int year;
        -:  105:     int *greg_diff;
        -:  106:     const int greg_year;
        -:  107:     const int greg_month;
        -:  108:     const int greg_first_day;
        -:  109:     const int greg_last_day;
        -:  110:/*!
        -:  111:   Calculates the day and month of Orthodox Easter giving the year
        -:  112:     and the specific Gregorian Reformation date.  It returns the
        -:  113:     "actual day_of_year number" of Eastern Easter of the Eastern Orthodox
        -:  114:     churches after AD 29 and passes the number of days between the given
        -:  115:     Gregorian calendar date and the according Julian calendar date
        -:  116:     in `&greg_diff'.
        -:  117:     If my references are right, the Eastern Orthodox churches celebrated
        -:  118:     Easter on the date of the Hebrew Pesach feast for dates prior AD 325
        -:  119:     (Council of Nicaea).  Later dated Easter is celebrated according to
        -:  120:     the Nicaean Easter date rule (Metonic cycle, Epacts and so forth...),
        -:  121:     but conforming to the Julian calendar.  So we have to compute the date
        -:  122:     of Easter by using Julian dates for a definite year, means, we have to
        -:  123:     ignore any missing days of a Gregorian Reformation for this year.
        -:  124:     Then, we simply add the day difference of the given Gregorian calendar
        -:  125:     date and the according Julian calendar date -- i.e. the amount of days,
        -:  126:     the Julian calendar is past the Gregorian calendar -- to this date!
        -:  127:   See the `knuth_easter_formula()' function for further details.
        -:  128:*/
        -:  129:{
        -:  130:  auto Greg_struct tmp_greg;
        -:  131:  register int easter;
        -:  132:  register int diff;
        -:  133:
        -:  134:
        -:  135:  /*
        -:  136:     We first need to buffer the Gregorian Reformation period actually used.
        -:  137:   */
    #####:  138:  tmp_greg.first_day = greg->first_day;
    #####:  139:  tmp_greg.last_day = greg->last_day;
    #####:  140:  tmp_greg.month = greg->month;
    #####:  141:  tmp_greg.year = greg->year;
    #####:  142:  if (year < 325)
branch  0 never executed
branch  1 never executed
    #####:  143:    easter = tishri_1 (year) - 163;
call    0 never executed
        -:  144:  else
        -:  145:    {
        -:  146:      /*
        -:  147:         Then we set the Gregorian Reformation period to a date
        -:  148:         which is out of the range of dates Gcal is able to manage,
        -:  149:         for computing the Easter Sunday of a Julian date, means
        -:  150:         we behave as if no Gregorian Reformation has ever happened.
        -:  151:       */
    #####:  152:      greg->last_day = greg->first_day = DAY_MIN;
    #####:  153:      greg->month = MONTH_MIN;
    #####:  154:      greg->year = YEAR_MAX + 3;
        -:  155:      /*
        -:  156:         Compute the Julian Easter Sunday's date.
        -:  157:       */
    #####:  158:      easter = knuth_easter_formula (year);
call    0 never executed
        -:  159:    }
        -:  160:  /*
        -:  161:     Now we set the Gregorian Reformation period to the date given.
        -:  162:   */
    #####:  163:  greg->year = greg_year;
    #####:  164:  greg->month = greg_month;
    #####:  165:  greg->first_day = greg_first_day;
    #####:  166:  greg->last_day = greg_last_day;
        -:  167:  /*
        -:  168:     The computation is done for the next date after the given Gregorian
        -:  169:     Reformation period, but for the current year (Gregorian date).
        -:  170:     If this is not proper, I would like to hear *your* solution how
        -:  171:     to compute it in the right way!
        -:  172:   */
    #####:  173:  diff = julian_gregorian_diff (greg->last_day + 1, greg->month, year);
call    0 never executed
    #####:  174:  if (greg_diff != (int *) NULL)
branch  0 never executed
branch  1 never executed
    #####:  175:    *greg_diff = diff;
        -:  176:  /*
        -:  177:     And restore the buffered Gregorian Reformation date actually used.
        -:  178:   */
    #####:  179:  greg->year = tmp_greg.year;
    #####:  180:  greg->month = tmp_greg.month;
    #####:  181:  greg->last_day = tmp_greg.last_day;
    #####:  182:  greg->first_day = tmp_greg.first_day;
        -:  183:
    #####:  184:  return (easter + diff);
        -:  185:}
        -:  186:
        -:  187:
        -:  188:
        -:  189:int
function tishri_1 called 0 returned 0% blocks executed 0%
    #####:  190:tishri_1 (year)
        -:  191:     const int year;
        -:  192:/*!
        -:  193:   Returns the `day_of_year' number of the (arithmetical lunisolar)
        -:  194:     Hebrew/Jewish Hebrew_New_Year/Rosh_Hashana/Tishri_1 for the
        -:  195:     given Julian/Gregorian year YEAR.
        -:  196:   Used formula:  John H. Conway, Guy and Berlekamp: "Winning Ways", Vol. 2.
        -:  197:   References:    Lot's of, but see `doc/calendar.faq' for the basics.
        -:  198:*/
        -:  199:{
        -:  200:  auto double n;
    #####:  201:  register int golden_number = (year % 19) + 1;
    #####:  202:  register int g12 = (12 * golden_number) % 19;
    #####:  203:  register int doy = day_of_year (dvec[8 - 1], 8, year);
call    0 never executed
        -:  204:
        -:  205:
        -:  206:  /*
        -:  207:     Calculation for Julian years.
        -:  208:   */
    #####:  209:  n = ((765433.0 / 492480.0) * g12)
    #####:  210:    + ((year % 4) / 4.0) - (((313.0 * year) + 89081.0) / 98496.0);
    #####:  211:  if (year >= greg->year)
branch  0 never executed
branch  1 never executed
        -:  212:    /*
        -:  213:       Correction term for Gregorian years.
        -:  214:     */
    #####:  215:    n += ((year / 100) - (year / 400) - 2.0);
    #####:  216:  doy += (int) n;
    #####:  217:  switch (weekday_of_date ((int) n, 9, year))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  218:    {
    #####:  219:    case 3:
        -:  220:    case 5:
        -:  221:    case DAY_MAX:
    #####:  222:      doy++;
    #####:  223:      break;
    #####:  224:    case DAY_MIN:
    #####:  225:      if ((n - (int) n >= 23269.0 / 25920.0) && (g12 > 11))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  226:	doy++;
    #####:  227:      break;
    #####:  228:    case 2:
    #####:  229:      if ((n - (int) n >= 1367.0 / 2160.0) && (g12 > 6))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  230:	doy++;
    #####:  231:      break;
    #####:  232:    default:
        -:  233:      ;				/* Void, nothing to do. */
        -:  234:    }
        -:  235:
    #####:  236:  return (doy);
        -:  237:}
        -:  238:
        -:  239:
        -:  240:
        -:  241:int
function muharram_1 called 0 returned 0% blocks executed 0%
    #####:  242:muharram_1 (year, doy)
        -:  243:     const int year;
        -:  244:     int *doy;
        -:  245:/*!
        -:  246:   Returns the `day_of_year' number of the (arithmetical lunar)
        -:  247:     Islamic *CIVIL* calendar's Islamic_New_Year/MuHarram_1 for the
        -:  248:     given Julian/Gregorian year YEAR, which must be greater than AD 621.
        -:  249:     The caller has to guarantee this!
        -:  250:     If MuHarram_1 appears twice in the year YEAR, the `day_of_year' number of
        -:  251:     the second (later) date is passed via the address of DOY, otherwise zero.
        -:  252:   Used formula:  My own one :)
        -:  253:   References:    Lot's of, but see `doc/calendar.faq' for the basics.
        -:  254:*/
        -:  255:{
        -:  256:  auto Ulint mjd;
        -:  257:  register int i;
        -:  258:  register int hijri_year;
        -:  259:  auto int d;
        -:  260:  auto int m;
        -:  261:  auto int y;
        -:  262:  auto int d2;
        -:  263:  auto int m2;
    #####:  264:  auto int y2 = 0;
        -:  265:
        -:  266:
        -:  267:  /*
        -:  268:     Calculate the approximate Hijri calendar year number for YEAR.
        -:  269:     Since the Hijri year is consistently shorter than a Julian
        -:  270:     or Gregorian year, we can simply multiply the year difference
        -:  271:     of `year-621' with a proper constant factor.  This factor is
        -:  272:     1.03071206847898 in Julian years, and 1.03069090396012 in
        -:  273:     Gregorian years.  The average length of a Hijri year is
        -:  274:     354.36~ days (10631 days within a 30-year cycle divided by 30),
        -:  275:     and when one divides this average length by the average length
        -:  276:     of a Julian year (365.25 days) or of a Gregorian year (365.2425),
        -:  277:     these above mentioned constant factors are the result.
        -:  278:   */
    #####:  279:  if (year > greg->year)
branch  0 never executed
branch  1 never executed
        -:  280:    /*
        -:  281:       Gregorian years.
        -:  282:     */
    #####:  283:    hijri_year = (greg->year - 621) * 1.03071206847898
    #####:  284:      + (year - greg->year) * 1.03069090396012;
        -:  285:  else
        -:  286:    /*
        -:  287:       Julian years.
        -:  288:     */
    #####:  289:    hijri_year = (year - 621) * 1.03071206847898;
        -:  290:  /*
        -:  291:     Perform at least two checks to detect the date(s) of MuHarram_1.
        -:  292:   */
        -:  293:  LOOP
        -:  294:  {
        -:  295:    /*
        -:  296:       Detect the number of complete 30-year cycles passed since
        -:  297:       MuHarram_1, 1 Anno Hegirae, which corresponds to AD 16-Jul-0622
        -:  298:       historically.  Then multiply this number by 10631 (the total
        -:  299:       number of days of such a cycle) and add 227017 (the number of
        -:  300:       days passed from AD 01-Jan-0001 until AD 16-Jul-0622).
        -:  301:     */
    #####:  302:    mjd = 227017L + (Ulint) (hijri_year / 30) * 10631L;
        -:  303:    /*
        -:  304:       Calculate the number of Hijri years in the actual 30-year cycle.
        -:  305:     */
    #####:  306:    i = hijri_year % 30;
        -:  307:    /*
        -:  308:       Is the actual 30-year cycle completed?
        -:  309:     */
    #####:  310:    if (i)
branch  0 never executed
branch  1 never executed
        -:  311:      {
        -:  312:	/*
        -:  313:	   No, add the number of days of the remaining Hijri years `years-1'.
        -:  314:	 */
    #####:  315:	mjd += (Ulint) ((i - 1) * 354);
        -:  316:	/*
        -:  317:	   And also add the number of leap days of the Hirji years which
        -:  318:	   occurred in the actual 30-year cycle except the actual Hirjri year.
        -:  319:	 */
    #####:  320:	for (--i; i; i--)
branch  0 never executed
branch  1 never executed
    #####:  321:	  if (i == 2
branch  0 never executed
branch  1 never executed
    #####:  322:	      || i == 5
branch  0 never executed
branch  1 never executed
    #####:  323:	      || i == 7
branch  0 never executed
branch  1 never executed
    #####:  324:	      || i == 10
branch  0 never executed
branch  1 never executed
    #####:  325:	      || i == 13
branch  0 never executed
branch  1 never executed
    #####:  326:	      || i == 16
branch  0 never executed
branch  1 never executed
    #####:  327:	      || i == 18 || i == 21 || i == 24 || i == 26 || i == 29)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:  328:	    mjd++;
        -:  329:      }
        -:  330:    else
        -:  331:      /*
        -:  332:         Yes, a completed 30-year cycle detected,
        -:  333:         so subtract one Hijri non-leap year.
        -:  334:       */
    #####:  335:      mjd -= 354L;
        -:  336:    /*
        -:  337:       Check if MuHarram_1 occurs twice in the year YEAR.
        -:  338:     */
    #####:  339:    if (mjd < date2num (13, MONTH_MIN, year))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  340:      {
    #####:  341:	num2date (mjd, &d2, &m2, &y2);
call    0 never executed
        -:  342:	/*
        -:  343:	   Detect if the *next* Hirji year completes a 30-year cycle.
        -:  344:	 */
    #####:  345:	if (!(++hijri_year % 30))
branch  0 never executed
branch  1 never executed
        -:  346:	  {
        -:  347:	    /*
        -:  348:	       Yes, so add one Hijri leap year and
        -:  349:	       skip processing (this case is the first check).
        -:  350:	     */
    #####:  351:	    mjd += 355L;
    #####:  352:	    break;
        -:  353:	  }
        -:  354:      }
        -:  355:    else
    #####:  356:      break;
        -:  357:  }
    #####:  358:  num2date (mjd, &d, &m, &y);
call    0 never executed
        -:  359:  /*
        -:  360:     Check if MuHarram_1 occurs twice in the year YEAR.
        -:  361:   */
    #####:  362:  if (y == y2)
branch  0 never executed
branch  1 never executed
        -:  363:    {
        -:  364:      /*
        -:  365:         Yes, MuHarram_1 occurs twice in the year YEAR.
        -:  366:       */
    #####:  367:      *doy = day_of_year (d, m, y);
call    0 never executed
    #####:  368:      return (day_of_year (d2, m2, y2));
call    0 never executed
        -:  369:    }
        -:  370:  /*
        -:  371:     No, MuHarram_1 occurs only once in the year YEAR.
        -:  372:   */
    #####:  373:  *doy = 0;
    #####:  374:  if (y2 == year)
branch  0 never executed
branch  1 never executed
        -:  375:    /*
        -:  376:       MuHarram_1 found during the first check.
        -:  377:     */
    #####:  378:    return (day_of_year (d2, m2, y2));
call    0 never executed
        -:  379:
        -:  380:  /*
        -:  381:     MuHarram_1 found during the second check.
        -:  382:   */
    #####:  383:  return (day_of_year (d, m, y));
call    0 never executed
        -:  384:}
        -:  385:
        -:  386:
        -:  387:
        -:  388:int
function find_chinese_leap_month called 0 returned 0% blocks executed 0%
    #####:  389:find_chinese_leap_month (conjunction_vector, nh_ws_prev_year, year, hour, min)
        -:  390:     Ulint *conjunction_vector;
        -:  391:     Ulint *nh_ws_prev_year;
        -:  392:     const int year;
        -:  393:     const int hour;
        -:  394:     const int min;
        -:  395:/*!
        -:  396:   Calculates the leap month of the Chinese calendar (based on the method
        -:  397:     used since AD 1645, which implemented the use of true -- astronomically
        -:  398:     detected -- Sun), which occurs in the given Julian/Gregorian year YEAR.
        -:  399:     * If the computation of the leap month fails by any reason,
        -:  400:       SPECIAL_VALUE is returned.
        -:  401:     * If there is no leap month in the YEAR,
        -:  402:       0 is returned.
        -:  403:     * If there is a leap month and it belongs to the YEAR,
        -:  404:       +1...+12 is returned.
        -:  405:     * If there is a leap month and it belongs to the previous YEAR,
        -:  406:       -11...-12 is returned.
        -:  407:   The date of the winter solstice (major solar term/Zhong-Qi 11) of the
        -:  408:     previous YEAR is returned via the address of NH_WS_PREV_YEAR.  All
        -:  409:     conjunction dates (starting on the date of NH_WS_PREV_YEAR or later)
        -:  410:     which are necessary to calculate the Chinese calendar for the YEAR,
        -:  411:     are returned via the address of CONJUNCTION_VECTOR.  The caller has to
        -:  412:     guarantee that the CONJUNCTION_VECTOR has 16 elements!
        -:  413:   Calculations are done for a line at a definite meridian expressed as
        -:  414:     a time value in HOUR and MIN.  If HOUR and MIN are set to zero,
        -:  415:     calculations are done for UTC/GMT.  If HOUR and MIN have a positive
        -:  416:     sign, calculations are done for meridians East of Greenwich, otherwise
        -:  417:     for meridians West of Greenwich.
        -:  418:   For a good and detailed reference of the Chinese calendar, see:
        -:  419:     "The Mathematics of the Chinese Calendar" by Helmer Aslaksen,
        -:  420:     <http://www.math.nus.edu.sg/aslaksen/>.
        -:  421:*/
        -:  422:{
        -:  423:  auto double n;
    #####:  424:  auto Ulint the_conjunction = 0L;
        -:  425:  auto Ulint cj_prev;
        -:  426:  auto Ulint cj;
        -:  427:  auto Ulint zq_prev;
        -:  428:  auto Ulint zq;
        -:  429:  auto Ulint zq1;
    #####:  430:  register int lm_prev = 0;
    #####:  431:  register int lm = 0;
    #####:  432:  register int i = 0;
    #####:  433:  register int j = 0;
        -:  434:  auto int d;
        -:  435:  auto int m;
        -:  436:  auto int y;
        -:  437:  auto int d2;
        -:  438:  auto int m2;
        -:  439:  auto int y2;
    #####:  440:  auto Bool lm_found = FALSE;
    #####:  441:  auto Bool double_zq_found = FALSE;
    #####:  442:  auto Bool second_double_zq_found = FALSE;
        -:  443:
        -:  444:
        -:  445:  /*
        -:  446:     Get the latest date that's necessary to check,
        -:  447:     which is the major solar term/Zhong-Qi 1 of the next YEAR.
        -:  448:   */
    #####:  449:  y = year;
    #####:  450:  n = NH_WS;
    #####:  451:  zq1 = (Ulint) sun_longitude (n, &d, &m, &y, hour, min, FALSE);
call    0 never executed
    #####:  452:  if (zq1 == (Ulint) SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  453:    return ((int) zq1);
    #####:  454:  zq1 =
    #####:  455:    (Ulint) next_sun_longitude (&n, 60.0, (double) zq1, &d, &m, &y, hour,
call    0 never executed
        -:  456:				min);
    #####:  457:  if (zq1 == (Ulint) SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  458:    return ((int) zq1);
        -:  459:  /*
        -:  460:     Get the earliest date that's necessary to check,
        -:  461:     which is the major solar term/Zhong-Qi 10 of the previous YEAR.
        -:  462:   */
    #####:  463:  y = year - 1;
    #####:  464:  n = NH_WS - 30.0;
    #####:  465:  zq_prev = (Ulint) sun_longitude (n, &d, &m, &y, hour, min, FALSE);
call    0 never executed
    #####:  466:  if (zq_prev == (Ulint) SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  467:    return ((int) zq_prev);
        -:  468:  /*
        -:  469:     Get the major solar term/Zhong-Qi 11 of the previous YEAR,
        -:  470:     the winter solstice, which is the base date for computing
        -:  471:     the Chinese_New_Year for the YEAR.
        -:  472:   */
    #####:  473:  *nh_ws_prev_year = zq =
    #####:  474:    (Ulint) next_sun_longitude (&n, 30.0, (double) zq_prev, &d, &m, &y, hour,
call    0 never executed
        -:  475:				min);
    #####:  476:  if (zq == (Ulint) SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  477:    return ((int) zq);
        -:  478:  /*
        -:  479:     And reset to the major solar term/Zhong-Qi 11 of the previous YEAR
        -:  480:     used in the ``next'' search later.
        -:  481:   */
    #####:  482:  n -= 30.0;
        -:  483:  /*
        -:  484:     Get the conjunction date of the previous YEAR, which is on or after
        -:  485:     the winter solstice date.
        -:  486:   */
    #####:  487:  *conjunction_vector = cj =
    #####:  488:    (Ulint) moonphase (MPHASE_NEW, FALSE, NULL, &the_conjunction, &d, &m, &y,
call    0 never executed
        -:  489:		       hour, min);
        -:  490:  /*
        -:  491:     If the conjunction date is on a later date as the winter solstice,
        -:  492:     get the previous conjunction date.
        -:  493:   */
    #####:  494:  if (cj > zq)
branch  0 never executed
branch  1 never executed
    #####:  495:    the_conjunction--;
        -:  496:  /*
        -:  497:     All preconditioning is done, now detect a possible leap month
        -:  498:     (that's a month without a major solar term).
        -:  499:   */
    #####:  500:  y2 = y = year - 1;
        -:  501:  LOOP
        -:  502:  {
        -:  503:    /*
        -:  504:       Get the actual conjunction date.
        -:  505:     */
    #####:  506:    cj_prev = cj;
    #####:  507:    cj =
    #####:  508:      (Ulint) moonphase (MPHASE_NEW, FALSE, NULL, &the_conjunction, &d, &m,
call    0 never executed
        -:  509:			 &y, hour, min);
    #####:  510:    if (j)
branch  0 never executed
branch  1 never executed
        -:  511:      {
    #####:  512:	if (*conjunction_vector != cj)
branch  0 never executed
branch  1 never executed
    #####:  513:	  *(conjunction_vector + j) = cj;
        -:  514:	else
    #####:  515:	  j--;
        -:  516:      }
        -:  517:    /*
        -:  518:       Check for leap month.
        -:  519:     */
    #####:  520:    if (lm || (!lm_found && (zq < cj)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  521:      {
    #####:  522:	if (lm)
branch  0 never executed
branch  1 never executed
        -:  523:	  {
    #####:  524:	    if (!lm_found)
branch  0 never executed
branch  1 never executed
        -:  525:	      {
    #####:  526:		if (zq >= cj)
branch  0 never executed
branch  1 never executed
        -:  527:		  {
        -:  528:		    /*
        -:  529:		       Raw leap month detected.
        -:  530:		     */
    #####:  531:		    lm_found = TRUE;
    #####:  532:		    lm = ((i + 10) % MONTH_MAX) - 1;
    #####:  533:		    if (lm <= 0)
branch  0 never executed
branch  1 never executed
        -:  534:		      {
    #####:  535:			lm += MONTH_MAX;
    #####:  536:			if (i < MONTH_MAX)
branch  0 never executed
branch  1 never executed
    #####:  537:			  lm = -lm;
        -:  538:		      }
        -:  539:		  }
        -:  540:	      }
        -:  541:	  }
        -:  542:	else
    #####:  543:	  lm = SPECIAL_VALUE;
        -:  544:      }
        -:  545:    else
    #####:  546:      lm = 0;
        -:  547:    /*
        -:  548:       Check for months with two solar terms.
        -:  549:     */
    #####:  550:    if (lm_found && (zq_prev >= cj_prev) && (zq < cj))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  551:      {
    #####:  552:	if (!double_zq_found)
branch  0 never executed
branch  1 never executed
        -:  553:	  {
    #####:  554:	    double_zq_found = TRUE;
    #####:  555:	    lm_prev = lm;
        -:  556:	  }
        -:  557:	else
    #####:  558:	  second_double_zq_found = TRUE;
    #####:  559:	if (lm > 0)
branch  0 never executed
branch  1 never executed
    #####:  560:	  lm_found = FALSE;
        -:  561:      }
        -:  562:    /*
        -:  563:       And get the date of the actual major solar term.
        -:  564:     */
    #####:  565:    zq_prev = zq;
    #####:  566:    zq =
    #####:  567:      (Ulint) next_sun_longitude (&n, 30.0, (double) zq_prev, &d2, &m2, &y2,
call    0 never executed
        -:  568:				  hour, min);
    #####:  569:    if (zq == (Ulint) SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  570:      return ((int) zq);
        -:  571:    /*
        -:  572:       Detect if the necessary range of dates is examined.
        -:  573:     */
    #####:  574:    if (cj >= zq1)
branch  0 never executed
branch  1 never executed
    #####:  575:      break;
        -:  576:    /*
        -:  577:       Next conjunction.
        -:  578:     */
    #####:  579:    the_conjunction++;
        -:  580:    /*
        -:  581:       Increase the month and conjunction vector counter.
        -:  582:     */
    #####:  583:    i++;
    #####:  584:    j++;
        -:  585:  }
        -:  586:  /*
        -:  587:     Correct the raw leap month found.
        -:  588:   */
    #####:  589:  if (double_zq_found && !second_double_zq_found)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  590:    {
    #####:  591:      y = year;
    #####:  592:      zq = (Ulint) sun_longitude (NH_WS, &d, &m, &y, hour, min, FALSE);
call    0 never executed
    #####:  593:      if (zq == (Ulint) SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  594:	return ((int) zq);
    #####:  595:      if (lm == MONTH_MAX)
branch  0 never executed
branch  1 never executed
        -:  596:	{
    #####:  597:	  the_conjunction = 0L;
    #####:  598:	  cj =
    #####:  599:	    (Ulint) moonphase (MPHASE_NEW, FALSE, NULL, &the_conjunction, &d,
call    0 never executed
        -:  600:			       &m, &y, hour, min);
        -:  601:	  /*
        -:  602:	     A 12th leap month can only occur if there is NO New Moon
        -:  603:	     on the same date as the winter solstice of the next YEAR.
        -:  604:	   */
    #####:  605:	  if (cj == zq)
branch  0 never executed
branch  1 never executed
        -:  606:	    /*
        -:  607:	       The true leap month is the previously detected raw leap month.
        -:  608:	     */
    #####:  609:	    lm = lm_prev;
        -:  610:	}
    #####:  611:      else if (lm != MONTH_MAX - 1)
branch  0 never executed
branch  1 never executed
        -:  612:	{
    #####:  613:	  j = MONTH_MAX - 2;
    #####:  614:	  while (*(conjunction_vector + j) <= zq)
branch  0 never executed
branch  1 never executed
    #####:  615:	    j++;
    #####:  616:	  if (j > MONTH_MAX)
branch  0 never executed
branch  1 never executed
        -:  617:	    /*
        -:  618:	       The true leap month is the previously detected raw leap month.
        -:  619:	     */
    #####:  620:	    lm = lm_prev;
        -:  621:	  else
        -:  622:	    /*
        -:  623:	       This YEAR is no leap sui, so it does not have a leap month!
        -:  624:	       (A sui is the solar year starting at the winter solstice
        -:  625:	       of the previous YEAR and ending at the winter solstice
        -:  626:	       of the YEAR.  A sui is a leap sui if there are 12 complete
        -:  627:	       months between the two 11th months at the beginning and
        -:  628:	       end of the sui.)
        -:  629:	     */
    #####:  630:	    lm = SPECIAL_VALUE;
        -:  631:	}
        -:  632:    }
    #####:  633:  if (lm == SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  634:    lm = 0;
        -:  635:
    #####:  636:  return (lm);
        -:  637:}
        -:  638:
        -:  639:
        -:  640:
        -:  641:int
function decode_date_format called 0 returned 0% blocks executed 0%
    #####:  642:decode_date_format (format_txt, result_txt, day, month, year, doy,
        -:  643:		    hls1_set, hls2_set, fixed_length_names)
        -:  644:     char *format_txt;
        -:  645:     char **result_txt;
        -:  646:     int day;
        -:  647:     int month;
        -:  648:     const int year;
        -:  649:     const int doy;
        -:  650:     const Bool hls1_set;
        -:  651:     const Bool hls2_set;
        -:  652:     const Bool fixed_length_names;
        -:  653:/*!
        -:  654:   Concatenates the elements of a date (inclusive highlighting) in formatted
        -:  655:     manner to `&result_txt' according to the order of format specifiers, which
        -:  656:     are given in the `format_txt.  The core area of the string vector
        -:  657:     `&result_txt' must be allocated and "filled" properly by the caller.
        -:  658:     "Filled" either means `&result_txt' contains a ZERO terminated text at
        -:  659:     function startup or a previous "*result_txt = '\0';" statement was
        -:  660:     performed by the caller before entering this function.
        -:  661:     If `day' is not zero but `doy' is zero:
        -:  662:       Use day of month and all other GROUPS.
        -:  663:     If `day' is zero but `doy' is not zero:
        -:  664:       Use day of year, insert a "day" text, use all other GROUPS except the month GROUP.
        -:  665:     If `day' is not zero and `doy' is not zero:
        -:  666:       Use both day of month and day of year and all other GROUPS.
        -:  667:     If `day' is zero and `doy' is zero:
        -:  668:       This results to an unmanaged internal error, because this
        -:  669:       case is unchecked due to faster internal processing speed.
        -:  670:     If `hls1_set' is TRUE and `hls2_set' is FALSE:
        -:  671:       Use `ehls1' highlighting sequences/marking characters.
        -:  672:     If `hls1_set' is FALSE and `hls2_set' is TRUE:
        -:  673:       Use `ehls2' highlighting sequences/marking characters.
        -:  674:     If `hls1_set' is FALSE and `hls2_set' is FALSE:
        -:  675:       Use no highlighting sequences/marking characters.
        -:  676:     If `hls1_set' is TRUE and `hls2_set' is TRUE:
        -:  677:       This case is unchecked due to faster internal processing speed
        -:  678:       but doesn't result to an unmanaged internal error, because
        -:  679:       the `ehls1' sequence is used by default.
        -:  680:     If `fixed_length_names' is set to TRUE, the texts returned by the
        -:  681:       `day_name()' and `month_name()' functions are set to a fixed length
        -:  682:       of `len_???name_max' characters (means trailing spaces), otherwise
        -:  683:       these texts are used as is.
        -:  684:     The `format_txt' must have exactly ONE day and year format specifier,
        -:  685:       exactly ONE format specifier from the month GROUP, BOTH format
        -:  686:       specifiers from the highlighting GROUP (%1 must be given before %2),
        -:  687:       and may have ONE weekday name format specifier.
        -:  688:     All format specifiers -- except the ones from the highlighting group --
        -:  689:       may be lead by an optional format instruction, which template is
        -:  690:       `[ ALIGNMENT [SIGN] [LZERO] WIDTH [STYLE] [SUFFIX] FORMAT ]', (see the
        -:  691:       `decode_format()' function for a more brief description of the
        -:  692:       format instruction), which will be evaluated and respected in case
        -:  693:       it is stated correctly:
        -:  694:     Day:
        -:  695:       %[FORMAT]D
        -:  696:     Year:
        -:  697:       %[FORMAT]Y
        -:  698:     Weekday name:
        -:  699:       %[FORMAT]K
        -:  700:     Month GROUP:
        -:  701:       %[FORMAT]M
        -:  702:       %[FORMAT]U
        -:  703:     Highlighting GROUP:
        -:  704:       %1 - Starting highlighting sequence
        -:  705:       %2 - Ending highlighting sequence
        -:  706:     Other (no group):
        -:  707:       _  - Blank (' ') character
        -:  708:       \_ - Underscore ('_') character
        -:  709:       \% - Percent ('%') character
        -:  710:       \\ - Backslash ('\') character
        -:  711:   The function return value is the text length of the "real" highlighting
        -:  712:   sequence pair if "real" highlighting must be performed, otherwise zero.
        -:  713:*/
        -:  714:{
    #####:  715:  register int skip_space = 0;
    #####:  716:  register int i = (int) strlen (format_txt);
        -:  717:  register int j;
        -:  718:  register int k;
        -:  719:  register int n;
    #####:  720:  register int hls_len = 0;
    #####:  721:  register int len = (int) strlen (*result_txt);
        -:  722:  register int pos;
    #####:  723:  auto int fstyle = FSTYLE_NONE;
    #####:  724:  auto int fwidth = SPECIAL_VALUE;
    #####:  725:  auto int d = day;
        -:  726:  auto char *ptr_char;
    #####:  727:  auto Bool hlsxe_before_month = TRUE;
    #####:  728:  auto Bool is_obsolete_space = FALSE;
    #####:  729:  auto Bool is_marking_char = (Bool) (ehls1s.len == 1);
    #####:  730:  auto Bool is_special_date = (!day && doy);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  731:  auto Bool is_cformat = FALSE;
    #####:  732:  auto Bool is_lformat = FALSE;
    #####:  733:  auto Bool is_sign = FALSE;
    #####:  734:  auto Bool is_lzero = FALSE;
    #####:  735:  auto Bool is_fformat = FALSE;
    #####:  736:  auto Bool is_suffix = FALSE;
        -:  737:
        -:  738:
    #####:  739:  j = len + i;
    #####:  740:  if ((Uint) j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  741:    resize_all_strings ((Uint) j + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####:  742:  if ((hls1_set || hls2_set) && !is_marking_char)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  743:    {
    #####:  744:      if (hls1_set)
branch  0 never executed
branch  1 never executed
    #####:  745:	hls_len = ehls1s.len + ehls1e.len;
        -:  746:      else
    #####:  747:	hls_len = ehls2s.len + ehls2e.len;
        -:  748:    }
    #####:  749:  if (is_special_date)
branch  0 never executed
branch  1 never executed
    #####:  750:    (void) doy2date (doy, (days_of_february (year) == 29), &day, &month);
call    0 never executed
call    1 never executed
        -:  751:  do
        -:  752:    {
    #####:  753:      while (*format_txt
branch  0 never executed
branch  1 never executed
    #####:  754:	     && (*format_txt != DFORMAT_CHAR) && (*format_txt != QUOTE_CHAR))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  755:	{
    #####:  756:	  if (!skip_space
branch  0 never executed
branch  1 never executed
    #####:  757:	      || ((*format_txt != ' ') && (*format_txt != PSEUDO_BLANK)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  758:	    {
    #####:  759:	      if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  760:		resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -:  761:				    (long) __LINE__);
    #####:  762:	      if (*format_txt == PSEUDO_BLANK)
branch  0 never executed
branch  1 never executed
    #####:  763:		*(*result_txt + len++) = ' ';
        -:  764:	      else
    #####:  765:		*(*result_txt + len++) = *format_txt;
        -:  766:	    }
    #####:  767:	  format_txt++;
    #####:  768:	  if (skip_space)
branch  0 never executed
branch  1 never executed
    #####:  769:	    skip_space--;
        -:  770:	}
    #####:  771:      if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  772:	resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -:  773:			    (long) __LINE__);
    #####:  774:      *(*result_txt + len) = '\0';
    #####:  775:      if (*format_txt)
branch  0 never executed
branch  1 never executed
        -:  776:	{
    #####:  777:	  if (*format_txt == DFORMAT_CHAR)
branch  0 never executed
branch  1 never executed
        -:  778:	    {
    #####:  779:	      pos = decode_format (format_txt, 1, &is_cformat,
call    0 never executed
        -:  780:				   &is_lformat, &is_sign, &is_lzero,
        -:  781:				   &is_suffix, &is_fformat, &fstyle, &fwidth);
    #####:  782:	      format_txt += pos;
    #####:  783:	      if (fwidth != SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  784:		if ((Uint) len + fwidth >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  785:		  resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -:  786:				      (long) __LINE__);
        -:  787:	      /*
        -:  788:	         Format specifier found.
        -:  789:	       */
    #####:  790:	      switch (*format_txt)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  791:		{
    #####:  792:		case HLS1S_CHAR:
    #####:  793:		  if (highlight_flag)
branch  0 never executed
branch  1 never executed
        -:  794:		    {
    #####:  795:		      if (!hls1_set && !hls2_set)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  796:			{
    #####:  797:			  if (!len && is_marking_char)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  798:			    {
    #####:  799:			      len++;
    #####:  800:			      strcat (*result_txt, NO_HLS);
        -:  801:			    }
        -:  802:			}
    #####:  803:		      else if (len)
branch  0 never executed
branch  1 never executed
    #####:  804:			if (is_marking_char
branch  0 never executed
branch  1 never executed
    #####:  805:			    && (*(*result_txt + (len - 1)) == ' '))
branch  0 never executed
branch  1 never executed
    #####:  806:			  *(*result_txt + --len) = '\0';
    #####:  807:		      if (hls1_set)
branch  0 never executed
branch  1 never executed
        -:  808:			{
    #####:  809:			  len += ehls1s.len;
    #####:  810:			  if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  811:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  812:						__FILE__, (long) __LINE__);
    #####:  813:			  strcat (*result_txt, ehls1s.seq);
        -:  814:			}
    #####:  815:		      else if (hls2_set)
branch  0 never executed
branch  1 never executed
        -:  816:			{
    #####:  817:			  len += ehls2s.len;
    #####:  818:			  if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  819:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  820:						__FILE__, (long) __LINE__);
    #####:  821:			  strcat (*result_txt, ehls2s.seq);
        -:  822:			}
        -:  823:		    }
    #####:  824:		  break;
    #####:  825:		case HLS1E_CHAR:
    #####:  826:		  if (highlight_flag)
branch  0 never executed
branch  1 never executed
        -:  827:		    {
    #####:  828:		      if (is_marking_char
branch  0 never executed
branch  1 never executed
    #####:  829:			  && (*(format_txt + 1) != ' ')
branch  0 never executed
branch  1 never executed
    #####:  830:			  && (*(format_txt + 1) != PSEUDO_BLANK)
branch  0 never executed
branch  1 never executed
    #####:  831:			  && !hls1_set && !hls2_set)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  832:			{
    #####:  833:			  len++;
    #####:  834:			  if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  835:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  836:						__FILE__, (long) __LINE__);
    #####:  837:			  strcat (*result_txt, NO_HLS);
        -:  838:			}
    #####:  839:		      if (hls1_set)
branch  0 never executed
branch  1 never executed
        -:  840:			{
    #####:  841:			  len += ehls1e.len;
    #####:  842:			  if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  843:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  844:						__FILE__, (long) __LINE__);
    #####:  845:			  strcat (*result_txt, ehls1e.seq);
    #####:  846:			  if (is_marking_char)
branch  0 never executed
branch  1 never executed
        -:  847:			    {
    #####:  848:			      skip_space++;
    #####:  849:			      hlsxe_before_month = is_obsolete_space = TRUE;
        -:  850:			    }
        -:  851:			}
    #####:  852:		      else if (hls2_set)
branch  0 never executed
branch  1 never executed
        -:  853:			{
    #####:  854:			  len += ehls2e.len;
    #####:  855:			  if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  856:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  857:						__FILE__, (long) __LINE__);
    #####:  858:			  strcat (*result_txt, ehls2e.seq);
    #####:  859:			  if (is_marking_char)
branch  0 never executed
branch  1 never executed
        -:  860:			    {
    #####:  861:			      skip_space++;
    #####:  862:			      hlsxe_before_month = is_obsolete_space = TRUE;
        -:  863:			    }
        -:  864:			}
        -:  865:		    }
    #####:  866:		  break;
    #####:  867:		case DAYNR_CHAR:
    #####:  868:		  if (hlsxe_before_month)
branch  0 never executed
branch  1 never executed
        -:  869:		    {
    #####:  870:		      hlsxe_before_month = FALSE;
    #####:  871:		      if (skip_space)
branch  0 never executed
branch  1 never executed
    #####:  872:			skip_space--;
        -:  873:		    }
    #####:  874:		  if (is_special_date)
branch  0 never executed
branch  1 never executed
    #####:  875:		    i = doy;
        -:  876:		  else
    #####:  877:		    i = day;
    #####:  878:		  if (is_suffix)
branch  0 never executed
branch  1 never executed
    #####:  879:		    k = len_suffix_max;
        -:  880:		  else
    #####:  881:		    k = 0;
    #####:  882:		  if (fwidth == SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
        -:  883:		    {
    #####:  884:		      if (is_special_date)
branch  0 never executed
branch  1 never executed
    #####:  885:			fwidth = 3;
        -:  886:		      else
    #####:  887:			fwidth = 2;
    #####:  888:		      if ((Uint) len + fwidth + k >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  889:			resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -:  890:					    (long) __LINE__);
        -:  891:		    }
    #####:  892:		  else if (is_special_date)
branch  0 never executed
branch  1 never executed
        -:  893:		    {
    #####:  894:		      fwidth++;
    #####:  895:		      if ((Uint) len + fwidth >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  896:			resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -:  897:					    (long) __LINE__);
        -:  898:		    }
    #####:  899:		  j = use_format (result_txt, len, "", i, TRUE,
call    0 never executed
        -:  900:				  is_cformat, is_lformat, is_sign, is_lzero,
        -:  901:				  is_suffix, is_fformat, fstyle, fwidth, 0);
    #####:  902:		  len += j;
    #####:  903:		  if (is_suffix)
branch  0 never executed
branch  1 never executed
        -:  904:		    {
    #####:  905:		      k += fwidth;
    #####:  906:		      if (j != k)
branch  0 never executed
branch  1 never executed
        -:  907:			{
    #####:  908:			  if (j < k)
branch  0 never executed
branch  1 never executed
        -:  909:			    {
    #####:  910:			      if ((Uint) len + k - j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  911:				resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  912:						    __FILE__,
        -:  913:						    (long) __LINE__);
    #####:  914:			      for (i = 0; i <= j; i++)
branch  0 never executed
branch  1 never executed
    #####:  915:				*(*result_txt + len - i + k - j) =
    #####:  916:				  *(*result_txt + len - i);
    #####:  917:			      for (i = 0; i < k - j; i++)
branch  0 never executed
branch  1 never executed
    #####:  918:				*(*result_txt + len - j + i) = ' ';
    #####:  919:			      len += (k - j);
        -:  920:			    }
    #####:  921:			  else if (is_fformat)
branch  0 never executed
branch  1 never executed
    #####:  922:			    len -= (j - k);
        -:  923:			}
        -:  924:		    }
    #####:  925:		  if (doy)
branch  0 never executed
branch  1 never executed
        -:  926:		    {
    #####:  927:		      if (!d)
branch  0 never executed
branch  1 never executed
        -:  928:			{
    #####:  929:			  ptr_char = _(" day");
    #####:  930:			  len += (int) strlen (ptr_char);
    #####:  931:			  if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  932:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  933:						__FILE__, (long) __LINE__);
    #####:  934:			  strcat (*result_txt, ptr_char);
        -:  935:			}
        -:  936:		      else
        -:  937:			{
    #####:  938:			  fwidth++;
    #####:  939:			  if ((Uint) len + 2 + fwidth >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  940:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  941:						__FILE__, (long) __LINE__);
    #####:  942:			  strcat (*result_txt, "(");
    #####:  943:			  len +=
    #####:  944:			    use_format (result_txt, len + 1, "", doy, TRUE,
call    0 never executed
        -:  945:					is_cformat, is_lformat, is_sign,
        -:  946:					is_lzero, FALSE, is_fformat, fstyle,
        -:  947:					fwidth, 0);
    #####:  948:			  strcat (*result_txt, ")");
    #####:  949:			  len += 2;
        -:  950:			}
        -:  951:		    }
    #####:  952:		  break;
    #####:  953:		case WDNAME_CHAR:
    #####:  954:		  if (hlsxe_before_month)
branch  0 never executed
branch  1 never executed
        -:  955:		    {
    #####:  956:		      hlsxe_before_month = FALSE;
    #####:  957:		      if (skip_space)
branch  0 never executed
branch  1 never executed
    #####:  958:			skip_space--;
        -:  959:		    }
    #####:  960:		  if (fixed_length_names && (fwidth == SPECIAL_VALUE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  961:		    {
    #####:  962:		      fwidth = len_dayname_max;
    #####:  963:		      is_lformat = TRUE;
    #####:  964:		      if ((Uint) len + fwidth >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  965:			resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -:  966:					    (long) __LINE__);
        -:  967:		    }
    #####:  968:		  len +=
    #####:  969:		    use_format (result_txt, len,
call    0 never executed
call    1 never executed
call    2 never executed
        -:  970:				day_name (weekday_of_date (day, month, year)),
        -:  971:				0, FALSE, is_cformat, is_lformat, is_sign,
        -:  972:				is_lzero, is_suffix, is_fformat, fstyle,
        -:  973:				fwidth, 0);
    #####:  974:		  break;
    #####:  975:		case MONTHNAME_CHAR:
    #####:  976:		  if (!is_special_date)
branch  0 never executed
branch  1 never executed
        -:  977:		    {
    #####:  978:		      if (fixed_length_names && (fwidth == SPECIAL_VALUE))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  979:			{
    #####:  980:			  fwidth = len_monthname_max;
    #####:  981:			  is_lformat = TRUE;
    #####:  982:			  if ((Uint) len + fwidth >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  983:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -:  984:						__FILE__, (long) __LINE__);
        -:  985:			}
    #####:  986:		      len +=
    #####:  987:			use_format (result_txt, len, month_name (month), 0,
call    0 never executed
call    1 never executed
        -:  988:				    FALSE, is_cformat, is_lformat, is_sign,
        -:  989:				    is_lzero, is_suffix, is_fformat, fstyle,
        -:  990:				    fwidth, 0);
        -:  991:		    }
        -:  992:		  else
        -:  993:		    {
    #####:  994:		      if (len)
branch  0 never executed
branch  1 never executed
        -:  995:			{
    #####:  996:			  if ((*(format_txt + 1) == ' '
branch  0 never executed
branch  1 never executed
    #####:  997:			       || *(format_txt + 1) == PSEUDO_BLANK)
branch  0 never executed
branch  1 never executed
    #####:  998:			      && (*(*result_txt + (len - 1)) == ' '))
branch  0 never executed
branch  1 never executed
    #####:  999:			    skip_space++;
        -: 1000:			  else
    #####: 1001:			    if (!skip_space
branch  0 never executed
branch  1 never executed
    #####: 1002:				&& is_obsolete_space && hlsxe_before_month)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1003:			    skip_space++;
        -: 1004:			}
    #####: 1005:		      hlsxe_before_month = is_obsolete_space = FALSE;
        -: 1006:		    }
    #####: 1007:		  break;
    #####: 1008:		case MONTHNR_CHAR:
    #####: 1009:		  if (!is_special_date)
branch  0 never executed
branch  1 never executed
        -: 1010:		    {
    #####: 1011:		      if (is_suffix)
branch  0 never executed
branch  1 never executed
    #####: 1012:			k = len_suffix_max;
        -: 1013:		      else
    #####: 1014:			k = 0;
    #####: 1015:		      if (fwidth == SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
        -: 1016:			{
    #####: 1017:			  fwidth = 2;
    #####: 1018:			  if ((Uint) len + fwidth + k >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1019:			    resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -: 1020:						__FILE__, (long) __LINE__);
        -: 1021:			}
    #####: 1022:		      j = use_format (result_txt, len, "", month, TRUE,
call    0 never executed
        -: 1023:				      is_cformat, is_lformat, is_sign,
        -: 1024:				      is_lzero, is_suffix, is_fformat, fstyle,
        -: 1025:				      fwidth, 0);
    #####: 1026:		      len += j;
    #####: 1027:		      if (is_suffix)
branch  0 never executed
branch  1 never executed
        -: 1028:			{
    #####: 1029:			  k += fwidth;
    #####: 1030:			  if (j != k)
branch  0 never executed
branch  1 never executed
        -: 1031:			    {
    #####: 1032:			      if (j < k)
branch  0 never executed
branch  1 never executed
        -: 1033:				{
    #####: 1034:				  if ((Uint) len + k - j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1035:				    resize_all_strings (maxlen_max << 1,
call    0 never executed
        -: 1036:							FALSE, __FILE__,
        -: 1037:							(long) __LINE__);
    #####: 1038:				  for (i = 0; i <= j; i++)
branch  0 never executed
branch  1 never executed
    #####: 1039:				    *(*result_txt + len - i + k - j) =
    #####: 1040:				      *(*result_txt + len - i);
    #####: 1041:				  for (i = 0; i < k - j; i++)
branch  0 never executed
branch  1 never executed
    #####: 1042:				    *(*result_txt + len - j + i) = ' ';
    #####: 1043:				  len += (k - j);
        -: 1044:				}
    #####: 1045:			      else if (is_fformat)
branch  0 never executed
branch  1 never executed
    #####: 1046:				len -= (j - k);
        -: 1047:			    }
        -: 1048:			}
        -: 1049:		    }
        -: 1050:		  else
        -: 1051:		    {
    #####: 1052:		      if (len)
branch  0 never executed
branch  1 never executed
        -: 1053:			{
    #####: 1054:			  if ((*(format_txt + 1) == ' '
branch  0 never executed
branch  1 never executed
    #####: 1055:			       || *(format_txt + 1) == PSEUDO_BLANK)
branch  0 never executed
branch  1 never executed
    #####: 1056:			      && (*(*result_txt + (len - 1)) == ' '))
branch  0 never executed
branch  1 never executed
    #####: 1057:			    skip_space++;
        -: 1058:			  else
    #####: 1059:			    if (!skip_space
branch  0 never executed
branch  1 never executed
    #####: 1060:				&& is_obsolete_space && hlsxe_before_month)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1061:			    skip_space++;
        -: 1062:			}
    #####: 1063:		      hlsxe_before_month = is_obsolete_space = FALSE;
        -: 1064:		    }
    #####: 1065:		  break;
    #####: 1066:		case YEARNR_CHAR:
    #####: 1067:		  if (hlsxe_before_month)
branch  0 never executed
branch  1 never executed
        -: 1068:		    {
    #####: 1069:		      hlsxe_before_month = FALSE;
    #####: 1070:		      if (skip_space)
branch  0 never executed
branch  1 never executed
    #####: 1071:			skip_space--;
        -: 1072:		    }
    #####: 1073:		  n = len_year_max;
    #####: 1074:		  if (transform_year)
branch  0 never executed
branch  1 never executed
        -: 1075:		    {
    #####: 1076:		      j = year - transform_year;
    #####: 1077:		      if ((j >= 0) && (transform_year > 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1078:			j++;
    #####: 1079:		      if (abs (j) > YEAR_MAX)
branch  0 never executed
branch  1 never executed
    #####: 1080:			n++;
        -: 1081:		    }
        -: 1082:		  else
    #####: 1083:		    j = year;
    #####: 1084:		  if (is_suffix)
branch  0 never executed
branch  1 never executed
    #####: 1085:		    k = len_suffix_max;
        -: 1086:		  else
    #####: 1087:		    k = 0;
    #####: 1088:		  if (fwidth == SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
        -: 1089:		    {
    #####: 1090:		      fwidth = n;
    #####: 1091:		      if ((Uint) len + fwidth + k >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1092:			resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -: 1093:					    (long) __LINE__);
        -: 1094:		    }
    #####: 1095:		  j = use_format (result_txt, len, "", j, TRUE,
call    0 never executed
        -: 1096:				  is_cformat, is_lformat, is_sign, is_lzero,
        -: 1097:				  is_suffix, is_fformat, fstyle, fwidth, 0);
    #####: 1098:		  len += j;
    #####: 1099:		  if (is_suffix)
branch  0 never executed
branch  1 never executed
        -: 1100:		    {
    #####: 1101:		      k += fwidth;
    #####: 1102:		      if (j != k)
branch  0 never executed
branch  1 never executed
        -: 1103:			{
    #####: 1104:			  if (j < k)
branch  0 never executed
branch  1 never executed
        -: 1105:			    {
    #####: 1106:			      if ((Uint) len + k - j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1107:				resize_all_strings (maxlen_max << 1, FALSE,
call    0 never executed
        -: 1108:						    __FILE__,
        -: 1109:						    (long) __LINE__);
    #####: 1110:			      for (i = 0; i <= j; i++)
branch  0 never executed
branch  1 never executed
    #####: 1111:				*(*result_txt + len - i + k - j) =
    #####: 1112:				  *(*result_txt + len - i);
    #####: 1113:			      for (i = 0; i < k - j; i++)
branch  0 never executed
branch  1 never executed
    #####: 1114:				*(*result_txt + len - j + i) = ' ';
    #####: 1115:			      len += (k - j);
        -: 1116:			    }
    #####: 1117:			  else if (is_fformat)
branch  0 never executed
branch  1 never executed
    #####: 1118:			    len -= (j - k);
        -: 1119:			}
        -: 1120:		    }
    #####: 1121:		  break;
    #####: 1122:		default:
        -: 1123:		  /*
        -: 1124:		     This case must be an internal error!
        -: 1125:		   */
    #####: 1126:		  abort ();
call    0 never executed
        -: 1127:		}
        -: 1128:	    }
        -: 1129:	  else
        -: 1130:	    {
    #####: 1131:	      if ((Uint) len + 2 >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1132:		resize_all_strings (maxlen_max << 1, FALSE, __FILE__,
call    0 never executed
        -: 1133:				    (long) __LINE__);
        -: 1134:	      /*
        -: 1135:	         Quote character found.
        -: 1136:	       */
    #####: 1137:	      switch (*++format_txt)
branch  0 never executed
branch  1 never executed
        -: 1138:		{
    #####: 1139:		case PSEUDO_BLANK:
        -: 1140:		case DFORMAT_CHAR:
    #####: 1141:		  *(*result_txt + len++) = *format_txt;
    #####: 1142:		  *(*result_txt + len) = '\0';
    #####: 1143:		  break;
    #####: 1144:		default:
    #####: 1145:		  if (*format_txt)
branch  0 never executed
branch  1 never executed
        -: 1146:		    {
    #####: 1147:		      if (*format_txt != QUOTE_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 1148:			*(*result_txt + len++) = QUOTE_CHAR;
    #####: 1149:		      *(*result_txt + len++) = *format_txt;
    #####: 1150:		      *(*result_txt + len) = '\0';
        -: 1151:		    }
        -: 1152:		  else
    #####: 1153:		    format_txt--;
        -: 1154:		}
        -: 1155:	    }
        -: 1156:	}
        -: 1157:      else
    #####: 1158:	break;
        -: 1159:    }
    #####: 1160:  while (*++format_txt);
branch  0 never executed
branch  1 never executed
        -: 1161:
    #####: 1162:  return (hls_len);
        -: 1163:}
        -: 1164:
        -: 1165:
        -: 1166:
        -: 1167:int
function decode_format called 6 returned 100% blocks executed 63%
        6: 1168:decode_format (format_txt, pos, is_cformat, is_lformat, is_sign,
        -: 1169:	       is_lzero, is_suffix, is_fformat, fstyle, fwidth)
        -: 1170:     char *format_txt;
        -: 1171:     int pos;
        -: 1172:     Bool *is_cformat;
        -: 1173:     Bool *is_lformat;
        -: 1174:     Bool *is_sign;
        -: 1175:     Bool *is_lzero;
        -: 1176:     Bool *is_suffix;
        -: 1177:     Bool *is_fformat;
        -: 1178:     int *fstyle;
        -: 1179:     int *fwidth;
        -: 1180:/*!
        -: 1181:   Checks for an optional format instruction which can either be used
        -: 1182:     in case a TVAR or a `%...' special text is referenced.  The template
        -: 1183:     of such a format is:  [ ALIGNMENT [SIGN] [LZERO] WIDTH [STYLE] [SUFFIX] FORMAT ],
        -: 1184:     e.g., $[<|:|>[+][0]N[u|U|l|L|w|W][&]*|#]TVAR, resp., %[<|:|>[+][0]N[u|U|l|L|w|W][&]*|#]?,
        -: 1185:     like `$:+010u&#a' or `%>20l&*Y'.
        -: 1186:     ALIGNMENT: '<' == adjusts field contents at the left margin using width WIDTH.
        -: 1187:                ':' == adjusts field contents in centered manner using width WIDTH.
        -: 1188:                '>' == ajdusts field contents at the right margin using width WIDTH.
        -: 1189:     SIGN     : '+' == leads a numerical value always by its sign.
        -: 1190:     LZERO    : '0' == fills a numerical value up to WIDTH leading zeroes
        -: 1191:                       inclusivly a possibly leading explicit SIGN or
        -: 1192:                       an implicitly leading negative sign.
        -: 1193:     WIDTH    : FWIDTH_MIN...FWIDTH_MAX == is the width of the field.
        -: 1194:     STYLE    : 'u' == converts field contents to upper-case letters.
        -: 1195:                'l' == converts field contents to lower-case letters.
        -: 1196:                'w' == converts field contents to capitalized words.
        -: 1197:     SUFFIX   : '&' == provides a numerical value with an ordinal number suffix.
        -: 1198:     FORMAT   : '*' == does not cut the field contents after
        -: 1199:                       position WIDTH if it is longer than WIDTH.
        -: 1200:                '#' == cuts the field contents after
        -: 1201:                       position WIDTH if it is longer than WIDTH.
        -: 1202:   On success, this function returns the position `pos' at which the format
        -: 1203:     instruction ends in the `format_txt' and the width of the field in `&fwidth'.
        -: 1204:     `&is_cformat', `&is_lformat', `&is_sign', `&is_lzero', `&is_suffix' and
        -: 1205:     `&is_fformat' are set to TRUE if the according directive characters are
        -: 1206:     found in proper order in `format_txt', otherwise they are set to FALSE;
        -: 1207:     and `&fstyle' is set to the according style value, otherwise to FSTYLE_NONE.
        -: 1208:   `&fwidth' is set to SPECIAL_VALUE and the unchanged position `pos' is
        -: 1209:     returned in case an error occurs during the scan of the format instruction,
        -: 1210:     which either means that it was not defined, or it contained a wrong
        -: 1211:     or misplaced or misspelled element.
        -: 1212:*/
        -: 1213:{
        6: 1214:  register int old_pos = pos;
        -: 1215:  register int i;
        -: 1216:  register int len;
        -: 1217:
        -: 1218:
        6: 1219:  *is_cformat = (*is_lformat) = (*is_sign) = (*is_lzero) = (*is_suffix) =
        6: 1220:    (*is_fformat) = FALSE;
        6: 1221:  *fstyle = FSTYLE_NONE;
        6: 1222:  *fwidth = SPECIAL_VALUE;
        6: 1223:  switch (*(format_txt + pos))
branch  0 taken 33%
branch  1 taken 0%
branch  2 taken 33%
branch  3 taken 33%
        -: 1224:    {
        2: 1225:    case FLEFT_CHAR:
        2: 1226:      *is_lformat = TRUE;
        2: 1227:      pos++;
        2: 1228:      break;
    #####: 1229:    case FCENTER_CHAR:
    #####: 1230:      *is_cformat = TRUE;
        -: 1231:      /* Fallthrough. */
        2: 1232:    case FRIGHT_CHAR:
        2: 1233:      pos++;
        2: 1234:      break;
        2: 1235:    default:
        2: 1236:      return (old_pos);
        -: 1237:    }
        4: 1238:  if (*(format_txt + pos) == FSIGN_CHAR)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1239:    {
    #####: 1240:      pos++;
    #####: 1241:      *is_sign = TRUE;
        -: 1242:    }
        4: 1243:  if (*(format_txt + pos) == FLZERO_CHAR)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -: 1244:    {
        1: 1245:      pos++;
        1: 1246:      *is_lzero = TRUE;
        -: 1247:    }
        4: 1248:  if (isdigit (*(format_txt + pos)))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1249:    {
        4: 1250:      if (*(format_txt + pos) != FLZERO_CHAR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1251:	{
        4: 1252:	  *fwidth = atoi (format_txt + pos);
        4: 1253:	  if (*fwidth > FWIDTH_MAX)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1254:	    *fwidth = i = FWIDTH_MAX;
        -: 1255:	  else
        4: 1256:	    i = *fwidth;
        4: 1257:	  if (!i)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1258:	    len = 1;
        -: 1259:	  else
        -: 1260:	    {
        4: 1261:	      len = 0;
       12: 1262:	      while (i)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -: 1263:		{
        4: 1264:		  len++;
        4: 1265:		  i /= 10;
        -: 1266:		}
        -: 1267:	    }
        4: 1268:	  pos += len;
        4: 1269:	  if (toupper (*(format_txt + pos)) == toupper (FUPPER_CHAR))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1270:	    {
    #####: 1271:	      pos++;
    #####: 1272:	      *fstyle = FSTYLE_UPPER;
        -: 1273:	    }
        4: 1274:	  if (toupper (*(format_txt + pos)) == toupper (FLOWER_CHAR))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1275:	    {
    #####: 1276:	      if (*fstyle == FSTYLE_NONE)
branch  0 never executed
branch  1 never executed
        -: 1277:		{
    #####: 1278:		  pos++;
    #####: 1279:		  *fstyle = FSTYLE_LOWER;
        -: 1280:		}
        -: 1281:	      else
    #####: 1282:		*fwidth = SPECIAL_VALUE;
        -: 1283:	    }
        4: 1284:	  if (toupper (*(format_txt + pos)) == toupper (FWORD_CHAR))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1285:	    {
    #####: 1286:	      if (*fstyle == FSTYLE_NONE)
branch  0 never executed
branch  1 never executed
        -: 1287:		{
    #####: 1288:		  pos++;
    #####: 1289:		  *fstyle = FSTYLE_WORD;
        -: 1290:		}
        -: 1291:	      else
    #####: 1292:		*fwidth = SPECIAL_VALUE;
        -: 1293:	    }
        4: 1294:	  if (*(format_txt + pos) == FSUFFIX_CHAR)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1295:	    {
    #####: 1296:	      pos++;
    #####: 1297:	      *is_suffix = TRUE;
        -: 1298:	    }
        4: 1299:	  switch (*(format_txt + pos))
branch  0 taken 50%
branch  1 taken 50%
branch  2 taken 0%
        -: 1300:	    {
        2: 1301:	    case FFIX_CHAR:
        2: 1302:	      *is_fformat = TRUE;
        -: 1303:	      /* Fallthrough. */
        4: 1304:	    case FVAR_CHAR:
        4: 1305:	      pos++;
        4: 1306:	      break;
    #####: 1307:	    default:
    #####: 1308:	      *fwidth = SPECIAL_VALUE;
        -: 1309:	    }
        -: 1310:	}
        -: 1311:      else
    #####: 1312:	*fwidth = SPECIAL_VALUE;
        -: 1313:    }
        -: 1314:  else
    #####: 1315:    *fwidth = SPECIAL_VALUE;
        4: 1316:  if (*fwidth == SPECIAL_VALUE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1317:    {
    #####: 1318:      *is_cformat = (*is_lformat) = (*is_sign) = (*is_lzero) = (*is_suffix) =
    #####: 1319:	(*is_fformat) = FALSE;
    #####: 1320:      *fstyle = FSTYLE_NONE;
    #####: 1321:      return (old_pos);
        -: 1322:    }
        -: 1323:
        4: 1324:  return (pos);
        -: 1325:}
        -: 1326:
        -: 1327:
        -: 1328:
        -: 1329:int
function use_format called 0 returned 0% blocks executed 0%
    #####: 1330:use_format (result_txt, pos, string, value, is_numeric, is_cformat,
        -: 1331:	    is_lformat, is_sign, is_lzero, is_suffix, is_fformat, fstyle,
        -: 1332:	    fwidth, extra_len)
        -: 1333:     char **result_txt;
        -: 1334:     const int pos;
        -: 1335:     const char *string;
        -: 1336:     const long value;
        -: 1337:     const Bool is_numeric;
        -: 1338:     const Bool is_cformat;
        -: 1339:     const Bool is_lformat;
        -: 1340:     const Bool is_sign;
        -: 1341:     const Bool is_lzero;
        -: 1342:     const Bool is_suffix;
        -: 1343:     const Bool is_fformat;
        -: 1344:     const int fstyle;
        -: 1345:     const int fwidth;
        -: 1346:     const int extra_len;
        -: 1347:/*!
        -: 1348:   Formats either the text `string' points to, or the number stored in `value'
        -: 1349:     and returns the effective length of the text formatted.
        -: 1350:     If `is_numeric' is set to TRUE, `value' is formatted, otherwise `string'.
        -: 1351:     If `extra_len' is not set to zero and this value is greater than the
        -: 1352:     computed length of `value' resp., `string', this value is taken instead
        -: 1353:     of the computed length of `value' resp., `string'.  The formatted result
        -: 1354:     is stored in `&result_txt', which must be allocated and "filled" properly
        -: 1355:     by the caller.  "Filled" either means `&result_txt' contains a ZERO
        -: 1356:     terminated text at function startup or a previous "*result_txt = '\0';"
        -: 1357:     statement was performed by the caller before entering this function.
        -: 1358:     `pos' is the zero based index at which this function adds/inserts
        -: 1359:     text into the `&result_txt'.
        -: 1360:*/
        -: 1361:{
    #####: 1362:  register int i = (int) strlen (string);
        -: 1363:  register int j;
        -: 1364:  register int n;
    #####: 1365:  register int len = (int) strlen (*result_txt);
    #####: 1366:  register int suffix_len = 0;
        -: 1367:  auto char *buf;
        -: 1368:  auto char *tmp;
        -: 1369:  auto char *ptr_char;
        -: 1370:  auto Bool is_translated;
        -: 1371:
        -: 1372:
    #####: 1373:  j = len + fwidth;
    #####: 1374:  if (!is_fformat && (i > fwidth))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1375:    j = len + i;
    #####: 1376:  if (is_suffix)
branch  0 never executed
branch  1 never executed
    #####: 1377:    j += len_suffix_max;
    #####: 1378:  if ((Uint) j >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1379:    resize_all_strings ((Uint) j + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####: 1380:  if (is_numeric)
branch  0 never executed
branch  1 never executed
        -: 1381:    {
    #####: 1382:      auto long num = value;
        -: 1383:
        -: 1384:
    #####: 1385:      if (!num)
branch  0 never executed
branch  1 never executed
    #####: 1386:	len = 1;
        -: 1387:      else
        -: 1388:	{
    #####: 1389:	  len = 0;
    #####: 1390:	  if (is_sign || (num < 0L))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1391:	    len++;
    #####: 1392:	  while (num)
branch  0 never executed
branch  1 never executed
        -: 1393:	    {
    #####: 1394:	      len++;
    #####: 1395:	      num /= 10L;
        -: 1396:	    }
        -: 1397:	}
    #####: 1398:      if (is_lzero && (len < fwidth))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1399:	len = fwidth;
    #####: 1400:      if (is_suffix)
branch  0 never executed
branch  1 never executed
    #####: 1401:	len += len_suffix_max;
    #####: 1402:      buf = (char *) my_malloc (len + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 never executed
        -: 1403:				__FILE__, ((long) __LINE__) - 1L, "buf", 0);
    #####: 1404:      if (is_sign)
branch  0 never executed
branch  1 never executed
        -: 1405:	{
    #####: 1406:	  if (is_lzero)
branch  0 never executed
branch  1 never executed
    #####: 1407:	    sprintf (buf, "%+0*ld", fwidth, value);
        -: 1408:	  else
    #####: 1409:	    sprintf (buf, "%+ld", value);
        -: 1410:	}
        -: 1411:      else
        -: 1412:	{
    #####: 1413:	  if (is_lzero)
branch  0 never executed
branch  1 never executed
    #####: 1414:	    sprintf (buf, "%0*ld", fwidth, value);
        -: 1415:	  else
    #####: 1416:	    sprintf (buf, "%ld", value);
        -: 1417:	}
    #####: 1418:      if (is_suffix)
branch  0 never executed
branch  1 never executed
        -: 1419:	{
    #####: 1420:	  tmp = (char *) day_suffix ((int) value);
call    0 never executed
    #####: 1421:	  suffix_len = (int) strlen (tmp);
    #####: 1422:	  strcat (buf, tmp);
        -: 1423:	}
        -: 1424:    }
        -: 1425:  else
        -: 1426:    {
    #####: 1427:      buf = (char *) my_malloc (i + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 never executed
        -: 1428:				__FILE__, ((long) __LINE__) - 1L, "buf", 0);
    #####: 1429:      strcpy (buf, string);
        -: 1430:    }
    #####: 1431:  j = len = (int) strlen (buf);
    #####: 1432:  switch (fstyle)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1433:    {
    #####: 1434:    case FSTYLE_UPPER:
    #####: 1435:      for (i = 0; i < len; i++)
branch  0 never executed
branch  1 never executed
        -: 1436:	{
    #####: 1437:	  buf[i] = (char) toupper (buf[i]);
    #####: 1438:	  if (!isupper (buf[i]) && (translate_string != (char *) NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1439:	    {
    #####: 1440:	      ptr_char = translate_string + 1;
    #####: 1441:	      while (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 1442:		{
    #####: 1443:		  if (*ptr_char == buf[i])
branch  0 never executed
branch  1 never executed
        -: 1444:		    {
    #####: 1445:		      buf[i] = *--ptr_char;
    #####: 1446:		      break;
        -: 1447:		    }
    #####: 1448:		  ptr_char++;
    #####: 1449:		  if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1450:		    ptr_char++;
        -: 1451:		}
        -: 1452:	    }
        -: 1453:	}
    #####: 1454:      break;
    #####: 1455:    case FSTYLE_LOWER:
    #####: 1456:      for (i = 0; i < len; i++)
branch  0 never executed
branch  1 never executed
        -: 1457:	{
    #####: 1458:	  buf[i] = (char) tolower (buf[i]);
    #####: 1459:	  if (!islower (buf[i]) && (translate_string != (char *) NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1460:	    {
    #####: 1461:	      ptr_char = translate_string;
    #####: 1462:	      while (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 1463:		{
    #####: 1464:		  if (*ptr_char == buf[i])
branch  0 never executed
branch  1 never executed
        -: 1465:		    {
    #####: 1466:		      buf[i] = *++ptr_char;
    #####: 1467:		      break;
        -: 1468:		    }
    #####: 1469:		  ptr_char++;
    #####: 1470:		  if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1471:		    ptr_char++;
        -: 1472:		}
        -: 1473:	    }
        -: 1474:	}
    #####: 1475:      break;
    #####: 1476:    case FSTYLE_WORD:
    #####: 1477:      *buf = (char) toupper (*buf);
    #####: 1478:      if (translate_string == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1479:	for (i = 1; i < len; i++)
branch  0 never executed
branch  1 never executed
        -: 1480:	  {
    #####: 1481:	    if (!isalpha (buf[i - 1]))
branch  0 never executed
branch  1 never executed
    #####: 1482:	      buf[i] = (char) toupper (buf[i]);
        -: 1483:	    else
    #####: 1484:	      buf[i] = (char) tolower (buf[i]);
        -: 1485:	  }
        -: 1486:      else
        -: 1487:	{
    #####: 1488:	  is_translated = FALSE;
    #####: 1489:	  if (!isupper (*buf))
branch  0 never executed
branch  1 never executed
        -: 1490:	    {
    #####: 1491:	      ptr_char = translate_string + 1;
    #####: 1492:	      while (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 1493:		{
    #####: 1494:		  if (*ptr_char == *buf)
branch  0 never executed
branch  1 never executed
        -: 1495:		    {
    #####: 1496:		      *buf = *--ptr_char;
    #####: 1497:		      is_translated = TRUE;
    #####: 1498:		      break;
        -: 1499:		    }
    #####: 1500:		  if (*(ptr_char - 1) == *buf)
branch  0 never executed
branch  1 never executed
        -: 1501:		    {
    #####: 1502:		      is_translated = TRUE;
    #####: 1503:		      break;
        -: 1504:		    }
    #####: 1505:		  ptr_char++;
    #####: 1506:		  if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1507:		    ptr_char++;
        -: 1508:		}
        -: 1509:	    }
    #####: 1510:	  for (i = 1; i < len; i++)
branch  0 never executed
branch  1 never executed
        -: 1511:	    {
    #####: 1512:	      if (!isalpha (buf[i - 1]) && !is_translated)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1513:		{
    #####: 1514:		  buf[i] = (char) toupper (buf[i]);
    #####: 1515:		  if (!isupper (buf[i]))
branch  0 never executed
branch  1 never executed
        -: 1516:		    {
    #####: 1517:		      ptr_char = translate_string + 1;
    #####: 1518:		      while (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 1519:			{
    #####: 1520:			  if (*ptr_char == buf[i])
branch  0 never executed
branch  1 never executed
        -: 1521:			    {
    #####: 1522:			      buf[i] = *--ptr_char;
    #####: 1523:			      is_translated = TRUE;
    #####: 1524:			      break;
        -: 1525:			    }
    #####: 1526:			  if (*(ptr_char - 1) == buf[i])
branch  0 never executed
branch  1 never executed
        -: 1527:			    {
    #####: 1528:			      is_translated = TRUE;
    #####: 1529:			      break;
        -: 1530:			    }
    #####: 1531:			  ptr_char++;
    #####: 1532:			  if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1533:			    ptr_char++;
        -: 1534:			}
        -: 1535:		    }
    #####: 1536:		  else if (isupper (buf[i]))
branch  0 never executed
branch  1 never executed
    #####: 1537:		    is_translated = TRUE;
        -: 1538:		}
        -: 1539:	      else
        -: 1540:		{
    #####: 1541:		  buf[i] = (char) tolower (buf[i]);
    #####: 1542:		  if (!islower (buf[i]))
branch  0 never executed
branch  1 never executed
        -: 1543:		    {
    #####: 1544:		      ptr_char = translate_string;
    #####: 1545:		      while (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 1546:			{
    #####: 1547:			  if (*ptr_char == buf[i])
branch  0 never executed
branch  1 never executed
        -: 1548:			    {
    #####: 1549:			      buf[i] = *++ptr_char;
    #####: 1550:			      break;
        -: 1551:			    }
    #####: 1552:			  ptr_char++;
    #####: 1553:			  if (*ptr_char == buf[i])
branch  0 never executed
branch  1 never executed
    #####: 1554:			    break;
    #####: 1555:			  if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1556:			    ptr_char++;
        -: 1557:			}
    #####: 1558:		      if (!*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1559:			is_translated = FALSE;
        -: 1560:		    }
        -: 1561:		}
        -: 1562:	    }
        -: 1563:	}
    #####: 1564:      break;
    #####: 1565:    default:
        -: 1566:      ;				/* Void, nothing to do! */
        -: 1567:    }
    #####: 1568:  if (!is_numeric && extra_len && (len != extra_len))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1569:    len = extra_len;
    #####: 1570:  if (is_cformat)
branch  0 never executed
branch  1 never executed
        -: 1571:    {
    #####: 1572:      if (len < fwidth)
branch  0 never executed
branch  1 never executed
        -: 1573:	{
    #####: 1574:	  n = fwidth - len;
    #####: 1575:	  n >>= 1;
    #####: 1576:	  tmp = (char *) my_malloc (n + 2, ERR_NO_MEMORY_AVAILABLE,
call    0 never executed
        -: 1577:				    __FILE__, ((long) __LINE__) - 1L,
        -: 1578:				    "tmp", 0);
    #####: 1579:	  for (i = 0; i < n; i++)
branch  0 never executed
branch  1 never executed
    #####: 1580:	    tmp[i] = ' ';
    #####: 1581:	  tmp[i] = '\0';
    #####: 1582:	  strcat (*result_txt, tmp);
    #####: 1583:	  strcat (*result_txt, buf);
    #####: 1584:	  if ((fwidth - len) % 2)
branch  0 never executed
branch  1 never executed
        -: 1585:	    {
    #####: 1586:	      tmp[i] = ' ';
    #####: 1587:	      tmp[i + 1] = '\0';
        -: 1588:	    }
    #####: 1589:	  strcat (*result_txt, tmp);
    #####: 1590:	  free (tmp);
    #####: 1591:	  j = fwidth;
        -: 1592:	}
        -: 1593:      else
        -: 1594:	{
    #####: 1595:	  if (is_fformat)
branch  0 never executed
branch  1 never executed
        -: 1596:	    {
    #####: 1597:	      if (is_numeric)
branch  0 never executed
branch  1 never executed
        -: 1598:		{
    #####: 1599:		  if (is_suffix)
branch  0 never executed
branch  1 never executed
        -: 1600:		    {
    #####: 1601:		      i = len - fwidth - suffix_len;
    #####: 1602:		      if (i <= 0)
branch  0 never executed
branch  1 never executed
    #####: 1603:			strncpy (*result_txt + pos, buf, fwidth + suffix_len);
        -: 1604:		      else
    #####: 1605:			strncpy (*result_txt + pos,
    #####: 1606:				 buf + len - fwidth - suffix_len,
    #####: 1607:				 fwidth + suffix_len);
    #####: 1608:		      *(*result_txt + pos + fwidth + suffix_len) = '\0';
        -: 1609:		    }
        -: 1610:		  else
        -: 1611:		    {
    #####: 1612:		      strncpy (*result_txt + pos, buf + len - fwidth, fwidth);
    #####: 1613:		      *(*result_txt + pos + fwidth) = '\0';
    #####: 1614:		      j = fwidth;
        -: 1615:		    }
        -: 1616:		}
        -: 1617:	      else
        -: 1618:		{
    #####: 1619:		  strncpy (*result_txt + pos, buf, fwidth);
    #####: 1620:		  *(*result_txt + pos + fwidth) = '\0';
    #####: 1621:		  j = fwidth;
        -: 1622:		}
        -: 1623:	    }
        -: 1624:	  else
    #####: 1625:	    strcat (*result_txt, buf);
        -: 1626:	}
        -: 1627:    }
    #####: 1628:  else if (is_lformat)
branch  0 never executed
branch  1 never executed
        -: 1629:    {
    #####: 1630:      if (is_fformat && (len > fwidth))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1631:	{
    #####: 1632:	  if (is_numeric)
branch  0 never executed
branch  1 never executed
        -: 1633:	    {
    #####: 1634:	      if (is_suffix)
branch  0 never executed
branch  1 never executed
        -: 1635:		{
    #####: 1636:		  i = len - fwidth - suffix_len;
    #####: 1637:		  if (i <= 0)
branch  0 never executed
branch  1 never executed
    #####: 1638:		    strncpy (*result_txt + pos, buf, fwidth + suffix_len);
        -: 1639:		  else
    #####: 1640:		    strncpy (*result_txt + pos,
    #####: 1641:			     buf + len - fwidth - suffix_len,
    #####: 1642:			     fwidth + suffix_len);
    #####: 1643:		  *(*result_txt + pos + fwidth + suffix_len) = '\0';
        -: 1644:		}
        -: 1645:	      else
        -: 1646:		{
    #####: 1647:		  strncpy (*result_txt + pos, buf + len - fwidth, fwidth);
    #####: 1648:		  *(*result_txt + pos + fwidth) = '\0';
    #####: 1649:		  j = fwidth;
        -: 1650:		}
        -: 1651:	    }
        -: 1652:	  else
        -: 1653:	    {
    #####: 1654:	      strncpy (*result_txt + pos, buf, fwidth);
    #####: 1655:	      *(*result_txt + pos + fwidth) = '\0';
    #####: 1656:	      j = fwidth;
        -: 1657:	    }
        -: 1658:	}
        -: 1659:      else
        -: 1660:	{
    #####: 1661:	  strcat (*result_txt, buf);
    #####: 1662:	  if (len < fwidth)
branch  0 never executed
branch  1 never executed
        -: 1663:	    {
    #####: 1664:	      n = fwidth - len;
    #####: 1665:	      tmp = (char *) my_malloc (n + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 never executed
        -: 1666:					__FILE__, ((long) __LINE__) - 1L,
        -: 1667:					"tmp", 0);
    #####: 1668:	      for (i = 0; i < n; i++)
branch  0 never executed
branch  1 never executed
    #####: 1669:		tmp[i] = ' ';
    #####: 1670:	      tmp[i] = '\0';
    #####: 1671:	      strcat (*result_txt, tmp);
    #####: 1672:	      free (tmp);
    #####: 1673:	      j = fwidth;
        -: 1674:	    }
        -: 1675:	}
        -: 1676:    }
        -: 1677:  else
        -: 1678:    {
    #####: 1679:      if (is_fformat && (len > fwidth))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1680:	{
    #####: 1681:	  if (is_numeric)
branch  0 never executed
branch  1 never executed
        -: 1682:	    {
    #####: 1683:	      if (is_suffix)
branch  0 never executed
branch  1 never executed
        -: 1684:		{
    #####: 1685:		  i = len - fwidth - suffix_len;
    #####: 1686:		  if (i <= 0)
branch  0 never executed
branch  1 never executed
    #####: 1687:		    strncpy (*result_txt + pos, buf, fwidth + suffix_len);
        -: 1688:		  else
    #####: 1689:		    strncpy (*result_txt + pos,
    #####: 1690:			     buf + len - fwidth - suffix_len,
    #####: 1691:			     fwidth + suffix_len);
    #####: 1692:		  *(*result_txt + pos + fwidth + suffix_len) = '\0';
        -: 1693:		}
        -: 1694:	      else
        -: 1695:		{
    #####: 1696:		  strncpy (*result_txt + pos, buf + len - fwidth, fwidth);
    #####: 1697:		  *(*result_txt + pos + fwidth) = '\0';
    #####: 1698:		  j = fwidth;
        -: 1699:		}
        -: 1700:	    }
        -: 1701:	  else
        -: 1702:	    {
    #####: 1703:	      strncpy (*result_txt + pos, buf, fwidth);
    #####: 1704:	      *(*result_txt + pos + fwidth) = '\0';
    #####: 1705:	      j = fwidth;
        -: 1706:	    }
        -: 1707:	}
        -: 1708:      else
        -: 1709:	{
    #####: 1710:	  if (len < fwidth)
branch  0 never executed
branch  1 never executed
        -: 1711:	    {
    #####: 1712:	      n = fwidth - len;
    #####: 1713:	      tmp = (char *) my_malloc (n + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 never executed
        -: 1714:					__FILE__, ((long) __LINE__) - 1L,
        -: 1715:					"tmp", 0);
    #####: 1716:	      for (i = 0; i < n; i++)
branch  0 never executed
branch  1 never executed
    #####: 1717:		tmp[i] = ' ';
    #####: 1718:	      tmp[i] = '\0';
    #####: 1719:	      strcat (*result_txt, tmp);
    #####: 1720:	      free (tmp);
    #####: 1721:	      j = fwidth;
        -: 1722:	    }
    #####: 1723:	  strcat (*result_txt, buf);
        -: 1724:	}
        -: 1725:    }
    #####: 1726:  free (buf);
        -: 1727:
    #####: 1728:  return (j);
        -: 1729:}
        -: 1730:
        -: 1731:
        -: 1732:
        -: 1733:void
function print_all_holidays called 1 returned 100% blocks executed 25%
        1: 1734:print_all_holidays (init_data, detected)
        -: 1735:     Bool init_data;
        -: 1736:     const Bool detected;
        -: 1737:/*!
        -: 1738:   Generate and display all holidays (global `hd_table') in sorted manner.
        -: 1739:*/
        -: 1740:{
        -: 1741:  auto const Cc_struct *ptr_cc;
        -: 1742:  register int easter;
        1: 1743:  register int i = 0;
        1: 1744:  register int j = 0;
        -: 1745:  register int k;
        1: 1746:  register int fday = 0;
        1: 1747:  register int count = (fiscal_month > MONTH_MIN) ? 2 : 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        1: 1748:  auto int hd_elems = 0;
        -: 1749:  auto char *ptr_char;
        -: 1750:
        -: 1751:
        1: 1752:  if (init_data || detected)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1753:    {
        1: 1754:      if (init_data)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      373: 1755:	for (i = 0; i < HD_MAX; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      372: 1756:	  hd_ldays[i] = hd_mdays[i] = '\0';
        1: 1757:      if (fiscal_month > MONTH_MIN)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1758:	{
    #####: 1759:	  fday = day_of_year (DAY_MIN, fiscal_month, year);
call    0 never executed
    #####: 1760:	  j = is_leap_year;
    #####: 1761:	  i = year;
        -: 1762:	}
        -: 1763:      do
        -: 1764:	{
        1: 1765:	  count--;
        1: 1766:	  easter = knuth_easter_formula (year);
call    0 returned 100%
        -: 1767:	  /*
        -: 1768:	     Use the global holiday management functions.
        -: 1769:	   */
        1: 1770:	  if (hdy_astronomical)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1771:	    astronomical_hdy (&init_data, detected, year, &hd_elems, fday,
call    0 never executed
        -: 1772:			      count);
        1: 1773:	  if (hdy_bahai)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1774:	    bahai_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1775:		       NULL);
        1: 1776:	  if (hdy_celtic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1777:	    celtic_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1778:			NULL);
        1: 1779:	  if (hdy_chinese_flexible)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1780:	    chinese_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1781:			 NULL, TRUE);
        1: 1782:	  if (hdy_chinese)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1783:	    chinese_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1784:			 NULL, FALSE);
        1: 1785:	  if (hdy_christian)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1786:	    christian_hdy (&init_data, detected, easter, year, &hd_elems,
call    0 never executed
        -: 1787:			   fday, count);
        1: 1788:	  if (hdy_hebrew)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1789:	    hebrew_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1790:			NULL);
        1: 1791:	  if (hdy_islamic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1792:	    islamic_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1793:			 NULL);
        1: 1794:	  if (hdy_japanese_flexible)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1795:	    japanese_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1796:			  NULL, TRUE);
        1: 1797:	  if (hdy_japanese)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1798:	    japanese_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1799:			  NULL, FALSE);
        1: 1800:	  if (hdy_multicultural_new_year)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1801:	    multicultural_new_year_hdy (&init_data, detected, year, &hd_elems,
call    0 never executed
        -: 1802:					fday, count);
        1: 1803:	  if (hdy_orthodox_new)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1804:	    orthodox_hdy (&init_data, detected, easter, year, &hd_elems, fday,
call    0 never executed
        -: 1805:			  count, NULL, TRUE);
        1: 1806:	  if (hdy_orthodox_old)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1807:	    orthodox_hdy (&init_data, detected, easter, year, &hd_elems, fday,
call    0 never executed
        -: 1808:			  count, NULL, FALSE);
        1: 1809:	  if (hdy_persian)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1810:	    persian_hdy (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1811:			 NULL);
        1: 1812:	  if (hdy_zodiacal_marker)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1813:	    zodiacal_marker_hdy (&init_data, detected, year, &hd_elems, fday,
call    0 never executed
        -: 1814:				 count);
        1: 1815:	  if (mth_bahai)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1816:	    bahai_mth (&init_data, detected, year, &hd_elems, fday, count);
call    0 never executed
        1: 1817:	  if (mth_chinese_flexible)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1818:	    chinese_mth (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1819:			 TRUE, TRUE);
        1: 1820:	  if (mth_chinese)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1821:	    chinese_mth (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1822:			 FALSE, TRUE);
        1: 1823:	  if (mth_coptic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1824:	    coptic_mth (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1825:			TRUE);
        1: 1826:	  if (mth_ethiopic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1827:	    coptic_mth (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1828:			FALSE);
        1: 1829:	  if (mth_french_revolutionary)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1830:	    french_revolutionary_mth (&init_data, detected, year, &hd_elems,
call    0 never executed
        -: 1831:				      fday, count);
        1: 1832:	  if (mth_hebrew)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1833:	    hebrew_mth (&init_data, detected, year, &hd_elems, fday, count);
call    0 never executed
        1: 1834:	  if (mth_indian_civil)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1835:	    indian_civil_mth (&init_data, detected, year, &hd_elems, fday,
call    0 never executed
        -: 1836:			      count);
        1: 1837:	  if (mth_islamic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1838:	    islamic_mth (&init_data, detected, year, &hd_elems, fday, count);
call    0 never executed
        1: 1839:	  if (mth_japanese_flexible)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1840:	    chinese_mth (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1841:			 TRUE, FALSE);
        1: 1842:	  if (mth_japanese)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1843:	    chinese_mth (&init_data, detected, year, &hd_elems, fday, count,
call    0 never executed
        -: 1844:			 FALSE, FALSE);
        1: 1845:	  if (mth_old_armenic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1846:	    old_egyptic_mth (&init_data, detected, year, &hd_elems, fday,
call    0 never executed
        -: 1847:			     count, FALSE);
        1: 1848:	  if (mth_old_egyptic)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1849:	    old_egyptic_mth (&init_data, detected, year, &hd_elems, fday,
call    0 never executed
        -: 1850:			     count, TRUE);
        1: 1851:	  if (mth_persian)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1852:	    persian_mth (&init_data, detected, year, &hd_elems, fday, count);
call    0 never executed
        1: 1853:	  if (cc != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1854:	    {
        -: 1855:	      /*
        -: 1856:	         Use the country specific holiday management functions.
        -: 1857:	       */
    #####: 1858:	      ptr_char = cc;
        -: 1859:	      do
        -: 1860:		{
        -: 1861:		  /*
        -: 1862:		     Copy a single country code id into `s1'.
        -: 1863:		   */
    #####: 1864:		  k = 0;
    #####: 1865:		  while (*ptr_char && (*ptr_char != *CONNECT_SEP))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1866:		    s1[k++] = *ptr_char++;
    #####: 1867:		  s1[k] = '\0';
    #####: 1868:		  ptr_cc = binsearch_cc_id (s1);
call    0 never executed
    #####: 1869:		  if (ptr_cc == (Cc_struct *) NULL)
branch  0 never executed
branch  1 never executed
        -: 1870:		    /*
        -: 1871:		       This case MUST be an internal error (`cc_holidays[]' corrupt')!
        -: 1872:		     */
    #####: 1873:		    abort ();
call    0 never executed
        -: 1874:		  else
    #####: 1875:		    (*ptr_cc->Cc_hdy_handler) (&init_data, detected, easter,
call    0 never executed
        -: 1876:					       year, &hd_elems, fday, count);
        -: 1877:		  /*
        -: 1878:		     Now skip a possibly trailing CONNECT_SEP.
        -: 1879:		   */
    #####: 1880:		  if (*ptr_char)
branch  0 never executed
branch  1 never executed
    #####: 1881:		    ptr_char++;
        -: 1882:		}
    #####: 1883:	      while (*ptr_char);
branch  0 never executed
branch  1 never executed
        -: 1884:	    }
        1: 1885:	  if (fiscal_month > MONTH_MIN)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1886:	    {
    #####: 1887:	      year++;
    #####: 1888:	      is_leap_year = (days_of_february (year) == 29);
call    0 never executed
        -: 1889:	    }
        -: 1890:	}
        1: 1891:      while (count);
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        1: 1892:      if (fiscal_month > MONTH_MIN)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1893:	{
    #####: 1894:	  is_leap_year = j;
    #####: 1895:	  year = i;
        -: 1896:	}
        -: 1897:    }
        1: 1898:  if (hd_elems && holiday_flag)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -: 1899:    {
        -: 1900:      /*
        -: 1901:         At last, sort the eternal holiday dates only if they are not presorted.
        -: 1902:       */
    #####: 1903:      if (hd_elems > 1)
branch  0 never executed
branch  1 never executed
        -: 1904:	{
    #####: 1905:	  if (!is_presorted (hd_table, hd_elems))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1906:	    {
    #####: 1907:	      if (hd_sort_des_flag)
branch  0 never executed
branch  1 never executed
    #####: 1908:		qsort ((VOID_PTR) hd_table, hd_elems, sizeof *hd_table,
call    0 never executed
        -: 1909:		       (Cmp_func) des_sort);
        -: 1910:	      else
    #####: 1911:		qsort ((VOID_PTR) hd_table, hd_elems, sizeof *hd_table,
call    0 never executed
        -: 1912:		       (Cmp_func) asc_sort);
        -: 1913:	    }
    #####: 1914:	  else if (hd_sort_des_flag)
branch  0 never executed
branch  1 never executed
        -: 1915:	    /*
        -: 1916:	       `hd_table[]' is presorted and must be shown in descending sort order,
        -: 1917:	       rearrange its internal sort order from ascending to descending sort order.
        -: 1918:	     */
    #####: 1919:	    reverse_order (hd_table, hd_elems);
call    0 never executed
        -: 1920:	}
        -: 1921:    }
        1: 1922:  else if (!detected)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1923:    {
        -: 1924:      register int n;
        -: 1925:      register int lym;
    #####: 1926:      register int m2 = fiscal_month + 1;
    #####: 1927:      register int m3 = fiscal_month + 2;
    #####: 1928:      register int tmp_month = month;
    #####: 1929:      auto Bool hd_title_shown = FALSE;
    #####: 1930:      auto Bool tmp_ify = is_fiscal_year;
        -: 1931:
        -: 1932:
        -: 1933:      /*
        -: 1934:         Display leading title text for a current year.
        -: 1935:       */
    #####: 1936:      if (hd_title_flag
branch  0 never executed
branch  1 never executed
        -: 1937:#if USE_RC
    #####: 1938:	  && !is_1month_mode && !is_2month_mode
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1939:#endif
    #####: 1940:	  && ((!is_3month_mode
branch  0 never executed
branch  1 never executed
    #####: 1941:	       && !is_3month_mode2
branch  0 never executed
branch  1 never executed
    #####: 1942:	       && ((!is_fiscal_year
branch  0 never executed
branch  1 never executed
    #####: 1943:		    && !month)
branch  0 never executed
branch  1 never executed
    #####: 1944:		   || (is_fiscal_year
branch  0 never executed
branch  1 never executed
    #####: 1945:		       && (fiscal_month == MONTH_MIN))))
branch  0 never executed
branch  1 never executed
    #####: 1946:	      || is_3month_mode2
branch  0 never executed
branch  1 never executed
    #####: 1947:	      || (is_3month_mode && (fiscal_month < MONTH_MAX - 1))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1948:	{
        -: 1949:	  /*
        -: 1950:	     Now display a leading NEWLINE character before the title text
        -: 1951:	     only if not explicitly suppressed by a `-G' command line
        -: 1952:	     option given.
        -: 1953:	   */
    #####: 1954:	  *s1 = '\0';
    #####: 1955:	  if (!hd_suppr_list_sep_flag)
branch  0 never executed
branch  1 never executed
    #####: 1956:	    print_text (stdout, s1);
call    0 never executed
    #####: 1957:	  if (hd_title_flag)
branch  0 never executed
branch  1 never executed
        -: 1958:	    {
        -: 1959:	      /*
        -: 1960:	         Now display the leading title text only if not explicitly
        -: 1961:	         suppressed by a `-X' command line option given.
        -: 1962:	       */
    #####: 1963:	      lym = len_year_max;
    #####: 1964:	      if (transform_year)
branch  0 never executed
branch  1 never executed
        -: 1965:		{
    #####: 1966:		  n = year - transform_year;
    #####: 1967:		  if ((n >= 0) && (transform_year > 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1968:		    n++;
    #####: 1969:		  if (abs (n) > YEAR_MAX)
branch  0 never executed
branch  1 never executed
    #####: 1970:		    lym++;
        -: 1971:		}
        -: 1972:	      else
    #####: 1973:		n = year;
    #####: 1974:	      i = (int) strlen (_("Eternal holiday list"));
    #####: 1975:	      if (use_year_zeroleaded)
branch  0 never executed
branch  1 never executed
        -: 1976:		{
    #####: 1977:		  if (is_leap_year)
branch  0 never executed
branch  1 never executed
    #####: 1978:		    sprintf (s1, _("%s:%*sThe year %0*d is A leap year"),
        -: 1979:			     _("Eternal holiday list"), LEN_HD_NAME - i + 2,
        -: 1980:			     "", lym, n);
        -: 1981:		  else
    #####: 1982:		    sprintf (s1, _("%s:%*sThe year %0*d is NO leap year"),
        -: 1983:			     _("Eternal holiday list"), LEN_HD_NAME - i + 2,
        -: 1984:			     "", lym, n);
        -: 1985:		}
        -: 1986:	      else
        -: 1987:		{
    #####: 1988:		  if (is_leap_year)
branch  0 never executed
branch  1 never executed
    #####: 1989:		    sprintf (s1, _("%s:%*sThe year %d is A leap year"),
        -: 1990:			     _("Eternal holiday list"), LEN_HD_NAME - i + 2,
        -: 1991:			     "", n);
        -: 1992:		  else
    #####: 1993:		    sprintf (s1, _("%s:%*sThe year %d is NO leap year"),
        -: 1994:			     _("Eternal holiday list"), LEN_HD_NAME - i + 2,
        -: 1995:			     "", n);
        -: 1996:		}
    #####: 1997:	      print_text (stdout, s1);
call    0 never executed
    #####: 1998:	      if (hd_table[0] != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1999:		print_text (stdout, s1);
call    0 never executed
        -: 2000:	    }
    #####: 2001:	  hd_title_shown = TRUE;
        -: 2002:	}
        -: 2003:      /*
        -: 2004:         Now display the (complete) eternal holiday list.
        -: 2005:       */
    #####: 2006:      if (is_3month_mode
branch  0 never executed
branch  1 never executed
        -: 2007:#if USE_RC
    #####: 2008:	  || is_1month_mode || is_2month_mode
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2009:#endif
    #####: 2010:	  || is_3month_mode2)
branch  0 never executed
branch  1 never executed
        -: 2011:	{
        -: 2012:	  /*
        -: 2013:	     Set the range of the 2|3 months, which have to be respected.
        -: 2014:	   */
    #####: 2015:	  if (fiscal_month >= MONTH_MAX - 1)
branch  0 never executed
branch  1 never executed
        -: 2016:	    {
    #####: 2017:	      m3 = MONTH_MIN;
    #####: 2018:	      if (fiscal_month == MONTH_MAX)
branch  0 never executed
branch  1 never executed
        -: 2019:		{
    #####: 2020:		  m2 = MONTH_MIN;
    #####: 2021:		  m3++;
        -: 2022:		}
        -: 2023:	    }
    #####: 2024:	  is_fiscal_year = FALSE;
    #####: 2025:	  month = fiscal_month;
        -: 2026:	}
    #####: 2027:      i = j = 0;
    #####: 2028:      while ((hd_table[i] != (char *) NULL) && (i < HD_ELEMS_MAX))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2029:	{
        -: 2030:	  /*
        -: 2031:	     One month resp., 2|3-month calendar mode:
        -: 2032:	     Get holiday month of holiday text.
        -: 2033:	   */
    #####: 2034:	  if (is_3month_mode
branch  0 never executed
branch  1 never executed
        -: 2035:#if USE_RC
    #####: 2036:	      || is_1month_mode || is_2month_mode
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2037:#endif
    #####: 2038:	      || is_3month_mode2 || (month && !is_fiscal_year))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2039:	    {
    #####: 2040:	      s1[0] = hd_table[i][len_year_max];
    #####: 2041:	      s1[1] = hd_table[i][len_year_max + 1];
    #####: 2042:	      s1[2] = '\0';
    #####: 2043:	      j = my_atoi (s1);
call    0 never executed
        -: 2044:	    }
        -: 2045:	  /*
        -: 2046:	     Display dates of eternal holiday list:
        -: 2047:	     Year calendar  --> Display all eternal holidays.
        -: 2048:	     Month calendar --> Display only those eternal holidays
        -: 2049:	     which refer to current month.
        -: 2050:	   */
    #####: 2051:	  if (is_fiscal_year || !month || month == j
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2052:#if USE_RC
    #####: 2053:	      || (is_1month_mode
branch  0 never executed
branch  1 never executed
    #####: 2054:		  && (month == j)) || (is_2month_mode && (j == m2))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2055:#endif
    #####: 2056:	      || ((is_3month_mode
branch  0 never executed
branch  1 never executed
    #####: 2057:		   || is_3month_mode2) && (j == m2 || j == m3)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2058:	    {
    #####: 2059:	      if (!hd_legal_days_only
branch  0 never executed
branch  1 never executed
    #####: 2060:		  || (hd_legal_days_only
branch  0 never executed
branch  1 never executed
    #####: 2061:		      &&
branch  0 never executed
branch  1 never executed
    #####: 2062:		      (*(*(hd_table + i) + LEN_HD_NAME + len_year_max + 4 + 2)
    #####: 2063:		       != *DIS_HLS_PREF)
    #####: 2064:		      &&
branch  0 never executed
branch  1 never executed
    #####: 2065:		      (*(*(hd_table + i) + LEN_HD_NAME + len_year_max + 4 + 2)
    #####: 2066:		       != *DIS_HLS_PREF2)))
        -: 2067:		{
        -: 2068:		  /*
        -: 2069:		     Month calendar mode:
        -: 2070:		     Display a leading NEWLINE character only in case
        -: 2071:		     an eternal holiday refers to the current month.
        -: 2072:		   */
    #####: 2073:		  if (!hd_title_shown)
branch  0 never executed
branch  1 never executed
        -: 2074:		    {
        -: 2075:		      /*
        -: 2076:		         Now display a leading NEWLINE character before the
        -: 2077:		         title text only if not explicitly suppressed by
        -: 2078:		         a `-G' command line option given.
        -: 2079:		       */
    #####: 2080:		      *s1 = '\0';
    #####: 2081:		      if (!hd_suppr_list_sep_flag)
branch  0 never executed
branch  1 never executed
    #####: 2082:			print_text (stdout, s1);
call    0 never executed
    #####: 2083:		      if (hd_title_flag)
branch  0 never executed
branch  1 never executed
        -: 2084:			{
        -: 2085:			  /*
        -: 2086:			     Now display the leading title text only if not
        -: 2087:			     explicitly suppressed by a `-X' command line
        -: 2088:			     option given.
        -: 2089:			   */
    #####: 2090:			  sprintf (s1, "%s:", _("Eternal holiday list"));
    #####: 2091:			  print_text (stdout, s1);
call    0 never executed
    #####: 2092:			  print_text (stdout, s1);
call    0 never executed
        -: 2093:			}
    #####: 2094:		      hd_title_shown = TRUE;
        -: 2095:		    }
        -: 2096:		  /*
        -: 2097:		     Display the eternal holiday text.
        -: 2098:		   */
    #####: 2099:		  sprintf (s1, "%s", *(hd_table + i) + len_year_max + 4 + 1);
    #####: 2100:		  print_text (stdout, s1);
call    0 never executed
        -: 2101:		}
        -: 2102:	    }
    #####: 2103:	  free (hd_table[i]);
    #####: 2104:	  hd_table[i++] = (char *) NULL;
        -: 2105:	}
    #####: 2106:      if (is_3month_mode
branch  0 never executed
branch  1 never executed
        -: 2107:#if USE_RC
    #####: 2108:	  || is_1month_mode || is_2month_mode
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2109:#endif
    #####: 2110:	  || is_3month_mode2)
branch  0 never executed
branch  1 never executed
        -: 2111:	{
    #####: 2112:	  month = tmp_month;
    #####: 2113:	  is_fiscal_year = tmp_ify;
        -: 2114:	}
        -: 2115:    }
        1: 2116:}
        -: 2117:
        -: 2118:
        -: 2119:
        -: 2120:void
function holiday called 0 returned 0% blocks executed 0%
    #####: 2121:holiday (init_data, detected, holiday_name, country_code, holiday_prefix,
        -: 2122:	 day, month, year, hd_elems, fday, count)
        -: 2123:     Bool init_data;
        -: 2124:     const Bool detected;
        -: 2125:     const char *holiday_name;
        -: 2126:     const char *country_code;
        -: 2127:     const char *holiday_prefix;
        -: 2128:     int day;
        -: 2129:     int month;
        -: 2130:     const int year;
        -: 2131:     int *hd_elems;
        -: 2132:     const int fday;
        -: 2133:     const int count;
        -: 2134:/*!
        -: 2135:   Generates a single holiday date text in formatted manner and stores the
        -: 2136:     result into global `hd_table[]'.
        -: 2137:     ONLY if `holiday_prefix' is a '-' (DIS_HLS_PREF) or '*' (DIS_HLS_PREF2)
        -: 2138:     character, this holiday is not stored into global `hd_ldays' and
        -: 2139:     will not be highlighted in the generated list, but is stored into
        -: 2140:     global `hd_mdays'!
        -: 2141:     If `holiday_prefix' is a '#' character, this marks the case the
        -: 2142:     holiday is only valid in some parts of the country, but is stored
        -: 2143:     into global `hd_ldays' and will be highlighted in the generated list.
        -: 2144:     If `holiday_prefix' is a '\0' or any other character, the same rules
        -: 2145:     concering to '#' character applies.
        -: 2146:     If `month' is set to zero, it's assumed that the delivered date is a
        -: 2147:     date relative to the Easter Sunday's date (`day' contains the according
        -: 2148:     day_of_year number), otherwise the date is an absolute date of the `year'.
        -: 2149:*/
        -: 2150:{
    #####: 2151:  register int i = day;
        -: 2152:  register int hd;
        -: 2153:  register int hd2;
        -: 2154:
        -: 2155:
    #####: 2156:  if (!month)
branch  0 never executed
branch  1 never executed
    #####: 2157:    (void) doy2date (i, is_leap_year, &day, &month);
call    0 never executed
    #####: 2158:  if (month == 2)
branch  0 never executed
branch  1 never executed
    #####: 2159:    i = is_leap_year;
        -: 2160:  else
    #####: 2161:    i = 0;
    #####: 2162:  hd = hd2 = day_of_year (day, month, year);
call    0 never executed
    #####: 2163:  if ((year >= EASTER_MIN)
branch  0 never executed
branch  1 never executed
    #####: 2164:      && (year <= EASTER_MAX)
branch  0 never executed
branch  1 never executed
    #####: 2165:      && (day >= DAY_MIN)
branch  0 never executed
branch  1 never executed
    #####: 2166:      && (day <= dvec[month - 1] + i)
branch  0 never executed
branch  1 never executed
    #####: 2167:      && (!fday
branch  0 never executed
branch  1 never executed
    #####: 2168:	  || (count
branch  0 never executed
branch  1 never executed
    #####: 2169:	      && (hd >= fday))
branch  0 never executed
branch  1 never executed
    #####: 2170:	  || (!count && (hd < fday - (days_of_february (year - 1) == 29)))))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 2171:    {
    #####: 2172:      if (holiday_flag
branch  0 never executed
branch  1 never executed
        -: 2173:#if USE_RC
    #####: 2174:	  || rc_enable_hda_flag || rc_enable_hdl_flag
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2175:#endif
        -: 2176:	)
        -: 2177:	{
    #####: 2178:	  register int d = day;
        -: 2179:
        -: 2180:
    #####: 2181:	  sprintf (s1, " (%s)", country_code);
    #####: 2182:	  i = (int) strlen (s1);
    #####: 2183:	  strncpy (s2, holiday_name, LEN_HD_NAME - i);
    #####: 2184:	  s2[LEN_HD_NAME - i - 1] = '\0';
    #####: 2185:	  strcat (s2, s1);
    #####: 2186:	  sprintf (s1, "%0*d%02d%02d %-*s  %1s ",
        -: 2187:		   len_year_max, year, month, day, LEN_HD_NAME - 1, s2,
        -: 2188:		   holiday_prefix);
    #####: 2189:	  strcpy (s2, s1);
    #####: 2190:	  i =
        -: 2191:	    hd -
    #####: 2192:	    ((cal_special_flag) ? act_day :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2193:	     day_of_year (act_day, act_month, act_year));
    #####: 2194:	  if (!hd_both_dates_flag)
branch  0 never executed
branch  1 never executed
        -: 2195:	    {
    #####: 2196:	      if (!hd_special_flag)
branch  0 never executed
branch  1 never executed
    #####: 2197:		hd2 = 0;
        -: 2198:	      else
    #####: 2199:		d = 0;
        -: 2200:	    }
    #####: 2201:	  if (!i && (year == act_year))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2202:	    (void) decode_date_format (date_format->df_format, &s2, d, month,
call    0 never executed
        -: 2203:				       year, hd2, TRUE, FALSE, TRUE);
    #####: 2204:	  else if ((*holiday_prefix != *DIS_HLS_PREF)
branch  0 never executed
branch  1 never executed
    #####: 2205:		   && (*holiday_prefix != *DIS_HLS_PREF2))
branch  0 never executed
branch  1 never executed
    #####: 2206:	    (void) decode_date_format (date_format->df_format, &s2, d, month,
call    0 never executed
        -: 2207:				       year, hd2, FALSE, TRUE, TRUE);
        -: 2208:	  else
    #####: 2209:	    (void) decode_date_format (date_format->df_format, &s2, d, month,
call    0 never executed
        -: 2210:				       year, hd2, FALSE, FALSE, TRUE);
        -: 2211:	  /*
        -: 2212:	     Add the day displacement, which is relative to the "actual date"
        -: 2213:	     to the eternal holiday text.
        -: 2214:	   */
    #####: 2215:	  if ((fday
branch  0 never executed
branch  1 never executed
    #####: 2216:	       && (((year == act_year - 1)
branch  0 never executed
branch  1 never executed
    #####: 2217:		    && (month >= fiscal_month))
branch  0 never executed
branch  1 never executed
    #####: 2218:		   || ((year == act_year + 1)
branch  0 never executed
branch  1 never executed
    #####: 2219:		       && (month < fiscal_month)))) || year == act_year)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2220:	    {
    #####: 2221:	      if (fday && (year != act_year))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2222:		{
    #####: 2223:		  if (year == act_year - 1)
branch  0 never executed
branch  1 never executed
        -: 2224:		    /*
        -: 2225:		       Eternal holiday to compute is in "actual year - 1".
        -: 2226:		     */
    #####: 2227:		    i = hd - (DAY_LAST + is_leap_year
    #####: 2228:			      +
    #####: 2229:			      ((cal_special_flag) ? act_day :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2230:			       day_of_year (act_day, act_month, act_year)));
        -: 2231:		  else
        -: 2232:		    /*
        -: 2233:		       Eternal holiday to compute is in "actual year + 1".
        -: 2234:		     */
    #####: 2235:		    i = hd + (DAY_LAST + (days_of_february (act_year) == 29)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 2236:			      -
    #####: 2237:			      ((cal_special_flag) ? act_day :
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2238:			       day_of_year (act_day, act_month, act_year)));
        -: 2239:		}
    #####: 2240:	      if (i)
branch  0 never executed
branch  1 never executed
        -: 2241:		{
    #####: 2242:		  if (abs (i) == 1)
branch  0 never executed
branch  1 never executed
    #####: 2243:		    sprintf (s1, _(" = %+4d day"), i);
        -: 2244:		  else
    #####: 2245:		    sprintf (s1, _(" = %+4d days"), i);
    #####: 2246:		  strcat (s2, s1);
        -: 2247:		}
        -: 2248:	    }
        -: 2249:	  /*
        -: 2250:	     Store the constructed "raw" line in `hd_table[]'.
        -: 2251:	   */
    #####: 2252:	  if (*hd_elems < HD_ELEMS_MAX)
branch  0 never executed
branch  1 never executed
        -: 2253:	    {
    #####: 2254:	      hd_table[*hd_elems] = (char *) my_malloc (strlen (s2) + 1,
call    0 never executed
        -: 2255:							ERR_NO_MEMORY_AVAILABLE,
        -: 2256:							__FILE__,
        -: 2257:							((long) __LINE__) -
        -: 2258:							2L,
        -: 2259:							"hd_table[hd_elems]",
        -: 2260:							*hd_elems);
    #####: 2261:	      strcpy (hd_table[(*hd_elems)++], s2);
        -: 2262:	    }
        -: 2263:	}
        -: 2264:      /*
        -: 2265:         This case can occur only, if the code was extended by more
        -: 2266:         eternal holidays and the table size for `hd_table[]', namely
        -: 2267:         HD_ELEMS_MAX, isn't increased/adjusted correctly so this
        -: 2268:         warning/informational is for maintainers only!!
        -: 2269:       */
    #####: 2270:      if ((warning_level >= 0) && (*hd_elems >= HD_ELEMS_MAX))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2271:	{
    #####: 2272:	  sprintf (s1, _("%s%s contains %d maximum entries now!%s"),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2273:		   ((ehls1s.len != 1) ? ehls1s.seq : ""),
        -: 2274:		   _("Eternal holiday list"), HD_ELEMS_MAX,
    #####: 2275:		   ((ehls1s.len != 1) ? ehls1e.seq : ""));
    #####: 2276:	  print_text (stderr, s1);
call    0 never executed
        -: 2277:	}
    #####: 2278:      if (init_data)
branch  0 never executed
branch  1 never executed
    #####: 2279:	for (i = 0; i < HD_MAX; i++)
branch  0 never executed
branch  1 never executed
    #####: 2280:	  hd_ldays[i] = hd_mdays[i] = '\0';
    #####: 2281:      if (detected)
branch  0 never executed
branch  1 never executed
        -: 2282:	{
    #####: 2283:	  if (*holiday_prefix == *DIS_HLS_PREF
branch  0 never executed
branch  1 never executed
    #####: 2284:	      || *holiday_prefix == *DIS_HLS_PREF2)
branch  0 never executed
branch  1 never executed
    #####: 2285:	    hd_mdays[((month - 1) * MONTH_LAST) + (day - 1)] = '@';
        -: 2286:	  else
    #####: 2287:	    hd_ldays[((month - 1) * MONTH_LAST) + (day - 1)] = '@';
        -: 2288:	}
        -: 2289:    }
    #####: 2290:  else if (init_data)
branch  0 never executed
branch  1 never executed
    #####: 2291:    for (i = 0; i < HD_MAX; i++)
branch  0 never executed
branch  1 never executed
    #####: 2292:      hd_ldays[i] = hd_mdays[i] = '\0';
    #####: 2293:}
