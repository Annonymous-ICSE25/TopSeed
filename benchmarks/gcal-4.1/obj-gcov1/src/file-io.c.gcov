        -:    0:Source:../../src/file-io.c
        -:    0:Programs:20
        -:    1:/*!
        -:    2:*  \file file-io.c
        -:    3:*  \brief Managing and accessing resource, include and response files.
        -:    4:*/
        -:    5:/*
        -:    6:*  Copyright (c) 1994, 95, 96, 1997, 2000, 2011 Thomas Esken
        -:    7:*  Copyright (c) 2010, 2011, 2013 Free Software Foundation, Inc.
        -:    8:*
        -:    9:*  This software doesn't claim completeness, correctness or usability.
        -:   10:*  On principle I will not be liable for ANY damages or losses (implicit
        -:   11:*  or explicit), which result from using or handling my software.
        -:   12:*  If you use this software, you agree without any exception to this
        -:   13:*  agreement, which binds you LEGALLY !!
        -:   14:*
        -:   15:*  This program is free software; you can redistribute it and/or modify
        -:   16:*  it under the terms of the `GNU General Public License' as published by
        -:   17:*  the `Free Software Foundation'; either version 3, or (at your option)
        -:   18:*  any later version.
        -:   19:*
        -:   20:*  You should have received a copy of the `GNU General Public License'
        -:   21:*  along with this program; if not, write to the:
        -:   22:*
        -:   23:*/
        -:   24:
        -:   25:
        -:   26:
        -:   27:/*
        -:   28:*  Include header files.
        -:   29:*/
        -:   30:#include "tailor.h"
        -:   31:#if HAVE_CTYPE_H
        -:   32:# include <ctype.h>
        -:   33:#endif
        -:   34:#ifdef GCAL_SHELL
        -:   35:# if HAVE_UNISTD_H
        -:   36:#  include <unistd.h>
        -:   37:# endif
        -:   38:#endif
        -:   39:#if HAVE_SYS_STAT_H
        -:   40:# if HAVE_SYS_TYPES_H
        -:   41:#  include <sys/types.h>
        -:   42:# endif
        -:   43:# include <sys/stat.h>
        -:   44:#endif
        -:   45:#include "common.h"
        -:   46:#if USE_RC
        -:   47:# include "rc-defs.h"
        -:   48:#endif /* !USE_RC */
        -:   49:#include "globals.h"
        -:   50:#include "gcal.h"
        -:   51:#include "hd-defs.h"
        -:   52:#include "hd-use.h"
        -:   53:#if USE_RC
        -:   54:# include "rc-utils.h"
        -:   55:#endif
        -:   56:#include "tty.h"
        -:   57:#include "utils.h"
        -:   58:#include "file-io.h"
        -:   59:
        -:   60:
        -:   61:
        -:   62:/*
        -:   63:*  static functions prototypes.
        -:   64:*/
        -:   65:__BEGIN_DECLARATIONS
        -:   66:/*
        -:   67:************************************************** Defined in `file-io.c'.
        -:   68:*/
        -:   69:static void
        -:   70:  make_absolute_filename __P_ ((char **absolute_filename,
        -:   71:				const char *directory, const char *filename));
        -:   72:static FILE *get_file_ptr __P_ ((FILE * fp,
        -:   73:				 const char *filename,
        -:   74:				 const int level,
        -:   75:				 const Fmode_enum mode, Bool * is_first));
        -:   76:__END_DECLARATIONS
        -:   77:/*
        -:   78:*  Function implementations.
        -:   79:*/
function file_open called 2 returned 100% blocks executed 52%
        2:   80:  FILE * file_open (filename, level, mode, bad_sys_include)
        -:   81:     char **
        -:   82:       filename;
        -:   83:     const int
        -:   84:       level;
        -:   85:     const Fmode_enum
        -:   86:       mode;
        -:   87:     Bool *
        -:   88:       bad_sys_include;
        -:   89:/*!
        -:   90:   Tries to open a resource/response file (MODE == `REsource', `REsponse')
        -:   91:     in the following order:
        -:   92:       1) $GCALPATH
        -:   93:       2) $HOME
        -:   94:       3) $GCAL_USR_DATADIR (environment variable first; default name if unset)
        -:   95:       4) $GCAL_SYS_DATADIR (environment variable first; default name if unset)
        -:   96:     and returns a file pointer to this file and it's MODIFIED name in some
        -:   97:     cases (due to this, it's necessary to reallocate the memory area of
        -:   98:     `&filename', which must be allocated on the heap), otherwise return a NULL pointer.
        -:   99:   If MODE is set to `USr_include', this function tries to open an
        -:  100:     include file (#include "file" directive found) in:
        -:  101:       1) actual directory
        -:  102:       2) $GCALPATH
        -:  103:       3) $HOME
        -:  104:       4) $GCAL_USR_DATADIR (environment variable first; default name if unset)
        -:  105:       5) $GCAL_SYS_DATADIR (environment variable first; default name if unset)
        -:  106:     and returns a file pointer to this file and it's MODIFIED name in some
        -:  107:     cases (due to this, it's necessary to reallocate the memory area of
        -:  108:     `&filename', which must be allocated on the heap), otherwise return a NULL pointer.
        -:  109:     If a root directory based include file name is given, set `&bad_sys_include'
        -:  110:     to TRUE!
        -:  111:   If MODE is set to `SYs_include', this function tries to open an
        -:  112:     include file (#include <file> directive found) only in:
        -:  113:       1) $GCAL_USR_DATADIR (environment variable first; default name if unset)
        -:  114:       2) $GCAL_SYS_DATADIR (environment variable first; default name if unset)
        -:  115:     and returns a file pointer to this file and it's MODIFIED name in some
        -:  116:     cases (due to this, it's necessary to reallocate the memory area of
        -:  117:     `&filename', which must be allocated on the heap), otherwise return a NULL pointer.
        -:  118:     If a root directory based include file name is given, set `&bad_sys_include'
        -:  119:     to TRUE!
        -:  120:   If MODE is set to `HEre', this function tries to open a
        -:  121:     "here" file (`--here=ARG' option) in
        -:  122:       1) actual directory
        -:  123:     and returns a file pointer to this file and it's name,
        -:  124:     otherwise return a NULL pointer.
        -:  125:   If MODE is set to `COmmon', this function tries to open a
        -:  126:     common file in
        -:  127:       1) $PATH
        -:  128:     and returns a file pointer to this file and it's name,
        -:  129:     otherwise return a NULL pointer.
        -:  130:   Passes the nesting LEVEL only for informational purposes to other functions called here.
        -:  131:   NO informational messages will be emitted in `REsponse' and `COmmon' modes!!
        -:  132:*/
        -:  133:{
        2:  134:  auto FILE *fp = (FILE *) NULL;
        -:  135:  register int len;
        -:  136:  auto char *ptr_env;
        -:  137:  auto char *ptr_char;
        2:  138:  auto Bool is_absolute_filename = FALSE;
        -:  139:#if USE_RC
        2:  140:  auto Bool is_root_based_filename = FALSE;
        2:  141:  auto Bool is_disk_given = FALSE;
        2:  142:  auto Bool is_first = (Bool) ((mode == REsource) ? TRUE : FALSE);
        -:  143:#else /* !USE_RC */
        -:  144:  auto Bool is_first = FALSE;
        -:  145:#endif /* !USE_RC */
        -:  146:
        -:  147:
        2:  148:  len = (int) strlen (*filename);
        2:  149:  if ((Uint) len >= maxlen_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  150:    resize_all_strings (len + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
        2:  151:  strcpy (s1, *filename);
        2:  152:  ptr_char = *filename;
        -:  153:#ifdef DISK_SEP
        -:  154:  ptr_char = strchr (*filename, *DISK_SEP);
        -:  155:  if (ptr_char != (char *) NULL)
        -:  156:    {
        -:  157:      /*
        -:  158:         If a disk/drive is specified, this is like an absolute file name!
        -:  159:       */
        -:  160:      is_absolute_filename = TRUE;
        -:  161:# if USE_RC
        -:  162:      is_disk_given = TRUE;
        -:  163:# endif
        -:  164:      ptr_char++;
        -:  165:    }
        -:  166:  else
        -:  167:    ptr_char = *filename;
        -:  168:#endif /* DISK_SEP */
        -:  169:#if USE_RC
        -:  170:  /*
        -:  171:     Check if an absolute file name is given.
        -:  172:   */
        2:  173:  if (*ptr_char == *DIR_SEP || *ptr_char == *ACTUAL_DIR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -:  174:    {
        2:  175:      if (*ptr_char == *ACTUAL_DIR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  176:	{
        3:  177:	  while (*ptr_char == *ACTUAL_DIR)
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        1:  178:	    ptr_char++;
        1:  179:	  if (*ptr_char == *DIR_SEP)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  180:	    {
    #####:  181:	      is_absolute_filename = TRUE;
    #####:  182:	      ptr_char--;
        -:  183:	    }
        -:  184:	}
        -:  185:      else
    #####:  186:	is_absolute_filename = TRUE;
        -:  187:    }
        -:  188:  else
        -:  189:    /*
        -:  190:       Check if STDIN channel is wanted.
        -:  191:     */
        1:  192:  if ((*ptr_char == '-') && (len == 1))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  193:    is_absolute_filename = TRUE;
        2:  194:  if (*ptr_char == *DIR_SEP)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  195:    is_root_based_filename = TRUE;
        2:  196:  if ((is_disk_given || is_root_based_filename) && (mode == SYs_include))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
        -:  197:    {
        -:  198:      /*
        -:  199:         Include files names. which are based by the root directory,
        -:  200:         are not allowed in system include statements, e.g.:
        -:  201:         #include </foo>   or   #include </foo/bar>.
        -:  202:       */
    #####:  203:      *bad_sys_include = TRUE;
    #####:  204:      return (NULL);
        -:  205:    }
        2:  206:  *bad_sys_include = FALSE;
        2:  207:  if (mode != SYs_include)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  208:#endif
        -:  209:    {
        2:  210:      if (mode != COmmon)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  211:	{
        -:  212:	  /*
        -:  213:	     Try to open the file directly (either absolute file name,
        -:  214:	     USr_include file type or HEre file type given).
        -:  215:	   */
        2:  216:	  if (is_absolute_filename
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  217:#if USE_RC
        1:  218:	      || mode == USr_include || mode == HEre
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  219:#endif
        -:  220:	    )
        -:  221:	    {
        1:  222:	      fp = get_file_ptr (fp, *filename, level, mode, &is_first);
call    0 returned 100%
        -:  223:	      /*
        -:  224:	         If the file is found, return to caller immediately.
        -:  225:	       */
        1:  226:	      if (fp != (FILE *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  227:		return (fp);
    #####:  228:	      else if (is_absolute_filename
branch  0 never executed
branch  1 never executed
        -:  229:#if USE_RC
    #####:  230:		       || mode == HEre
branch  0 never executed
branch  1 never executed
        -:  231:#endif
        -:  232:		)
        -:  233:		{
        -:  234:#if USE_RC
    #####:  235:		  if ((fp == (FILE *) NULL)
branch  0 never executed
branch  1 never executed
    #####:  236:		      && (warning_level >= WARN_LVL_MAX))
branch  0 never executed
branch  1 never executed
        -:  237:		    /*
        -:  238:		       Terminate if `--debug=abort' option is given
        -:  239:		       and the absolute file name or the `HEre' file
        -:  240:		       name isn't found.
        -:  241:		     */
    #####:  242:		    my_error (ERR_FILE_NOT_FOUND, *filename, 0L, *filename,
call    0 never executed
        -:  243:			      0);
        -:  244:#endif
    #####:  245:		  return (NULL);
        -:  246:		}
        -:  247:	    }
        -:  248:	}
        -:  249:#if !defined(AMIGA) || defined(__GNUC__)
        1:  250:      if (fp == (FILE *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  251:	{
        -:  252:	  /*
        -:  253:	     Simple file name delivered and the file isn't found:
        -:  254:	     * Either search a COmmon file in the directory/ies,
        -:  255:	     which are stored in the environment variable $PATH
        -:  256:	     * Or search all other file types in the directory/ies,
        -:  257:	     which are stored in the environment variable $GCALPATH.
        -:  258:	   */
        1:  259:	  if (mode == COmmon)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  260:	    ptr_env = getenv (ENV_VAR_PATH);
call    0 never executed
        -:  261:	  else
        1:  262:	    ptr_env = getenv (ENV_VAR_GCALPATH);
call    0 returned 100%
        1:  263:	  if (ptr_env != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  264:	    if (*ptr_env)
branch  0 never executed
branch  1 never executed
        -:  265:	      {
    #####:  266:		auto Bool ok = FALSE;
        -:  267:
        -:  268:
    #####:  269:		len = (int) strlen (ptr_env);
    #####:  270:		if ((Uint) len >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  271:		  resize_all_strings (len + 1, FALSE, __FILE__,
call    0 never executed
        -:  272:				      (long) __LINE__);
    #####:  273:		strcpy (s2, ptr_env);
    #####:  274:		while (!ok && (fp == (FILE *) NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  275:		  {
    #####:  276:		    ok =
    #####:  277:		      (Bool) ((ptr_char =
    #####:  278:			       strchr (s2, *PATH_SEP)) == (char *) NULL);
    #####:  279:		    if (ok)
branch  0 never executed
branch  1 never executed
    #####:  280:		      len = (int) strlen (s2);
        -:  281:		    else
    #####:  282:		      len = (int) strlen (s2) - strlen (ptr_char);
    #####:  283:		    strncpy (s1, s2, len);
    #####:  284:		    s1[len] = '\0';
    #####:  285:		    if (len)
branch  0 never executed
branch  1 never executed
    #####:  286:		      if (s1[len - 1] != *DIR_SEP)
branch  0 never executed
branch  1 never executed
    #####:  287:			strcat (s1, DIR_SEP);
    #####:  288:		    strcat (s1, *filename);
        -:  289:# ifdef SUFFIX_SEP
        -:  290:		    if ((ptr_char =
        -:  291:			 strchr (s1, *SUFFIX_SEP)) != (char *) NULL)
        -:  292:		      *ptr_char = '\0';
        -:  293:# endif
    #####:  294:		    if (*s1)
branch  0 never executed
branch  1 never executed
    #####:  295:		      fp = get_file_ptr (fp, s1, level, mode, &is_first);
call    0 never executed
    #####:  296:		    if (ok)
branch  0 never executed
branch  1 never executed
    #####:  297:		      break;
    #####:  298:		    ptr_char = s2 + len + 1;
    #####:  299:		    if (!*ptr_char)
branch  0 never executed
branch  1 never executed
    #####:  300:		      break;
    #####:  301:		    strcpy (s2, ptr_char);
        -:  302:		  }
        -:  303:		/*
        -:  304:		   If a file isn't found yet but the last character of the
        -:  305:		   $[GCAL]PATH environment variable is a PATH_SEP character
        -:  306:		   (which means the last search for the file must be done
        -:  307:		   in the actual directory), perform this file access!
        -:  308:		 */
    #####:  309:		if ((fp == (FILE *) NULL)
branch  0 never executed
branch  1 never executed
    #####:  310:		    && (*(ptr_env + strlen (ptr_env) - 1) == *PATH_SEP))
branch  0 never executed
branch  1 never executed
    #####:  311:		  fp = get_file_ptr (fp, *filename, level, mode, &is_first);
call    0 never executed
        -:  312:	      }
        -:  313:	}
        1:  314:      if (mode != COmmon)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  315:	{
        1:  316:	  if (fp == (FILE *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  317:	    {
        -:  318:	      /*
        -:  319:	         File not found in the $GCALPATH directory:
        -:  320:	         * Search the file in the directory, which is
        -:  321:	         stored in the environment variable of $HOME.
        -:  322:	       */
        1:  323:	      ptr_env = getenv (ENV_VAR_HOME);
call    0 returned 100%
        1:  324:	      if (ptr_env != (char *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  325:		if (*ptr_env)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  326:		  {
        1:  327:		    make_absolute_filename (&s1, ptr_env, *filename);
call    0 returned 100%
        1:  328:		    fp = get_file_ptr (fp, s1, level, mode, &is_first);
call    0 returned 100%
        -:  329:		  }
        -:  330:	    }
        -:  331:	}
        -:  332:    }
        -:  333:  /*
        -:  334:     It's not necessary to perform further searches for COmmon files
        -:  335:     in the $GCAL_???_DATADIR directories!
        -:  336:   */
        1:  337:  if (mode == COmmon)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  338:    return (fp);
        -:  339:# if USE_RC
        1:  340:  if (fp == (FILE *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  341:    {
        -:  342:      /*
        -:  343:         File not found in the $HOME directory:
        -:  344:         * Search the file in the user's library directory of
        -:  345:         $HOME/[$]GCAL_USR_DATADIR.
        -:  346:       */
        1:  347:      ptr_env = getenv (ENV_VAR_HOME);
call    0 returned 100%
        1:  348:      if (ptr_env != (char *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  349:	if (*ptr_env)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  350:	  {
        1:  351:	    ptr_char = getenv (ENV_VAR_USR_DATADIR);
call    0 returned 100%
        -:  352:	    /*
        -:  353:	       Search the file in the directory specified in the
        -:  354:	       $GCAL_USR_DATADIR environment variable first.
        -:  355:	     */
        1:  356:	    if (ptr_char != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  357:	      {
    #####:  358:		if (*ptr_char)
branch  0 never executed
branch  1 never executed
        -:  359:		  {
    #####:  360:		    make_absolute_filename (&s1, ptr_env, ptr_char);
call    0 never executed
    #####:  361:		    strcpy (s2, s1);
    #####:  362:		    make_absolute_filename (&s1, s2, *filename);
call    0 never executed
    #####:  363:		    fp = get_file_ptr (fp, s1, level, mode, &is_first);
call    0 never executed
        -:  364:		  }
        -:  365:	      }
        -:  366:	    else
        -:  367:	      {
        -:  368:		/*
        -:  369:		   If the $GCAL_USR_DATADIR environment variable is unset,
        -:  370:		   search the file in burned-in user's library directory of
        -:  371:		   GCAL_USR_DATADIR.
        -:  372:		 */
        1:  373:		make_absolute_filename (&s1, ptr_env, GCAL_USR_DATADIR);
call    0 returned 100%
        1:  374:		strcpy (s2, s1);
        1:  375:		make_absolute_filename (&s1, s2, *filename);
call    0 returned 100%
        1:  376:		fp = get_file_ptr (fp, s1, level, mode, &is_first);
call    0 returned 100%
        -:  377:	      }
        -:  378:	  }
        -:  379:    }
        1:  380:  if (fp == (FILE *) NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  381:    {
        -:  382:      /*
        -:  383:         The file isn't found in user library directory of
        -:  384:         $HOME/[$]GCAL_USR_DATADIR:
        -:  385:         * Search the file in the system's library directory of
        -:  386:         $GCAL_SYS_DATADIR.
        -:  387:       */
        1:  388:      ptr_env = getenv (ENV_VAR_SYS_DATADIR);
call    0 returned 100%
        -:  389:      /*
        -:  390:         Search the file in the directory specified in the
        -:  391:         $GCAL_SYS_DATADIR environment variable first.
        -:  392:       */
        1:  393:      if (ptr_env != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  394:	{
    #####:  395:	  if (*ptr_env)
branch  0 never executed
branch  1 never executed
        -:  396:	    {
    #####:  397:	      make_absolute_filename (&s1, ptr_env, *filename);
call    0 never executed
    #####:  398:	      fp = get_file_ptr (fp, s1, level, mode, &is_first);
call    0 never executed
        -:  399:	    }
        -:  400:	}
        -:  401:      else
        -:  402:	{
        -:  403:	  /*
        -:  404:	     If the $GCAL_SYS_DATADIR environment variable is unset:
        -:  405:	     * Search the file in burned-in system's library directory of
        -:  406:	     GCAL_SYS_DATADIR.
        -:  407:	   */
        1:  408:	  make_absolute_filename (&s1, GCAL_SYS_DATADIR, *filename);
call    0 returned 100%
        1:  409:	  fp = get_file_ptr (fp, s1, level, mode, &is_first);
call    0 returned 100%
        -:  410:	}
        -:  411:    }
        -:  412:# endif	/* USE_RC */
        -:  413:#else /* AMIGA && !__GNUC__ */
        -:  414:      /*
        -:  415:         It's not necessary to perform further searches for COmmon files,
        -:  416:         because the compiler/system doesn't support the `getenv()' function.
        -:  417:       */
        -:  418:      if (mode == COmmon)
        -:  419:	return (fp);
        -:  420:# if USE_RC
        -:  421:      /*
        -:  422:         This part is for compilers/systems
        -:  423:         which do not support the `getenv()' function.
        -:  424:       */
        -:  425:      if (fp == (FILE *) NULL)
        -:  426:	{
        -:  427:	  /*
        -:  428:	     The file isn't found in the actual directory:
        -:  429:	     * Search the file in the burned-in user's library directory of
        -:  430:	     GCAL_USR_DATADIR.
        -:  431:	   */
        -:  432:	  make_absolute_filename (&s1, GCAL_USR_DATADIR, *filename);
        -:  433:	  fp = get_file_ptr (fp, s1, level, mode, &is_first);
        -:  434:	}
        -:  435:      if (fp == (FILE *) NULL)
        -:  436:	{
        -:  437:	  /*
        -:  438:	     The file isn't found in the user's library directory of
        -:  439:	     GCAL_USR_DATADIR:
        -:  440:	     * Search the file in the burned-in system's library directory of
        -:  441:	     GCAL_SYS_DATADIR.
        -:  442:	   */
        -:  443:	  make_absolute_filename (&s1, GCAL_SYS_DATADIR, *filename);
        -:  444:	  fp = get_file_ptr (fp, s1, level, mode, &is_first);
        -:  445:	}
        -:  446:# endif	/* USE_RC */
        -:  447:#endif /* AMIGA && !__GNUC__ */
        -:  448:      /*
        -:  449:         If the file is found:
        -:  450:         Copy the real (absolute) name of the file to `&filename'.
        -:  451:       */
        1:  452:      if (fp != (FILE *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  453:	{
    #####:  454:	  len = (int) strlen (s1);
    #####:  455:	  if ((int) strlen (*filename) < len)
branch  0 never executed
branch  1 never executed
        -:  456:	    /*
        -:  457:	       We MUST reallocate the memory area of `&filename'!
        -:  458:	     */
    #####:  459:	    *filename = (char *) my_realloc ((VOID_PTR) * filename,
call    0 never executed
        -:  460:					     len + 1,
        -:  461:					     ERR_NO_MEMORY_AVAILABLE,
        -:  462:					     __FILE__, ((long) __LINE__) - 3L,
        -:  463:					     "*filename", 0);
    #####:  464:	  strcpy (*filename, s1);
        -:  465:	}
        -:  466:#if USE_RC
        -:  467:      else
        -:  468:	/*
        -:  469:	   File not found!
        -:  470:	 */
        1:  471:      if (warning_level >= WARN_LVL_MAX)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  472:	/*
        -:  473:	   Terminate if `--debug=abort' option is given.
        -:  474:	 */
    #####:  475:	my_error (ERR_FILE_NOT_FOUND, *filename, 0L, *filename, 0);
call    0 never executed
        -:  476:#endif
        -:  477:
        1:  478:      return (fp);
        -:  479:    }
        -:  480:
        -:  481:
        -:  482:
function file_read_line called 2 returned 100% blocks executed 17%
        2:  483:  char *file_read_line (fp, line_buffer, in_pool, pool, ptr_pool, filename,
        -:  484:			line_number, line_length, mode, is_include, is_dvar,
        -:  485:			is_tvar) FILE *fp;
        -:  486:  char **line_buffer;
        -:  487:  int *in_pool;
        -:  488:  char *pool;
        -:  489:  char *ptr_pool;
        -:  490:  const char *filename;
        -:  491:  long *line_number;
        -:  492:  int *line_length;
        -:  493:  const Fmode_enum mode;
        -:  494:  Bool *is_include;
        -:  495:  Bool *is_dvar;
        -:  496:  Bool *is_tvar;
        -:  497:/*!
        -:  498:   Reads a line of a delivered resource/response file into `&line_buffer'
        -:  499:     using the delivered char vector `pool', which must be allocated by caller
        -:  500:     with size BUF_LEN+1 (BUF_LEN should be "A POWER OF 2", e.g., 4096).
        -:  501:     Returns the position in buffer of the character managed in next call
        -:  502:     by char pointer `ptr_pool', which must be defined by caller; or NULL
        -:  503:     if EOF is detected.
        -:  504:*/
        -:  505:  {
        -:  506:    static Uint lbuf_max = MAXLEN_MAX;
        2:  507:    register int i = 1;
        -:  508:    auto char *ptr_char;
        -:  509:    auto char ch;
        2:  510:    auto Bool is_error = FALSE;
        -:  511:#if USE_RC
        2:  512:    auto Bool is_rem = FALSE;
        -:  513:#endif
        -:  514:
        -:  515:
        -:  516:    /*
        -:  517:       Ensure NOW that `&line_buffer' is ALWAYS as large as all "other"
        -:  518:       string vectors (s1...s7) are, because the `&line_buffer' is not
        -:  519:       resized in all cases when the "other" strings vectors are resized!
        -:  520:     */
        2:  521:    if (lbuf_max < maxlen_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  522:      {
    #####:  523:	*line_buffer = (char *) my_realloc ((VOID_PTR) * line_buffer,
call    0 never executed
        -:  524:					    maxlen_max,
        -:  525:					    ERR_NO_MEMORY_AVAILABLE,
        -:  526:					    __FILE__, ((long) __LINE__) - 3L,
        -:  527:					    "*line_buffer", maxlen_max);
    #####:  528:	lbuf_max = maxlen_max;
        -:  529:      }
        2:  530:    **line_buffer = '\0';
        2:  531:    *line_length = 0;
        2:  532:    ptr_char = *line_buffer;
        2:  533:    (*is_include) = (*is_dvar) = (*is_tvar) = FALSE;
        -:  534:    /*
        -:  535:       Initial fill/refill of `pool'.
        -:  536:     */
        2:  537:    if (!*in_pool)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  538:      {
        1:  539:	*in_pool = read (fileno (fp), (char *) pool, BUF_LEN);
call    0 returned 100%
call    1 returned 100%
        1:  540:	if (!*in_pool)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  541:	  /*
        -:  542:	     At end of file.
        -:  543:	   */
    #####:  544:	  return (NULL);
        1:  545:	else if (*in_pool < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  546:	  /*
        -:  547:	     File read error.
        -:  548:	   */
    #####:  549:	  my_error (ERR_READ_FILE, __FILE__, (long) __LINE__, filename, 0);
call    0 never executed
        1:  550:	ptr_pool = pool;
        -:  551:      }
        2:  552:    if (*ptr_pool == '\n')
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  553:      (*line_number)++;
        9:  554:    while ((*ptr_pool != REM_CHAR) && (
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  555:#if USE_RC
        -:  556:					((mode == REsource)
    #####:  557:					 && (*ptr_pool != *RC_INCL_STMENT)
branch  0 never executed
branch  1 never executed
    #####:  558:					 && (*ptr_pool != RC_TVAR_CHAR)
branch  0 never executed
branch  1 never executed
    #####:  559:					 && !isalnum (*ptr_pool)) ||
branch  0 never executed
branch  1 never executed
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  560:#endif
        -:  561:					((mode == REsponse)
        6:  562:					 && (*ptr_pool != *MONTH3_LIT)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  563:					 && (*ptr_pool != *FYEAR_SEP)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  564:					 && (*ptr_pool != RSP_CHAR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  565:					 && !isalnum (*ptr_pool)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  566:#if USE_RC
        6:  567:					 && (*ptr_pool != RC_ADATE_CHAR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  568:#endif
        6:  569:					 && (*ptr_pool != *SWITCH)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  570:					 && (*ptr_pool != *SWITCH2))))
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  571:      {
        6:  572:	if ((!**line_buffer && !isspace (*ptr_pool)) || **line_buffer)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
        -:  573:	  {
    #####:  574:	    if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
        -:  575:	      {
    #####:  576:		resize_all_strings (maxlen_max << 1, TRUE, __FILE__,
call    0 never executed
        -:  577:				    (long) __LINE__);
    #####:  578:		ptr_char = *line_buffer + i - 1;
        -:  579:	      }
    #####:  580:	    i++;
    #####:  581:	    *ptr_char++ = *ptr_pool++;
        -:  582:	  }
        -:  583:	else
        6:  584:	  ptr_pool++;
        6:  585:	(*in_pool)--;
        6:  586:	if (!*in_pool)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -:  587:	  {
        -:  588:	    /*
        -:  589:	       Refill `pool', because the line we work on isn't complete.
        -:  590:	     */
        1:  591:	    *in_pool = read (fileno (fp), (char *) pool, BUF_LEN);
call    0 returned 100%
call    1 returned 100%
        1:  592:	    if (!*in_pool)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  593:	      {
        -:  594:		/*
        -:  595:		   At end of file.
        -:  596:		 */
        1:  597:		if (i > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  598:		  /*
        -:  599:		     Error, the line of the resource file contains no valid "date"-part.
        -:  600:		   */
    #####:  601:		  break;
        1:  602:		return (NULL);
        -:  603:	      }
    #####:  604:	    else if (*in_pool < 0)
branch  0 never executed
branch  1 never executed
        -:  605:	      /*
        -:  606:	         File read error.
        -:  607:	       */
    #####:  608:	      my_error (ERR_READ_FILE, __FILE__, (long) __LINE__, filename,
call    0 never executed
        -:  609:			0);
    #####:  610:	    ptr_pool = pool;
        -:  611:	  }
        5:  612:	if (*ptr_pool == '\n')
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:  613:	  {
        4:  614:	    if (i > 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  615:	      {
        -:  616:		/*
        -:  617:		   Error, the line of the resource file contains no valid "date"-part.
        -:  618:		 */
    #####:  619:		if ((Uint) i < maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  620:		  i--;
    #####:  621:		(*in_pool)++;
    #####:  622:		ptr_pool--;
    #####:  623:		ptr_char--;
    #####:  624:		break;
        -:  625:	      }
        4:  626:	    (*line_number)++;
        -:  627:	  }
        -:  628:      }
        1:  629:    (*line_number)++;
        -:  630:    /*
        -:  631:       Skip whole line.
        -:  632:     */
        2:  633:    if ((mode != COmmon) && (*ptr_pool == REM_CHAR))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  634:      {
        -:  635:#if USE_RC
        1:  636:	is_rem = TRUE;
        -:  637:#endif
        -:  638:	LOOP
        -:  639:	{
        1:  640:	  ch = '\0';
        -:  641:	  /*
        -:  642:	     Read until a NEWLINE character or EOF.
        -:  643:	   */
        3:  644:	  while (*ptr_pool != '\n')
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  645:	    {
        -:  646:	      /*
        -:  647:	         Refill `pool', because the line we work on isn't complete.
        -:  648:	       */
        1:  649:	      if (!*in_pool)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  650:		{
    #####:  651:		  *in_pool = read (fileno (fp), (char *) pool, BUF_LEN);
call    0 never executed
call    1 never executed
    #####:  652:		  if (!*in_pool)
branch  0 never executed
branch  1 never executed
        -:  653:		    /*
        -:  654:		       At end of file.
        -:  655:		     */
    #####:  656:		    return (NULL);
    #####:  657:		  else if (*in_pool < 0)
branch  0 never executed
branch  1 never executed
        -:  658:		    /*
        -:  659:		       File read error.
        -:  660:		     */
    #####:  661:		    my_error (ERR_READ_FILE, __FILE__, (long) __LINE__,
call    0 never executed
        -:  662:			      filename, 0);
    #####:  663:		  ptr_pool = pool;
        -:  664:		}
        -:  665:	      else
        -:  666:		{
        1:  667:		  ch = *ptr_pool++;
        1:  668:		  (*in_pool)--;
        -:  669:		}
        -:  670:	    }
        -:  671:	  /*
        -:  672:	     Skip the trailing NEWLINE character of the line.
        -:  673:	   */
        1:  674:	  ptr_pool++;
        1:  675:	  if (*in_pool)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  676:	    (*in_pool)--;
        -:  677:	  /*
        -:  678:	     Check if it is a `\\'`\n' (BACKSLASH-NEWLINE) character sequence:
        -:  679:	     If so, append the next line to the current line.
        -:  680:	   */
        1:  681:	  if (ch == QUOTE_CHAR)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  682:	    {
    #####:  683:	      if (!*in_pool)
branch  0 never executed
branch  1 never executed
        -:  684:		{
    #####:  685:		  *in_pool = read (fileno (fp), (char *) pool, BUF_LEN);
call    0 never executed
call    1 never executed
    #####:  686:		  if (!*in_pool)
branch  0 never executed
branch  1 never executed
        -:  687:		    /*
        -:  688:		       At end of file.
        -:  689:		     */
    #####:  690:		    return (NULL);
    #####:  691:		  else if (*in_pool < 0)
branch  0 never executed
branch  1 never executed
        -:  692:		    /*
        -:  693:		       File read error.
        -:  694:		     */
    #####:  695:		    my_error (ERR_READ_FILE, __FILE__, (long) __LINE__,
call    0 never executed
        -:  696:			      filename, 0);
    #####:  697:		  ptr_pool = pool;
        -:  698:		}
    #####:  699:	      (*line_number)++;
        -:  700:	    }
        -:  701:	  else
        1:  702:	    break;
        -:  703:	}
        -:  704:      }
        -:  705:    else
        -:  706:      {
    #####:  707:	if (i > 1)
branch  0 never executed
branch  1 never executed
    #####:  708:	  is_error = TRUE;
        -:  709:#if USE_RC
    #####:  710:	else if (mode == REsource)
branch  0 never executed
branch  1 never executed
        -:  711:	  {
    #####:  712:	    if (*ptr_pool == *RC_INCL_STMENT)
branch  0 never executed
branch  1 never executed
    #####:  713:	      *is_include = TRUE;
    #####:  714:	    else if (isalpha (*ptr_pool))
branch  0 never executed
branch  1 never executed
    #####:  715:	      *is_dvar = TRUE;
    #####:  716:	    else if (*ptr_pool == RC_TVAR_CHAR)
branch  0 never executed
branch  1 never executed
    #####:  717:	      *is_tvar = TRUE;
    #####:  718:	    else if (!isdigit (*ptr_pool))
branch  0 never executed
branch  1 never executed
    #####:  719:	      is_error = TRUE;
        -:  720:	  }
        -:  721:#endif
    #####:  722:	ch = (*ptr_char++) = *ptr_pool++;
    #####:  723:	(*in_pool)--;
        -:  724:	LOOP
        -:  725:	{
    #####:  726:	  if (*in_pool)
branch  0 never executed
branch  1 never executed
        -:  727:	    {
    #####:  728:	      if ((Uint) i < maxlen_max)
branch  0 never executed
branch  1 never executed
    #####:  729:		i++;
        -:  730:	      else
        -:  731:		{
    #####:  732:		  resize_all_strings (maxlen_max << 1, TRUE, __FILE__,
call    0 never executed
        -:  733:				      (long) __LINE__);
    #####:  734:		  ptr_char = *line_buffer + i++;
        -:  735:		}
        -:  736:	      /*
        -:  737:	         Character sequence `\\'`\n' (BACKSLASH-NEWLINE) found:
        -:  738:	         Eliminate the sequence and append the next line to the current line.
        -:  739:	       */
    #####:  740:	      if ((*ptr_pool == '\n') && (ch == QUOTE_CHAR))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  741:		{
    #####:  742:		  if (is_error)
branch  0 never executed
branch  1 never executed
        -:  743:		    {
    #####:  744:		      (*in_pool)--;
    #####:  745:		      break;
        -:  746:		    }
    #####:  747:		  if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
        -:  748:		    {
    #####:  749:		      resize_all_strings (maxlen_max << 1, TRUE, __FILE__,
call    0 never executed
        -:  750:					  (long) __LINE__);
    #####:  751:		      ptr_char = *line_buffer + i - 1;
        -:  752:		    }
    #####:  753:		  ptr_char--;
    #####:  754:		  i -= 2;
    #####:  755:		  (*line_number)++;
    #####:  756:		  ch = *ptr_pool;
    #####:  757:		  if (*in_pool)
branch  0 never executed
branch  1 never executed
    #####:  758:		    ptr_pool++;
        -:  759:		}
        -:  760:	      else
        -:  761:		{
    #####:  762:		  ch = *ptr_pool++;
        -:  763:		  /*
        -:  764:		     Single NEWLINE character found:
        -:  765:		     We must finish the line!
        -:  766:		   */
    #####:  767:		  if (ch == '\n')
branch  0 never executed
branch  1 never executed
        -:  768:		    {
    #####:  769:		      (*in_pool)--;
    #####:  770:		      break;
        -:  771:		    }
        -:  772:		  else
        -:  773:		    {
    #####:  774:		      if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
        -:  775:			{
    #####:  776:			  resize_all_strings (maxlen_max << 1, TRUE, __FILE__,
call    0 never executed
        -:  777:					      (long) __LINE__);
    #####:  778:			  ptr_char = *line_buffer + i - 1;
        -:  779:			}
    #####:  780:		      *ptr_char++ = ch;
        -:  781:		    }
        -:  782:		}
    #####:  783:	      if (*in_pool)
branch  0 never executed
branch  1 never executed
    #####:  784:		(*in_pool)--;
        -:  785:	    }
        -:  786:	  /*
        -:  787:	     Refill `pool', because the line we work on isn't complete.
        -:  788:	   */
    #####:  789:	  if (!*in_pool)
branch  0 never executed
branch  1 never executed
        -:  790:	    {
    #####:  791:	      *in_pool = read (fileno (fp), (char *) pool, BUF_LEN);
call    0 never executed
call    1 never executed
    #####:  792:	      if (!*in_pool)
branch  0 never executed
branch  1 never executed
        -:  793:		{
        -:  794:		  /*
        -:  795:		     At end of file.
        -:  796:		   */
    #####:  797:		  if (!**line_buffer)
branch  0 never executed
branch  1 never executed
    #####:  798:		    return (NULL);
        -:  799:		  else
    #####:  800:		    break;
        -:  801:		}
    #####:  802:	      else if (*in_pool < 0)
branch  0 never executed
branch  1 never executed
        -:  803:		/*
        -:  804:		   File read error.
        -:  805:		 */
    #####:  806:		my_error (ERR_READ_FILE, __FILE__, (long) __LINE__, filename,
call    0 never executed
        -:  807:			  0);
    #####:  808:	      ptr_pool = pool;
        -:  809:	    }
        -:  810:	}
        -:  811:      }
        1:  812:    *ptr_char = '\0';
        -:  813:#if USE_RC
        1:  814:    if (!is_error && !is_rem && (mode == REsource))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
        -:  815:      {
    #####:  816:	if (*is_tvar)
branch  0 never executed
branch  1 never executed
        -:  817:	  {
    #####:  818:	    if (i > 2)
branch  0 never executed
branch  1 never executed
        -:  819:	      {
        -:  820:		/*
        -:  821:		   If the line does not consist of a text variable
        -:  822:		   assignment or operation, expand the text variable.
        -:  823:		 */
    #####:  824:		if ((isalpha (*(*line_buffer + 1))
branch  0 never executed
branch  1 never executed
    #####:  825:		     && (*(*line_buffer + 2) != *RC_VAR_ASSIGN)
branch  0 never executed
branch  1 never executed
    #####:  826:		     && (*(*line_buffer + 2) != *RC_TVAR_ICMD_ASSIGN)
branch  0 never executed
branch  1 never executed
    #####:  827:		     && (*(*line_buffer + 2) != *RC_TVAR_UCMD_ASSIGN)
branch  0 never executed
branch  1 never executed
    #####:  828:		     && (*(*line_buffer + 2) != *RC_VAR_ADD)
branch  0 never executed
branch  1 never executed
    #####:  829:		     && (*(*line_buffer + 2) != *RC_VAR_SUB))
branch  0 never executed
branch  1 never executed
    #####:  830:		    || *(*line_buffer + 1) == FLEFT_CHAR
branch  0 never executed
branch  1 never executed
    #####:  831:		    || *(*line_buffer + 1) == FCENTER_CHAR
branch  0 never executed
branch  1 never executed
    #####:  832:		    || *(*line_buffer + 1) == FRIGHT_CHAR)
branch  0 never executed
branch  1 never executed
    #####:  833:		  *is_tvar = FALSE;
        -:  834:	      }
        -:  835:	    else
    #####:  836:	      *is_tvar = FALSE;
        -:  837:	  }
        -:  838:	/*
        -:  839:	   Try to expand text variables NOW!
        -:  840:	 */
    #####:  841:	if (!*is_tvar)
branch  0 never executed
branch  1 never executed
        -:  842:	  {
        -:  843:	    register int len;
        -:  844:	    register int n;
        -:  845:	    register int k;
        -:  846:	    register int x;
        -:  847:	    register int l;
    #####:  848:	    register int flen = 1;
    #####:  849:	    auto int fstyle = FSTYLE_NONE;
    #####:  850:	    auto int fwidth = SPECIAL_VALUE;
        -:  851:	    auto char *ptr_tvar;
        -:  852:	    static char tvar[2];
        -:  853:	    static char the_tvar;
    #####:  854:	    auto Bool is_quoted = FALSE;
    #####:  855:	    auto Bool restore_tvar = FALSE;
    #####:  856:	    auto Bool ok = FALSE;
    #####:  857:	    auto Bool is_cformat = FALSE;
    #####:  858:	    auto Bool is_lformat = FALSE;
    #####:  859:	    auto Bool is_sign = FALSE;
    #####:  860:	    auto Bool is_lzero = FALSE;
    #####:  861:	    auto Bool is_fformat = FALSE;
    #####:  862:	    auto Bool is_suffix = FALSE;
        -:  863:
        -:  864:
        -:  865:	    /*
        -:  866:	       Analyse line till ALL referenced text variables are expanded.
        -:  867:	     */
        -:  868:	    do
        -:  869:	      {
    #####:  870:		ptr_char = *line_buffer;
        -:  871:		/*
        -:  872:		   Check if the assigned TEXT contains any references
        -:  873:		   to other TVAR variables, if so, insert their TEXTs.
        -:  874:		 */
    #####:  875:		ptr_tvar = strchr (ptr_char, RC_TVAR_CHAR);
    #####:  876:		if (ptr_tvar != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -:  877:		  {
    #####:  878:		    n = flen;
        -:  879:		    /*
        -:  880:		       Buffer the name of the text variable respecting
        -:  881:		       a possible TVAR format $[<|:|>[+][0]N[&]#|*]TVAR.
        -:  882:		     */
    #####:  883:		    while (*(ptr_tvar + n) && !isalpha (*(ptr_tvar + n)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  884:		      n++;
    #####:  885:		    the_tvar = *(ptr_tvar + n);
    #####:  886:		    *tvar = tvar[1] = '\0';
    #####:  887:		    n = k = 0;
        -:  888:		    do
        -:  889:		      {
        -:  890:			/*
        -:  891:			   Check for a TVAR format.
        -:  892:			 */
    #####:  893:			flen = decode_format (ptr_tvar, flen, &is_cformat,
call    0 never executed
        -:  894:					      &is_lformat, &is_sign,
        -:  895:					      &is_lzero, &is_suffix,
        -:  896:					      &is_fformat, &fstyle, &fwidth);
    #####:  897:			if (fwidth == SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####:  898:			  flen = 1;
    #####:  899:			*tvar = *(ptr_tvar + flen);
    #####:  900:			tvar[1] = *(ptr_tvar + flen + 1);
    #####:  901:			len = (int) (ptr_tvar - ptr_char);
    #####:  902:			if (len)
branch  0 never executed
branch  1 never executed
        -:  903:			  {
    #####:  904:			    while ((Uint) len + k >= maxlen_max)
branch  0 never executed
branch  1 never executed
        -:  905:			      {
    #####:  906:				resize_all_strings (maxlen_max << 1, TRUE,
call    0 never executed
        -:  907:						    __FILE__,
        -:  908:						    (long) __LINE__);
    #####:  909:				ptr_char = *line_buffer + n;
        -:  910:			      }
    #####:  911:			    strncpy (s5 + k, ptr_char, len);
    #####:  912:			    k += len;
        -:  913:			  }
    #####:  914:			s5[k] = '\0';
    #####:  915:			if (k)
branch  0 never executed
branch  1 never executed
    #####:  916:			  if (s5[k - 1] == QUOTE_CHAR)
branch  0 never executed
branch  1 never executed
    #####:  917:			    is_quoted = TRUE;
    #####:  918:			if (!is_quoted && isalpha (*tvar))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  919:			  {
    #####:  920:			    register int j = 0;
        -:  921:			    register int j_buf;
        -:  922:
        -:  923:
        -:  924:			    /*
        -:  925:			       Try to insert the value of this TVAR (this is its TEXT).
        -:  926:			     */
    #####:  927:			    if (rc_tvar[IDX (*tvar)].tvar_local.tvar_text !=
branch  0 never executed
branch  1 never executed
        -:  928:				(char *) NULL
    #####:  929:				|| rc_tvar[IDX (*tvar)].tvar_global.
branch  0 never executed
branch  1 never executed
        -:  930:				tvar_text != (char *) NULL)
    #####:  931:			      {
        -:  932:				auto char *buf;
        -:  933:
        -:  934:
    #####:  935:				if (rc_tvar[IDX (*tvar)].tvar_local.
branch  0 never executed
branch  1 never executed
        -:  936:				    tvar_text != (char *) NULL)
        -:  937:				  {
    #####:  938:				    if (!*rc_tvar[IDX (*tvar)].tvar_local.
branch  0 never executed
branch  1 never executed
        -:  939:					tvar_text)
        -:  940:				      {
    #####:  941:					if (rc_tvar[IDX (*tvar)].tvar_global.
branch  0 never executed
branch  1 never executed
        -:  942:					    tvar_text != (char *) NULL)
    #####:  943:					  buf =
    #####:  944:					    rc_tvar[IDX (*tvar)].tvar_global.
        -:  945:					    tvar_text;
        -:  946:					else
    #####:  947:					  buf =
    #####:  948:					    rc_tvar[IDX (*tvar)].tvar_local.
        -:  949:					    tvar_text;
        -:  950:				      }
        -:  951:				    else
    #####:  952:				      buf =
    #####:  953:					rc_tvar[IDX (*tvar)].tvar_local.
        -:  954:					tvar_text;
        -:  955:				  }
        -:  956:				else
    #####:  957:				  buf =
    #####:  958:				    rc_tvar[IDX (*tvar)].tvar_global.
        -:  959:				    tvar_text;
    #####:  960:				j_buf = (int) strlen (buf);
    #####:  961:				if (fwidth != SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
        -:  962:				  {
    #####:  963:				    if (is_fformat)
branch  0 never executed
branch  1 never executed
    #####:  964:				      j = fwidth;
        -:  965:				    else
        -:  966:				      {
    #####:  967:					register int num_hls = 0;
    #####:  968:					auto char *ptr_buf = buf;
        -:  969:					auto char *tvar_text;
    #####:  970:					auto Bool quote = FALSE;
        -:  971:
        -:  972:
        -:  973:					/*
        -:  974:					   Scan contents of TVAR for special texts used for highlighting.
        -:  975:					 */
    #####:  976:					tvar_text =
call    0 never executed
    #####:  977:					  (char *) my_malloc (j_buf + 1,
        -:  978:							      ERR_NO_MEMORY_AVAILABLE,
        -:  979:							      __FILE__,
        -:  980:							      ((long)
        -:  981:							       __LINE__) - 2L,
        -:  982:							      "tvar_text", 0);
    #####:  983:					l = x = 0;
        -:  984:					LOOP
        -:  985:					{
    #####:  986:					  if (*(ptr_buf + l))
branch  0 never executed
branch  1 never executed
        -:  987:					    {
    #####:  988:					      if (*(ptr_buf + l) ==
branch  0 never executed
branch  1 never executed
        -:  989:						  RC_SPECIAL_TEXT_CHAR)
        -:  990:						{
    #####:  991:						  l++;
    #####:  992:						  switch (*(ptr_buf + l))
branch  0 never executed
branch  1 never executed
        -:  993:						    {
    #####:  994:						    case RC_HLS1S_CHAR:
        -:  995:						    case RC_HLS1E_CHAR:
        -:  996:						    case RC_HLS2S_CHAR:
        -:  997:						    case RC_HLS2E_CHAR:
        -:  998:						    case RC_HLS3S_CHAR:
        -:  999:						    case RC_HLS3E_CHAR:
        -: 1000:						    case RC_HLS4S_CHAR:
        -: 1001:						    case RC_HLS4E_CHAR:
        -: 1002:						    case RC_HLS5S_CHAR:
        -: 1003:						    case RC_HLS5E_CHAR:
    #####: 1004:						      if (quote)
branch  0 never executed
branch  1 never executed
        -: 1005:							{
    #####: 1006:							  quote = FALSE;
    #####: 1007:							  x--;
    #####: 1008:							  tvar_text[x++] =
    #####: 1009:							    *(ptr_buf + l -
        -: 1010:							      1);
    #####: 1011:							  tvar_text[x++] =
    #####: 1012:							    *(ptr_buf + l);
        -: 1013:							}
        -: 1014:						      else
    #####: 1015:							num_hls++;
    #####: 1016:						      break;
    #####: 1017:						    default:
    #####: 1018:						      tvar_text[x++] =
    #####: 1019:							*(ptr_buf + l - 1);
    #####: 1020:						      tvar_text[x++] =
    #####: 1021:							*(ptr_buf + l);
        -: 1022:						    }
        -: 1023:						}
        -: 1024:					      else
        -: 1025:						{
    #####: 1026:						  if (*(ptr_buf + l) ==
branch  0 never executed
branch  1 never executed
        -: 1027:						      QUOTE_CHAR)
    #####: 1028:						    quote = TRUE;
        -: 1029:						  else
    #####: 1030:						    quote = FALSE;
    #####: 1031:						  tvar_text[x++] =
    #####: 1032:						    *(ptr_buf + l);
        -: 1033:						}
    #####: 1034:					      l++;
        -: 1035:					    }
        -: 1036:					  else
        -: 1037:					    {
    #####: 1038:					      tvar_text[x] = '\0';
    #####: 1039:					      break;
        -: 1040:					    }
        -: 1041:					}
    #####: 1042:					free (tvar_text);
    #####: 1043:					if (highlight_flag
branch  0 never executed
branch  1 never executed
    #####: 1044:					    && (ehls1s.len == 1))
branch  0 never executed
branch  1 never executed
        -: 1045:					  {
    #####: 1046:					    fwidth += num_hls;
    #####: 1047:					    j = MAX (fwidth, j_buf);
        -: 1048:					  }
        -: 1049:					else
        -: 1050:					  {
    #####: 1051:					    j_buf = x;
    #####: 1052:					    j = MAX (fwidth, j_buf);
    #####: 1053:					    j += (num_hls << 1);
        -: 1054:					  }
        -: 1055:				      }
        -: 1056:				  }
        -: 1057:				else
    #####: 1058:				  j = j_buf;
    #####: 1059:				if (j)
branch  0 never executed
branch  1 never executed
        -: 1060:				  {
    #####: 1061:				    while ((Uint) k + j >= maxlen_max)
branch  0 never executed
branch  1 never executed
        -: 1062:				      {
    #####: 1063:					resize_all_strings (maxlen_max << 1,
call    0 never executed
        -: 1064:							    TRUE, __FILE__,
        -: 1065:							    (long) __LINE__);
    #####: 1066:					ptr_char = *line_buffer + n;
        -: 1067:				      }
    #####: 1068:				    if (fwidth != SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####: 1069:				      (void) use_format (&s5, k, buf,
call    0 never executed
        -: 1070:							 atol (buf),
    #####: 1071:							 is_sign | is_lzero |
        -: 1072:							 is_suffix,
        -: 1073:							 is_cformat,
        -: 1074:							 is_lformat, is_sign,
        -: 1075:							 is_lzero, is_suffix,
        -: 1076:							 is_fformat, fstyle,
        -: 1077:							 fwidth, j_buf);
        -: 1078:				    else
    #####: 1079:				      strcat (s5, buf);
        -: 1080:				  }
        -: 1081:				/*
        -: 1082:				   Skip TVAR name.
        -: 1083:				 */
    #####: 1084:				len += (flen + 1);
    #####: 1085:				if (j)
branch  0 never executed
branch  1 never executed
    #####: 1086:				  k += j;
        -: 1087:				else
        -: 1088:				  /*
        -: 1089:				     If TVAR is "empty", remove a possibly obsolete whitespace.
        -: 1090:				   */
    #####: 1091:				if (isspace (s5[k - 1]) && isspace (tvar[1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1092:				  s5[--k] = '\0';
        -: 1093:			      }
        -: 1094:			    else
    #####: 1095:			      restore_tvar = TRUE;
        -: 1096:			  }
        -: 1097:			else
    #####: 1098:			  restore_tvar = TRUE;
        -: 1099:			/*
        -: 1100:			   If TVAR isn't defined, or quoted, or an invalid
        -: 1101:			   TVAR name is found, don't touch it.
        -: 1102:			 */
    #####: 1103:			if (restore_tvar)
branch  0 never executed
branch  1 never executed
        -: 1104:			  {
    #####: 1105:			    if ((Uint) k + 1 >= maxlen_max)
branch  0 never executed
branch  1 never executed
        -: 1106:			      {
    #####: 1107:				resize_all_strings (maxlen_max << 1, TRUE,
call    0 never executed
        -: 1108:						    __FILE__,
        -: 1109:						    (long) __LINE__);
    #####: 1110:				ptr_char = *line_buffer + n;
        -: 1111:			      }
    #####: 1112:			    s5[k++] = RC_TVAR_CHAR;
    #####: 1113:			    len++;
    #####: 1114:			    if (*tvar && (flen == 1))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1115:			      {
    #####: 1116:				if ((Uint) k + 1 >= maxlen_max)
branch  0 never executed
branch  1 never executed
        -: 1117:				  {
    #####: 1118:				    resize_all_strings (maxlen_max << 1, TRUE,
call    0 never executed
        -: 1119:							__FILE__,
        -: 1120:							(long) __LINE__);
    #####: 1121:				    ptr_char = *line_buffer + n;
        -: 1122:				  }
    #####: 1123:				s5[k++] = *tvar;
    #####: 1124:				len++;
        -: 1125:			      }
    #####: 1126:			    s5[k] = '\0';
        -: 1127:			  }
    #####: 1128:			n += len;
    #####: 1129:			ptr_char += len;
    #####: 1130:			ptr_tvar = strchr (ptr_char, RC_TVAR_CHAR);
    #####: 1131:			flen = 1;
    #####: 1132:			restore_tvar = is_quoted = FALSE;
        -: 1133:		      }
    #####: 1134:		    while (ptr_tvar != (char *) NULL);
branch  0 never executed
branch  1 never executed
        -: 1135:		    /*
        -: 1136:		       Add possibly trailing ordinary text.
        -: 1137:		     */
    #####: 1138:		    if (*ptr_char)
branch  0 never executed
branch  1 never executed
        -: 1139:		      {
    #####: 1140:			k += (int) strlen (ptr_char);
    #####: 1141:			while ((Uint) k >= maxlen_max)
branch  0 never executed
branch  1 never executed
        -: 1142:			  {
    #####: 1143:			    resize_all_strings (maxlen_max << 1, TRUE,
call    0 never executed
        -: 1144:						__FILE__, (long) __LINE__);
    #####: 1145:			    ptr_char = *line_buffer + n;
        -: 1146:			  }
    #####: 1147:			strcat (s5, ptr_char);
        -: 1148:		      }
    #####: 1149:		    i = k++;
    #####: 1150:		    strcpy (*line_buffer, s5);
        -: 1151:		    /*
        -: 1152:		       If the expansion results to a text variable assignment
        -: 1153:		       or operation, skip the expansion loop and perform the
        -: 1154:		       assignment/operation.
        -: 1155:		     */
    #####: 1156:		    if ((**line_buffer == RC_TVAR_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 1157:			&& isalpha (*(*line_buffer + 1))
branch  0 never executed
branch  1 never executed
    #####: 1158:			&& (*(*line_buffer + 2) == *RC_VAR_ASSIGN
branch  0 never executed
branch  1 never executed
    #####: 1159:			    || *(*line_buffer + 2) == *RC_TVAR_ICMD_ASSIGN
branch  0 never executed
branch  1 never executed
    #####: 1160:			    || *(*line_buffer + 2) == *RC_TVAR_UCMD_ASSIGN
branch  0 never executed
branch  1 never executed
    #####: 1161:			    || *(*line_buffer + 2) == *RC_VAR_ADD
branch  0 never executed
branch  1 never executed
    #####: 1162:			    || *(*line_buffer + 2) == *RC_VAR_SUB))
branch  0 never executed
branch  1 never executed
    #####: 1163:		      *is_tvar = ok = TRUE;
        -: 1164:		    /*
        -: 1165:		       Now check whether we have to analyse the line again
        -: 1166:		       in case text variables were expanded to texts which
        -: 1167:		       contain unquoted references of other text variables.
        -: 1168:		     */
    #####: 1169:		    n = 0;
    #####: 1170:		    ptr_tvar = strchr (*line_buffer, RC_TVAR_CHAR);
    #####: 1171:		    if (ptr_tvar != (char *) NULL)
branch  0 never executed
branch  1 never executed
        -: 1172:		      {
        -: 1173:			do
        -: 1174:			  {
    #####: 1175:			    if (!n && (**line_buffer != RC_TVAR_CHAR))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1176:			      ptr_tvar--;
    #####: 1177:			    else if (n)
branch  0 never executed
branch  1 never executed
    #####: 1178:			      ptr_tvar--;
    #####: 1179:			    *tvar = *ptr_tvar;
    #####: 1180:			    if (!n && (**line_buffer != RC_TVAR_CHAR))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1181:			      ptr_tvar++;
    #####: 1182:			    else if (n)
branch  0 never executed
branch  1 never executed
    #####: 1183:			      ptr_tvar++;
    #####: 1184:			    ptr_tvar++;
        -: 1185:			    /*
        -: 1186:			       Check for a TVAR format.
        -: 1187:			     */
    #####: 1188:			    flen = decode_format (ptr_tvar, 0, &is_cformat,
call    0 never executed
        -: 1189:						  &is_lformat, &is_sign,
        -: 1190:						  &is_lzero, &is_suffix,
        -: 1191:						  &is_fformat, &fstyle,
        -: 1192:						  &fwidth);
    #####: 1193:			    if (fwidth != SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####: 1194:			      ptr_tvar += flen;
        -: 1195:			    /*
        -: 1196:			       Check if a text variable reference is found
        -: 1197:			       which needs to be expanded again.
        -: 1198:			     */
    #####: 1199:			    if ((*tvar != QUOTE_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 1200:				&& isalpha (*ptr_tvar)
branch  0 never executed
branch  1 never executed
    #####: 1201:				&& (rc_tvar[IDX (*ptr_tvar)].tvar_local.
branch  0 never executed
branch  1 never executed
        -: 1202:				    tvar_text != (char *) NULL
    #####: 1203:				    || rc_tvar[IDX (*ptr_tvar)].tvar_global.
branch  0 never executed
branch  1 never executed
        -: 1204:				    tvar_text != (char *) NULL))
        -: 1205:			      {
        -: 1206:				/*
        -: 1207:				   Check if expansion results to invalid recursion.
        -: 1208:				 */
    #####: 1209:				if (*ptr_tvar == the_tvar)
branch  0 never executed
branch  1 never executed
    #####: 1210:				  ok = TRUE;
        -: 1211:				else
    #####: 1212:				  flen = 1;
        -: 1213:				/*
        -: 1214:				   Text variable reference found which needs to be expanded again.
        -: 1215:				 */
    #####: 1216:				break;
        -: 1217:			      }
    #####: 1218:			    n = 1;
    #####: 1219:			    while (*ptr_tvar == RC_TVAR_CHAR)
branch  0 never executed
branch  1 never executed
    #####: 1220:			      ptr_tvar++;
    #####: 1221:			    if (*ptr_tvar)
branch  0 never executed
branch  1 never executed
    #####: 1222:			      ptr_tvar = strchr (ptr_tvar, RC_TVAR_CHAR);
        -: 1223:			    else
    #####: 1224:			      ptr_tvar = (char *) NULL;
        -: 1225:			  }
    #####: 1226:			while (ptr_tvar != (char *) NULL);
branch  0 never executed
branch  1 never executed
    #####: 1227:			if (ptr_tvar == (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1228:			  ok = TRUE;
        -: 1229:		      }
        -: 1230:		    else
        -: 1231:		      /*
        -: 1232:		         All text variable references already expanded.
        -: 1233:		       */
    #####: 1234:		      ok = TRUE;
        -: 1235:		  }
        -: 1236:		else
        -: 1237:		  /*
        -: 1238:		     No text variable references found.
        -: 1239:		   */
    #####: 1240:		  ok = TRUE;
        -: 1241:		/*
        -: 1242:		   If the expansion results to an include directive,
        -: 1243:		   skip the expansion loop and perform the assignment.
        -: 1244:		 */
    #####: 1245:		if (**line_buffer == *RC_INCL_STMENT)
branch  0 never executed
branch  1 never executed
    #####: 1246:		  *is_include = ok = TRUE;
        -: 1247:		else
        -: 1248:		  /*
        -: 1249:		     If the expansion results to a date variable assignment,
        -: 1250:		     skip the expansion loop and perform the assignment.
        -: 1251:		   */
    #####: 1252:		if (isalpha (**line_buffer))
branch  0 never executed
branch  1 never executed
    #####: 1253:		  *is_dvar = ok = TRUE;
        -: 1254:	      }
    #####: 1255:	    while (!ok);
branch  0 never executed
branch  1 never executed
        -: 1256:	  }
        -: 1257:	/*
        -: 1258:	   Check for a local date variable DVAR definition.
        -: 1259:	 */
    #####: 1260:	if (*is_dvar)
branch  0 never executed
branch  1 never executed
    #####: 1261:	  set_dvar (*line_buffer, lptrs3, filename, *line_number, LOcal);
call    0 never executed
        -: 1262:	/*
        -: 1263:	   Check for a local text variable TVAR definition.
        -: 1264:	 */
    #####: 1265:	if (*is_tvar)
branch  0 never executed
branch  1 never executed
    #####: 1266:	  set_tvar (*line_buffer, filename, *line_number, LOcal);
call    0 never executed
        -: 1267:      }
        -: 1268:#endif
        1: 1269:    if (is_error)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1270:      {
        -: 1271:#if USE_RC
    #####: 1272:	if (mode == REsource)
branch  0 never executed
branch  1 never executed
        -: 1273:	  /*
        -: 1274:	     Error, invalid date-"part" given.
        -: 1275:	   */
    #####: 1276:	  i = ERR_INVALID_DATE_FIELD;
        -: 1277:	else
        -: 1278:#endif
        -: 1279:	  /*
        -: 1280:	     Error, illegal NUL character found in file.
        -: 1281:	   */
    #####: 1282:	  i = ERR_ILLEGAL_CHAR_IN_FILE;
    #####: 1283:	my_error (i, filename, *line_number, *line_buffer, 0);
call    0 never executed
        -: 1284:      }
        1: 1285:    if (ch == '\n')
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1286:      *line_length = i - 1;
        -: 1287:    else
        1: 1288:      *line_length = i;
        -: 1289:
        1: 1290:    return (ptr_pool);
        -: 1291:  }
        -: 1292:
        -: 1293:
        -: 1294:
function insert_response_file called 1 returned 100% blocks executed 18%
        1: 1295:  char **insert_response_file (fp, filename, opt_list, my_argc_max, my_argc,
        -: 1296:			       my_argv) FILE *fp;
        -: 1297:  char *filename;
        -: 1298:  const char *opt_list;
        -: 1299:  Uint *my_argc_max;
        -: 1300:  int *my_argc;
        -: 1301:  char *my_argv[];
        -: 1302:/*!
        -: 1303:   Tries to manage a response file @FILE argument given in the command line.
        -: 1304:     Inserts the options and commands found in file @FILE (name delivered
        -: 1305:     in `filename' and its file pointer in `fp') into `my_argv[]' and sets
        -: 1306:     delivered `&my_argc' and perhaps `&my_argc_max' to according "new"
        -: 1307:     values.  Uses the global text buffer `s1' internally.  Returns the
        -: 1308:     build `my_argv[]' ptr vector.
        -: 1309:*/
        -: 1310:  {
        1: 1311:    auto long line_number = 0L;
        -: 1312:    auto int line_length;
        1: 1313:    auto int in_pool = 0;
        1: 1314:    auto char *pool = (char *) NULL;
        1: 1315:    auto char *ptr_pool = (char *) NULL;
        -: 1316:    auto Bool b_dummy;		/* Necessary dummy for `file_read_line()' function. */
        -: 1317:
        -: 1318:
        1: 1319:    pool = (char *) my_malloc (BUF_LEN + 1, ERR_NO_MEMORY_AVAILABLE,
call    0 returned 100%
        -: 1320:			       __FILE__, ((long) __LINE__) - 1L, "pool", 0);
        3: 1321:    while ((ptr_pool =
call    0 returned 100%
branch  1 taken 50%
branch  2 taken 50% (fallthrough)
        -: 1322:	    file_read_line (fp, &s1, &in_pool, pool, ptr_pool, filename,
        -: 1323:			    &line_number, &line_length, REsponse, &b_dummy,
        -: 1324:			    &b_dummy, &b_dummy)) != (char *) NULL)
        1: 1325:      if (*s1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1326:	{
    #####: 1327:	  if ((*s1 == *SWITCH
branch  0 never executed
branch  1 never executed
    #####: 1328:	       || *s1 == *SWITCH2) && s1[1] && (s1[1] != *SWITCH))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1329:	    /*
        -: 1330:	       Short-style option found.
        -: 1331:	     */
    #####: 1332:	    if ((strchr (opt_list, s1[1]) != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1333:		&& isspace (s1[2]))
branch  0 never executed
branch  1 never executed
        -: 1334:	      {
    #####: 1335:		register int spaces = 1;
        -: 1336:
        -: 1337:
        -: 1338:		/*
        -: 1339:		   Short-style option requires an argument, which could be
        -: 1340:		   separated by whitespace characters from the option character;
        -: 1341:		   respect this!  This means all separating whitespace
        -: 1342:		   characters between the option character and argument
        -: 1343:		   will be eliminated.
        -: 1344:		 */
    #####: 1345:		line_length = 2;
    #####: 1346:		while (s1[line_length + spaces]
branch  0 never executed
branch  1 never executed
    #####: 1347:		       && isspace (s1[line_length + spaces]))
branch  0 never executed
branch  1 never executed
        -: 1348:		  /*
        -: 1349:		     Count the separating whitespace characters.
        -: 1350:		   */
    #####: 1351:		  spaces++;
        -: 1352:		/*
        -: 1353:		   Store needed argument of option adjacent to option character.
        -: 1354:		 */
    #####: 1355:		while (s1[line_length + spaces])
branch  0 never executed
branch  1 never executed
        -: 1356:		  {
    #####: 1357:		    s1[line_length] = s1[line_length + spaces];
    #####: 1358:		    line_length++;
        -: 1359:		  }
    #####: 1360:		s1[line_length] = '\0';
        -: 1361:	      }
        -: 1362:	  /*
        -: 1363:	     Avoid one or two letter combinations of '-', '/' or '%' characters only!
        -: 1364:	   */
    #####: 1365:	  if (((line_length == 1) && (*s1 == *SWITCH
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1366:#if USE_RC
    #####: 1367:				      || *s1 == RC_ADATE_CHAR
branch  0 never executed
branch  1 never executed
        -: 1368:#endif
    #####: 1369:				      || *s1 == *SWITCH2))
branch  0 never executed
branch  1 never executed
    #####: 1370:	      || ((line_length == 2) && (*s1 == *SWITCH
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1371:#if USE_RC
    #####: 1372:					 || *s1 == RC_ADATE_CHAR
branch  0 never executed
branch  1 never executed
        -: 1373:#endif
    #####: 1374:					 || *s1 == *SWITCH2)
branch  0 never executed
branch  1 never executed
    #####: 1375:		  && (s1[1] == *SWITCH
branch  0 never executed
branch  1 never executed
        -: 1376:#if USE_RC
    #####: 1377:		      || s1[1] == RC_ADATE_CHAR
branch  0 never executed
branch  1 never executed
        -: 1378:#endif
    #####: 1379:		      || s1[1] == *SWITCH2)))
branch  0 never executed
branch  1 never executed
        -: 1380:	    ;			/* Void, don't allocate memory */
        -: 1381:	  else
        -: 1382:	    {
    #####: 1383:	      if ((Uint) * my_argc >= *my_argc_max)
branch  0 never executed
branch  1 never executed
        -: 1384:		{
        -: 1385:		  /*
        -: 1386:		     Resize the `my_argv[]' table.
        -: 1387:		   */
    #####: 1388:		  *my_argc_max <<= 1;
    #####: 1389:		  if (*my_argc_max * sizeof (char *) > testval)
branch  0 never executed
branch  1 never executed
    #####: 1390:		    (*my_argc_max)--;
    #####: 1391:		  my_argv = (char **) my_realloc ((VOID_PTR) my_argv,
call    0 never executed
    #####: 1392:						  *my_argc_max *
        -: 1393:						  sizeof (char *),
        -: 1394:						  ERR_NO_MEMORY_AVAILABLE,
        -: 1395:						  __FILE__,
        -: 1396:						  ((long) __LINE__) - 3L,
        -: 1397:						  "my_argv[my_argc_max]",
    #####: 1398:						  *my_argc_max);
        -: 1399:		}
    #####: 1400:	      my_argv[*my_argc] = (char *) my_malloc (line_length + 1,
call    0 never executed
        -: 1401:						      ERR_NO_MEMORY_AVAILABLE,
        -: 1402:						      __FILE__,
        -: 1403:						      ((long) __LINE__) - 2L,
        -: 1404:						      "my_argv[my_argc]",
        -: 1405:						      *my_argc);
    #####: 1406:	      strcpy (my_argv[(*my_argc)++], s1);
        -: 1407:	    }
        -: 1408:	}
        1: 1409:    free (pool);
        -: 1410:
        1: 1411:    return (my_argv);
        -: 1412:  }
        -: 1413:
        -: 1414:
        -: 1415:
        -: 1416:  void
function write_log_file called 0 returned 0% blocks executed 0%
    #####: 1417:    write_log_file (filename, mode, mode_txt, created_txt, argc, argv)
        -: 1418:    const char *filename;
        -: 1419:  const Fmode_enum mode;
        -: 1420:  const char *mode_txt;
        -: 1421:  const char *created_txt;
        -: 1422:  const int argc;
        -: 1423:  char *argv[];
        -: 1424:/*!
        -: 1425:   Writes the contents of the environment variable $GCAL, which is already
        -: 1426:     stored in `argc' and the arguments of command line either into a
        -: 1427:     response file (MODE==REsponse) or into a shell script (MODE==SCript);
        -: 1428:     other settings to `mode' will `abort()' the program immediately.
        -: 1429:*/
        -: 1430:  {
    #####: 1431:    auto FILE *fp = (FILE *) NULL;
    #####: 1432:    auto int len = 0;
    #####: 1433:    register int i = 0;
        -: 1434:
        -: 1435:
    #####: 1436:    fp = fopen (filename, "w");
call    0 never executed
    #####: 1437:    if (fp != (FILE *) NULL)
branch  0 never executed
branch  1 never executed
        -: 1438:      {
    #####: 1439:	switch (mode)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 1440:	  {
    #####: 1441:	  case REsponse:
    #####: 1442:	    len =
    #####: 1443:	      fprintf (fp,
call    0 never executed
call    1 never executed
        -: 1444:		       "%c `%s' %s `%s' --- %s %02d-%s-%04d %02d%s%02d%s%02d",
        -: 1445:		       REM_CHAR, prgr_name, mode_txt, filename, created_txt,
        -: 1446:		       true_day, short_month_name (true_month), true_year,
        -: 1447:		       act_hour, time_sep, act_min, time_sep, act_sec);
    #####: 1448:	    if (tz != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1449:	      len = fprintf (fp, " %s", tz);
call    0 never executed
    #####: 1450:	    len = fprintf (fp, "\n%c\n", REM_CHAR);
call    0 never executed
    #####: 1451:	    break;
        -: 1452:#ifdef GCAL_SHELL
    #####: 1453:	  case SCript:
        -: 1454:# if HAVE_SYS_INTERPRETER
    #####: 1455:	    len =
    #####: 1456:	      fprintf (fp,
call    0 never executed
call    1 never executed
        -: 1457:		       "%c%s\n%c\n%c `%s' %s `%s' --- %s %02d-%s-%04d %02d%s%02d%s%02d",
    #####: 1458:		       *SHL_REM, SHELL, *SHL_REM, *SHL_REM, prgr_name,
        -: 1459:		       mode_txt, filename, created_txt, true_day,
        -: 1460:		       short_month_name (true_month), true_year, act_hour,
        -: 1461:		       time_sep, act_min, time_sep, act_sec);
        -: 1462:# else /* !HAVE_SYS_INTERPRETER */
        -: 1463:	    len =
        -: 1464:	      fprintf (fp,
        -: 1465:		       "%c `%s' %s `%s' --- %s %02d-%s-%04 %02d%s%02d%s%02d",
        -: 1466:		       *SHL_REM, prgr_name, mode_txt, filename, created_txt,
        -: 1467:		       true_day, short_month_name (true_month), true_year,
        -: 1468:		       act_hour, time_sep, act_min, time_sep, act_sec);
        -: 1469:# endif	/* !HAVE_SYS_INTERPRETER */
    #####: 1470:	    if (tz != (char *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1471:	      len = fprintf (fp, " %s", tz);
call    0 never executed
    #####: 1472:	    len =
    #####: 1473:	      fprintf (fp, "\n%c\n%s %c\n", *SHL_REM, prgr_name, *SHL_ESC);
call    0 never executed
    #####: 1474:	    break;
        -: 1475:#endif /* GCAL_SHELL */
    #####: 1476:	  default:
        -: 1477:	    /*
        -: 1478:	       This case MUST be an internal error!
        -: 1479:	     */
    #####: 1480:	    abort ();
call    0 never executed
        -: 1481:	  }
    #####: 1482:	if (len != EOF)
branch  0 never executed
branch  1 never executed
        -: 1483:	  {
    #####: 1484:	    for (i = 1; i < argc; i++)
branch  0 never executed
branch  1 never executed
        -: 1485:	      {
        -: 1486:		/*
        -: 1487:		   Don't write the name of a response file or
        -: 1488:		   of a shell script into the response file!
        -: 1489:		 */
    #####: 1490:		if (*argv[i] == *SWITCH || *argv[i] == *SWITCH2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1491:		  {
        -: 1492:		    /*
        -: 1493:		       If the short-style option -R<NAME> or -S<NAME> is given, skip it!
        -: 1494:		     */
    #####: 1495:		    if (*(argv[i] + 1) == 'R'
branch  0 never executed
branch  1 never executed
        -: 1496:#ifdef GCAL_SHELL
    #####: 1497:			|| *(argv[i] + 1) == 'S'
branch  0 never executed
branch  1 never executed
        -: 1498:#endif
        -: 1499:		      )
    #####: 1500:		      continue;
    #####: 1501:		    if (*(argv[i] + 1) == *SWITCH)
branch  0 never executed
branch  1 never executed
        -: 1502:		      {
        -: 1503:			/*
        -: 1504:			   Detect whether the long-style option `--response-file=ARG'
        -: 1505:			   or `--shell-script=ARG' is given and if found,
        -: 1506:			   don't write this option itself into the response file!
        -: 1507:			 */
    #####: 1508:			strcpy (s4, argv[i] + 2);
    #####: 1509:			(void) eval_longopt (s4, &len);
call    0 never executed
    #####: 1510:			if (len == SYM_RESPONSE_FILE)
branch  0 never executed
branch  1 never executed
    #####: 1511:			  continue;
        -: 1512:#ifdef GCAL_SHELL
    #####: 1513:			if (len == SYM_SCRIPT_FILE)
branch  0 never executed
branch  1 never executed
    #####: 1514:			  continue;
        -: 1515:#endif
        -: 1516:		      }
        -: 1517:		  }
    #####: 1518:		if (*argv[i] == RSP_CHAR)
branch  0 never executed
branch  1 never executed
        -: 1519:		  /*
        -: 1520:		     Avoid to write a response file @FILE argument into the resulting file.
        -: 1521:		   */
    #####: 1522:		  continue;
    #####: 1523:		switch (mode)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 1524:		  {
    #####: 1525:		  case REsponse:
    #####: 1526:		    len = fprintf (fp, "%s\n", argv[i]);
call    0 never executed
    #####: 1527:		    break;
        -: 1528:#ifdef GCAL_SHELL
    #####: 1529:		  case SCript:
    #####: 1530:		    len = fprintf (fp, "'%s' %c\n", argv[i], *SHL_ESC);
call    0 never executed
    #####: 1531:		    break;
        -: 1532:#endif
    #####: 1533:		  default:
        -: 1534:		    /*
        -: 1535:		       This case can't occur anymore, if so, it MUST be an internal error!
        -: 1536:		     */
    #####: 1537:		    abort ();
call    0 never executed
        -: 1538:		  }
    #####: 1539:		if (len == EOF)
branch  0 never executed
branch  1 never executed
    #####: 1540:		  break;
        -: 1541:	      }
        -: 1542:#ifdef GCAL_SHELL
    #####: 1543:	    if (mode == SCript)
branch  0 never executed
branch  1 never executed
    #####: 1544:	      len = fprintf (fp, " $*\n");
call    0 never executed
        -: 1545:#endif
    #####: 1546:	    i = fclose (fp);
call    0 never executed
        -: 1547:	  }
        -: 1548:      }
        -: 1549:    else
    #####: 1550:      len = EOF;
    #####: 1551:    if (i == EOF)
branch  0 never executed
branch  1 never executed
    #####: 1552:      len = EOF;
    #####: 1553:    if (((len != EOF)
branch  0 never executed
branch  1 never executed
    #####: 1554:	 && (warning_level == 1))
branch  0 never executed
branch  1 never executed
    #####: 1555:	|| ((len == EOF) && (warning_level == 2)) || warning_level > 2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1556:      {
    #####: 1557:	i = (int) strlen (filename)
    #####: 1558:	  + MAX (ehls1s.len, ehls2s.len)
    #####: 1559:	  + MAX (ehls1e.len, ehls2e.len) + LEN_SINGLE_LINE;
    #####: 1560:	if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1561:	  resize_all_strings (i + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####: 1562:	sprintf (s4, _("Try to write %s `%s'... %s%s%s"), mode_txt, filename,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1563:		 (ehls1s.len !=
    #####: 1564:		  1) ? ((len == EOF) ? ehls2s.seq : ehls1s.seq) : "",
branch  0 never executed
branch  1 never executed
    #####: 1565:		 (len == EOF) ? _("failed") : _("success"),
    #####: 1566:		 (ehls1s.len !=
    #####: 1567:		  1) ? ((len == EOF) ? ehls2e.seq : ehls1e.seq) : "");
branch  0 never executed
branch  1 never executed
    #####: 1568:	print_text (stderr, s4);
call    0 never executed
        -: 1569:	/*
        -: 1570:	   Terminate the program in case the file can't be written!
        -: 1571:	 */
    #####: 1572:	if ((len == EOF) && (warning_level >= WARN_LVL_MAX))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1573:	  my_error (ERR_WRITE_FILE, __FILE__, (long) __LINE__, filename, 0);
call    0 never executed
        -: 1574:      }
        -: 1575:#ifdef GCAL_SHELL
    #####: 1576:    if ((mode == SCript) && (len != EOF))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1577:      {
        -: 1578:	/*
        -: 1579:	   Try to make the created shell script executable!
        -: 1580:	 */
    #####: 1581:	i =
    #####: 1582:	  (int) strlen (filename) + strlen (CHMOD_PRGR) +
    #####: 1583:	  strlen (CHMOD_OPTS) + 2;
    #####: 1584:	if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1585:	  resize_all_strings (i + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####: 1586:	sprintf (s4, "%s %s %s", CHMOD_PRGR, CHMOD_OPTS, filename);
        -: 1587:	/*
        -: 1588:	   And ignore any errors...
        -: 1589:	 */
    #####: 1590:	(void) my_system (s4);
call    0 never executed
        -: 1591:      }
        -: 1592:#endif /* GCAL_SHELL */
    #####: 1593:  }
        -: 1594:
        -: 1595:
        -: 1596:
        -: 1597:  static void
function make_absolute_filename called 4 returned 100% blocks executed 86%
        4: 1598:    make_absolute_filename (absolute_filename, directory, filename)
        -: 1599:    char **absolute_filename;
        -: 1600:  const char *directory;
        -: 1601:  const char *filename;
        -: 1602:/*!
        -: 1603:   Creates an absolute file name (directory+file name) of a delivered
        -: 1604:     file name and directory and returns it in delivered `&absolute_filename'.
        -: 1605:*/
        -: 1606:  {
        4: 1607:    register int dir_len = (int) strlen (directory);
        4: 1608:    register int fil_len = (int) strlen (filename);
        -: 1609:
        -: 1610:
        4: 1611:    if (directory[dir_len - 1] != *DIR_SEP)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4: 1612:      dir_len++;
        4: 1613:    if ((Uint) dir_len + fil_len >= maxlen_max)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1614:      resize_all_strings (dir_len + fil_len + 1, FALSE, __FILE__,
call    0 never executed
        -: 1615:			  (long) __LINE__);
        4: 1616:    strcpy (*absolute_filename, directory);
        4: 1617:    if (directory[dir_len - 1] != *DIR_SEP)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4: 1618:      strcat (*absolute_filename, DIR_SEP);
        4: 1619:    strcat (*absolute_filename, filename);
        4: 1620:  }
        -: 1621:
        -: 1622:
        -: 1623:
function get_file_ptr called 4 returned 100% blocks executed 15%
        4: 1624:  static FILE *get_file_ptr (fp, filename, level, mode, is_first) FILE *fp;
        -: 1625:  const char *filename;
        -: 1626:  const int level;
        -: 1627:  const Fmode_enum mode;
        -: 1628:  Bool *is_first;
        -: 1629:/*!
        -: 1630:   Tries to open the file (with optional diagnostic messages on STDERR channel
        -: 1631:     in case the `--debug[=0...WARN_LVL_MAX]' option is set) and returns a
        -: 1632:     valid file pointer of that file, or NULL if this fails.
        -: 1633:*/
        -: 1634:  {
        -: 1635:#if HAVE_SYS_STAT_H && defined(S_IFMT) && defined(S_IFREG)
        -: 1636:    auto struct stat statbuf;
        -: 1637:
        -: 1638:
        4: 1639:    fp = (FILE *) NULL;
        -: 1640:    /*
        -: 1641:       Check whether STDIN channel is wanted.
        -: 1642:     */
        4: 1643:    if ((*filename == '-') && (strlen (filename) == 1))
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 1644:      fp = stdin;
        -: 1645:    else
        -: 1646:      /*
        -: 1647:         Test if the file is a regular file, if not, ignore it!
        -: 1648:       */
        3: 1649:    if (!stat (filename, &statbuf))
call    0 returned 100%
branch  1 taken 33% (fallthrough)
branch  2 taken 67%
        1: 1650:      if ((statbuf.st_mode & S_IFMT) == S_IFREG)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1651:	fp = fopen (filename, "r");
call    0 never executed
        -: 1652:#else /* !HAVE_SYS_STAT_H || !S_IFMT || !S_IFREG */
        -: 1653:    if ((*filename == '-') && (strlen (filename) == 1))
        -: 1654:      fp = stdin;
        -: 1655:    else
        -: 1656:      fp = fopen (filename, "r");
        -: 1657:#endif /* !HAVE_SYS_STAT_H || !S_IFMT || !S_IFREG */
        4: 1658:    if ((warning_level >= 0) && (mode != REsponse) && (mode != COmmon))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1659:#if USE_RC
        -: 1660:      {
    #####: 1661:	if (((fp != (FILE *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1662:	     && (warning_level == 1))
branch  0 never executed
branch  1 never executed
    #####: 1663:	    || ((fp == (FILE *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1664:		&& (warning_level == 2)) || warning_level > 2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1665:	  {
        -: 1666:	    register int i;
        -: 1667:
        -: 1668:
        -: 1669:	    /*
        -: 1670:	       If this function is entered the first time:
        -: 1671:	       Print a leading NEWLINE character before any information texts.
        -: 1672:	     */
    #####: 1673:	    if (*is_first)
branch  0 never executed
branch  1 never executed
        -: 1674:	      {
    #####: 1675:		*is_first = FALSE;
    #####: 1676:		*s4 = '\0';
    #####: 1677:		print_text (stderr, s4);
call    0 never executed
        -: 1678:	      }
    #####: 1679:	    i = (int) strlen (filename)
    #####: 1680:	      + MAX (ehls1s.len, ehls2s.len)
    #####: 1681:	      + MAX (ehls1e.len, ehls2e.len) + LEN_SINGLE_LINE;
    #####: 1682:	    if ((Uint) i >= maxlen_max)
branch  0 never executed
branch  1 never executed
    #####: 1683:	      resize_all_strings (i + 1, FALSE, __FILE__, (long) __LINE__);
call    0 never executed
    #####: 1684:	    if (mode == REsource || mode == HEre)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1685:	      sprintf (s4, _("Try to open%sresource file `%s'... %s%s%s"),
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1686:		       (mode == REsource) ? " " : _(" `HERE' "), filename,
    #####: 1687:		       (ehls1s.len !=
        -: 1688:			1) ? ((fp ==
    #####: 1689:			       (FILE *) NULL) ? ehls2s.seq : ehls1s.seq) : "",
branch  0 never executed
branch  1 never executed
        -: 1690:		       (fp == (FILE *) NULL) ? _("failed") : _("success"),
    #####: 1691:		       (ehls1s.len !=
        -: 1692:			1) ? ((fp ==
    #####: 1693:			       (FILE *) NULL) ? ehls2e.seq : ehls1e.
branch  0 never executed
branch  1 never executed
        -: 1694:			      seq) : "");
        -: 1695:	    else
    #####: 1696:	      sprintf (s4,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1697:		       _
        -: 1698:		       ("Try to open (level: %02d) include file `%s'... %s%s%s"),
        -: 1699:		       level, filename,
    #####: 1700:		       (ehls1s.len !=
        -: 1701:			1) ? ((fp ==
    #####: 1702:			       (FILE *) NULL) ? ehls2s.seq : ehls1s.seq) : "",
branch  0 never executed
branch  1 never executed
        -: 1703:		       (fp == (FILE *) NULL) ? _("failed") : _("success"),
    #####: 1704:		       (ehls1s.len !=
        -: 1705:			1) ? ((fp ==
    #####: 1706:			       (FILE *) NULL) ? ehls2e.seq : ehls1e.
branch  0 never executed
branch  1 never executed
        -: 1707:			      seq) : "");
    #####: 1708:	    print_text (stderr, s4);
call    0 never executed
        -: 1709:	  }
        -: 1710:      }
        -: 1711:#else /* !USE_RC */
        -: 1712:      ;				/* Void, no text to display */
        -: 1713:#endif /* !USE_RC */
        -: 1714:
        4: 1715:    return (fp);
        -: 1716:  }
