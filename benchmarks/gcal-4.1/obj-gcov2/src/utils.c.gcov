        -:    0:Source:../../src/utils.c
        -:    0:Programs:20
        -:    1:/*!
        -:    2:*  \file utils.c
        -:    3:*  \brief Pool of common functions.
        -:    4:*/
        -:    5:/*
        -:    6:*  Copyright (c) 1994, 95, 96, 1997, 2000, 2011 Thomas Esken
        -:    7:*  Copyright (c) 2010, 2011, 2013, 2014 Free Software Foundation, Inc.
        -:    8:*
        -:    9:*  This software doesn't claim completeness, correctness or usability.
        -:   10:*  On principle I will not be liable for ANY damages or losses (implicit
        -:   11:*  or explicit), which result from using or handling my software.
        -:   12:*  If you use this software, you agree without any exception to this
        -:   13:*  agreement, which binds you LEGALLY !!
        -:   14:*
        -:   15:*  This program is free software; you can redistribute it and/or modify
        -:   16:*  it under the terms of the `GNU General Public License' as published by
        -:   17:*  the `Free Software Foundation'; either version 3, or (at your option)
        -:   18:*  any later version.
        -:   19:*
        -:   20:*  You should have received a copy of the `GNU General Public License'
        -:   21:*  along with this program; if not, write to the:
        -:   22:*
        -:   23:*/
        -:   24:
        -:   25:
        -:   26:
        -:   27:/*
        -:   28:*  Include header files.
        -:   29:*/
        -:   30:#include "tailor.h"
        -:   31:#if HAVE_CTYPE_H
        -:   32:# include <ctype.h>
        -:   33:#endif
        -:   34:#if HAVE_ERRNO_H
        -:   35:# include <errno.h>
        -:   36:#endif
        -:   37:#if HAVE_UNISTD_H
        -:   38:# include <unistd.h>
        -:   39:#endif
        -:   40:#if TIME_WITH_SYS_TIME
        -:   41:# include <sys/time.h>
        -:   42:# include <time.h>
        -:   43:#else /* !TIME_WITH_SYS_TIME */
        -:   44:# if HAVE_SYS_TIME_H
        -:   45:#  include <sys/time.h>
        -:   46:# else /* !HAVE_SYS_TIME_H */
        -:   47:#  include <time.h>
        -:   48:# endif	/* !HAVE_SYS_TIME_H */
        -:   49:#endif /* !TIME_WITH_SYS_TIME */
        -:   50:#include "common.h"
        -:   51:#if USE_RC
        -:   52:# include "rc-defs.h"
        -:   53:#endif /* USE_RC */
        -:   54:#include "globals.h"
        -:   55:#include "hd-defs.h"
        -:   56:#include "hd-use.h"
        -:   57:#if USE_RC
        -:   58:# include "rc-utils.h"
        -:   59:#endif /* USE_RC */
        -:   60:#include "utils.h"
        -:   61:
        -:   62:
        -:   63:
        -:   64:/*
        -:   65:*  static functions prototypes.
        -:   66:*/
        -:   67:__BEGIN_DECLARATIONS
        -:   68:/*
        -:   69:************************************************** Defined in `utils.c'.
        -:   70:*/
        -:   71:static void gregorian2julian __P_ ((int *day, int *month, int *year));
        -:   72:static int
        -:   73:  raw_week_number __P_ ((const int day,
        -:   74:			 const int month,
        -:   75:			 const int year,
        -:   76:			 const Bool is_iso_week,
        -:   77:			 const int start_day_of_week));
        -:   78:static const char *dflt_day_name __P_ ((const int day));
        -:   79:static const char *dflt_month_name __P_ ((const int month));
        -:   80:__END_DECLARATIONS
        -:   81:/*
        -:   82:*  Function implementations.
        -:   83:*/
        -:   84:  VOID_PTR
function my_malloc called 2303 returned 100% blocks executed 67%
     2303:   85:my_malloc (amount, exit_status, module_name, module_line, var_name,
        -:   86:	   var_contents)
        -:   87:     const int amount;
        -:   88:     const int exit_status;
        -:   89:     const char *module_name;
        -:   90:     const long module_line;
        -:   91:     const char *var_name;
        -:   92:     const int var_contents;
        -:   93:/*!
        -:   94:   Allocates AMOUNT bytes of memory dynamically, with error checking.
        -:   95:     Calls `my_error()' and terminates the program if any errors occur.
        -:   96:     AMOUNT is limited to `int' range instead of `size_t' range;
        -:   97:     this is wanted!
        -:   98:*/
        -:   99:{
        -:  100:  auto VOID_PTR ptr_memblock;
        -:  101:
        -:  102:
     2303:  103:  if ((Uint) amount > testval)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  104:    /*
        -:  105:       Error, table size overflow!
        -:  106:     */
    #####:  107:    my_error (ERR_INTERNAL_TABLE_CRASH, module_name, module_line, var_name,
call    0 never executed
        -:  108:	      (int) testval);
     2303:  109:  ptr_memblock = (VOID_PTR) malloc ((int) amount);
     2303:  110:  if (ptr_memblock == (VOID_PTR) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  111:    /*
        -:  112:       Error, `malloc()' function failed.
        -:  113:     */
    #####:  114:    my_error (exit_status, module_name, module_line, var_name, var_contents);
call    0 never executed
        -:  115:
     2303:  116:  return (ptr_memblock);
        -:  117:}
        -:  118:
        -:  119:
        -:  120:
        -:  121:VOID_PTR
function my_realloc called 68 returned 100% blocks executed 63%
       68:  122:my_realloc (ptr_memblock, amount, exit_status, module_name, module_line,
        -:  123:	    var_name, var_contents)
        -:  124:     VOID_PTR ptr_memblock;
        -:  125:     const int amount;
        -:  126:     const int exit_status;
        -:  127:     const char *module_name;
        -:  128:     const long module_line;
        -:  129:     const char *var_name;
        -:  130:     const int var_contents;
        -:  131:/*!
        -:  132:   Changes the size of an allocated block of memory PTR_MEMBLOCK to AMOUNT
        -:  133:     bytes, with error checking.  Calls `my_error()' and terminates the program
        -:  134:     if any errors occur.  AMOUNT is limited to `int' range instead of `size_t'
        -:  135:     range; this is wanted!  If PTR_MEMBLOCK is NULL, `my_malloc()' is called
        -:  136:     instead.
        -:  137:*/
        -:  138:{
       68:  139:  if ((Uint) amount > testval)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  140:    /*
        -:  141:       Error, table size overflow!
        -:  142:     */
    #####:  143:    my_error (ERR_INTERNAL_TABLE_CRASH, module_name, module_line, var_name,
call    0 never executed
        -:  144:	      (int) testval);
       68:  145:  if (ptr_memblock == (VOID_PTR) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  146:    return (my_malloc
call    0 never executed
        -:  147:	    (amount, exit_status, module_name, module_line, var_name,
        -:  148:	     var_contents));
       68:  149:  ptr_memblock = (VOID_PTR) realloc (ptr_memblock, (int) amount);
       68:  150:  if (ptr_memblock == (VOID_PTR) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  151:    /*
        -:  152:       Error, `realloc()' function failed.
        -:  153:     */
    #####:  154:    my_error (exit_status, module_name, module_line, var_name, var_contents);
call    0 never executed
        -:  155:
       68:  156:  return (ptr_memblock);
        -:  157:}
        -:  158:
        -:  159:
        -:  160:
        -:  161:void
function allocate_all_strings called 98 returned 100% blocks executed 100%
       98:  162:allocate_all_strings (amount, module_name, module_line)
        -:  163:     const int amount;
        -:  164:     const char *module_name;
        -:  165:     const long module_line;
        -:  166:/*!
        -:  167:   Initially allocates AMOUNT bytes of memory dynamically for all string
        -:  168:     vectors used, with error checking.  Calls `my_error()' indirectly and
        -:  169:     terminates the program if any errors occur.  AMOUNT is limited to `int'
        -:  170:     range instead of `size_t' range; this is wanted!  Can only be called once!
        -:  171:*/
        -:  172:{
        -:  173:  static Bool all_strings_initialized = FALSE;
        -:  174:
        -:  175:
       98:  176:  if (!all_strings_initialized)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  177:    {
       98:  178:      s1 = (char *) my_malloc (amount,
call    0 returned 100%
        -:  179:			       ERR_NO_MEMORY_AVAILABLE,
        -:  180:			       module_name, module_line, "s1", 0);
       98:  181:      s2 = (char *) my_malloc (amount,
call    0 returned 100%
        -:  182:			       ERR_NO_MEMORY_AVAILABLE,
        -:  183:			       module_name, module_line, "s2", 0);
       98:  184:      s3 = (char *) my_malloc (amount,
call    0 returned 100%
        -:  185:			       ERR_NO_MEMORY_AVAILABLE,
        -:  186:			       module_name, module_line, "s3", 0);
       98:  187:      s4 = (char *) my_malloc (amount,
call    0 returned 100%
        -:  188:			       ERR_NO_MEMORY_AVAILABLE,
        -:  189:			       module_name, module_line, "s4", 0);
        -:  190:#if USE_RC
       98:  191:      s5 = (char *) my_malloc (amount,
call    0 returned 100%
        -:  192:			       ERR_NO_MEMORY_AVAILABLE,
        -:  193:			       module_name, module_line, "s5", 0);
       98:  194:      s6 = (char *) my_malloc (amount,
call    0 returned 100%
        -:  195:			       ERR_NO_MEMORY_AVAILABLE,
        -:  196:			       module_name, module_line, "s6", 0);
       98:  197:      s7 = (char *) my_malloc (amount,
call    0 returned 100%
        -:  198:			       ERR_NO_MEMORY_AVAILABLE,
        -:  199:			       module_name, module_line, "s7", 0);
       98:  200:      line_buffer = (char *) my_malloc (amount,
call    0 returned 100%
        -:  201:					ERR_NO_MEMORY_AVAILABLE,
        -:  202:					module_name, module_line,
        -:  203:					"line_buffer", 0);
        -:  204:#endif
       98:  205:      all_strings_initialized = TRUE;
        -:  206:    }
       98:  207:}
        -:  208:
        -:  209:
        -:  210:
        -:  211:void
function resize_all_strings called 0 returned 0% blocks executed 0%
    #####:  212:resize_all_strings (amount, with_line_buffer, module_name, module_line)
        -:  213:     const int amount;
        -:  214:     const Bool with_line_buffer;
        -:  215:     const char *module_name;
        -:  216:     const long module_line;
        -:  217:/*!
        -:  218:   Changes the size of all string vectors used to AMOUNT bytes, with error
        -:  219:     checking.  Calls `my_error()' indirectly and terminates the program
        -:  220:     if any errors occur. AMOUNT is limited to `int' range instead of `size_t'
        -:  221:     range; this is wanted!
        -:  222:*/
        -:  223:{
    #####:  224:  if (((Uint) amount > testval) && (maxlen_max < testval))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  225:    maxlen_max = testval;
        -:  226:  else
    #####:  227:    maxlen_max = (Uint) amount;
    #####:  228:  s1 = (char *) my_realloc ((VOID_PTR) s1, maxlen_max,
call    0 never executed
        -:  229:			    ERR_NO_MEMORY_AVAILABLE,
        -:  230:			    module_name, module_line, "s1", maxlen_max);
    #####:  231:  s2 = (char *) my_realloc ((VOID_PTR) s2, maxlen_max,
call    0 never executed
        -:  232:			    ERR_NO_MEMORY_AVAILABLE,
        -:  233:			    module_name, module_line, "s2", maxlen_max);
    #####:  234:  s3 = (char *) my_realloc ((VOID_PTR) s3, maxlen_max,
call    0 never executed
        -:  235:			    ERR_NO_MEMORY_AVAILABLE,
        -:  236:			    module_name, module_line, "s3", maxlen_max);
    #####:  237:  s4 = (char *) my_realloc ((VOID_PTR) s4, maxlen_max,
call    0 never executed
        -:  238:			    ERR_NO_MEMORY_AVAILABLE,
        -:  239:			    module_name, module_line, "s4", maxlen_max);
        -:  240:#if USE_RC
    #####:  241:  s5 = (char *) my_realloc ((VOID_PTR) s5, maxlen_max,
call    0 never executed
        -:  242:			    ERR_NO_MEMORY_AVAILABLE,
        -:  243:			    module_name, module_line, "s5", maxlen_max);
    #####:  244:  s6 = (char *) my_realloc ((VOID_PTR) s6, maxlen_max,
call    0 never executed
        -:  245:			    ERR_NO_MEMORY_AVAILABLE,
        -:  246:			    module_name, module_line, "s6", maxlen_max);
    #####:  247:  s7 = (char *) my_realloc ((VOID_PTR) s7, maxlen_max,
call    0 never executed
        -:  248:			    ERR_NO_MEMORY_AVAILABLE,
        -:  249:			    module_name, module_line, "s7", maxlen_max);
    #####:  250:  if (with_line_buffer)
branch  0 never executed
branch  1 never executed
    #####:  251:    line_buffer = (char *) my_realloc ((VOID_PTR) line_buffer, maxlen_max,
call    0 never executed
        -:  252:				       ERR_NO_MEMORY_AVAILABLE,
        -:  253:				       module_name, module_line,
        -:  254:				       "line_buffer", maxlen_max);
        -:  255:#endif
    #####:  256:}
        -:  257:
        -:  258:
        -:  259:
        -:  260:void
function my_error called 1 returned 0% blocks executed 21%
        1:  261:my_error (exit_status, module_name, module_line, var_name, var_contents)
        -:  262:     const int exit_status;
        -:  263:     const char *module_name;
        -:  264:     const long module_line;
        -:  265:     const char *var_name;
        -:  266:     const int var_contents;
        -:  267:/*!
        -:  268:   Displays a specific error message on STDERR channel
        -:  269:     and terminates the program with status `exit_status'.
        -:  270:*/
        -:  271:{
        1:  272:  S_NEWLINE (stderr);
call    0 returned 100%
        1:  273:  if (prgr_name == (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  274:    prgr_name = PACKAGE_NAME;
        1:  275:  fprintf (stderr, _("%s: abort, "), prgr_name);
call    0 returned 100%
        1:  276:  switch (exit_status)
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 100%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
        -:  277:    {
    #####:  278:    case ERR_INVALID_EASTER_DATE:
    #####:  279:      fprintf (stderr,
call    0 never executed
        -:  280:	       _
        -:  281:	       ("invalid year for computing Easter Sundays date\nYear must be in range (%d...%d)"),
        -:  282:	       EASTER_MIN, EASTER_MAX);
    #####:  283:      break;
    #####:  284:    case ERR_NO_MEMORY_AVAILABLE:
    #####:  285:      fprintf (stderr, _("`%s' line %ld: virtual memory exhausted (%s=%d)"),
call    0 never executed
        -:  286:	       module_name, module_line, var_name, var_contents);
    #####:  287:      break;
        -:  288:#if USE_RC
    #####:  289:    case ERR_INVALID_DATE_FIELD:
    #####:  290:      fprintf (stderr, _("invalid date part in file `%s'\nLine %ld: %s"),
call    0 never executed
        -:  291:	       module_name, module_line, var_name);
    #####:  292:      break;
    #####:  293:    case ERR_INVALID_MONTH_FIELD:
    #####:  294:      fprintf (stderr,
call    0 never executed
        -:  295:	       _("invalid month field(%02d) in file `%s'\nLine %ld: %s"),
        -:  296:	       var_contents, module_name, module_line, var_name);
    #####:  297:      break;
    #####:  298:    case ERR_INVALID_DAY_FIELD:
    #####:  299:      fprintf (stderr,
call    0 never executed
        -:  300:	       _("invalid day field(%02d) in file `%s'\nLine %ld: %s"),
        -:  301:	       var_contents, module_name, module_line, var_name);
    #####:  302:      break;
    #####:  303:    case ERR_MALFORMED_INCLUDE:
    #####:  304:      fprintf (stderr, _("malformed %s in file `%s'\nLine %ld: %s"),
call    0 never executed
        -:  305:	       RC_INCL_STMENT, module_name, module_line, var_name);
    #####:  306:      break;
    #####:  307:    case ERR_CYCLIC_INCLUDE:
    #####:  308:      fprintf (stderr,
call    0 never executed
        -:  309:	       _("invalid recursive/cyclic %s in file `%s'\nLine %ld: %s"),
        -:  310:	       RC_INCL_STMENT, module_name, module_line, var_name);
    #####:  311:      break;
    #####:  312:    case ERR_FILE_NOT_FOUND:
    #####:  313:      fprintf (stderr, _("file `%s' not found"), module_name);
call    0 never executed
    #####:  314:      break;
    #####:  315:    case ERR_INVALID_NWD_FIELD:
    #####:  316:      fprintf (stderr,
call    0 never executed
        -:  317:	       _("invalid N'th weekday field(%d) in file `%s'\nLine %ld: %s"),
        -:  318:	       var_contents, module_name, module_line, var_name);
    #####:  319:      break;
    #####:  320:    case ERR_NO_SEPARATOR_CHAR:
    #####:  321:      fprintf (stderr,
call    0 never executed
        -:  322:	       _
        -:  323:	       ("missing `whitespace' character after date part in file `%s'\nLine %ld: %s"),
        -:  324:	       module_name, module_line, var_name);
    #####:  325:      break;
        -:  326:#endif	/* USE_RC */
    #####:  327:    case ERR_WRITE_FILE:
    #####:  328:      fprintf (stderr, _("file `%s' can't be written\nStorage media full!"),
call    0 never executed
        -:  329:	       var_name);
    #####:  330:      break;
        -:  331:#ifdef GCAL_EMAIL
    #####:  332:    case ERR_EMAIL_SEND_FAILURE:
    #####:  333:      fprintf (stderr, _("sending eMail to <%s> failed"), var_name);
call    0 never executed
        -:  334:# if HAVE_ERRNO_H
    #####:  335:      fprintf (stderr, _("\n`%s' line %ld: "), module_name, module_line);
call    0 never executed
    #####:  336:      perror ("perror");
call    0 never executed
        -:  337:# endif
    #####:  338:      break;
        -:  339:#endif
        -:  340:#if defined(GCAL_EPAGER) || defined(GCAL_EMAIL) || USE_RC
    #####:  341:    case ERR_INTERNAL_C_FUNC_FAILURE:
    #####:  342:      fprintf (stderr, _("`%s' line %ld: (`%s') `%s%d' failed"),
call    0 never executed
        -:  343:	       module_name, module_line, _("Internal"), var_name,
        -:  344:	       var_contents);
        -:  345:# if HAVE_ERRNO_H
    #####:  346:      perror ("\nperror");
call    0 never executed
        -:  347:# endif
    #####:  348:      break;
        -:  349:#endif
        1:  350:    case ERR_READ_FILE:
        1:  351:      fprintf (stderr, _("read error in file `%s'"), var_name);
call    0 returned 100%
        -:  352:#if HAVE_ERRNO_H
        1:  353:      fprintf (stderr, _("\n`%s' line %ld: "), module_name, module_line);
call    0 returned 100%
        1:  354:      perror ("perror");
call    0 returned 100%
        -:  355:#endif
        1:  356:      break;
    #####:  357:    case ERR_ILLEGAL_CHAR_IN_FILE:
    #####:  358:      fprintf (stderr,
call    0 never executed
        -:  359:	       _("illegal character in response file `%s'\nLine %ld: %s"),
        -:  360:	       module_name, module_line, var_name);
    #####:  361:      break;
    #####:  362:    case ERR_INTERNAL_TABLE_CRASH:
    #####:  363:      fprintf (stderr,
call    0 never executed
        -:  364:	       _
        -:  365:	       ("`%s' line %ld: (`%s') invalid value for table size `sizeof %s>%d'"),
        -:  366:	       module_name, module_line, _("Internal"), var_name,
        -:  367:	       var_contents);
    #####:  368:      break;
    #####:  369:    case ERR_INVALID_DATE_FORMAT:
    #####:  370:      fprintf (stderr, _("(`%s') date format `%s' is invalid"), module_name,
call    0 never executed
        -:  371:	       var_name);
    #####:  372:      break;
        -:  373:#if USE_RC
    #####:  374:    case ERR_INVALID_REGEX_PATTERN:
    #####:  375:      if (*module_name)
branch  0 never executed
branch  1 never executed
    #####:  376:	fprintf (stderr, _("%s in search pattern `%s'"), module_name,
call    0 never executed
        -:  377:		 var_name);
        -:  378:      else
    #####:  379:	fprintf (stderr, _("invalid search pattern `%s' specified"),
call    0 never executed
        -:  380:		 var_name);
    #####:  381:      break;
        -:  382:#endif	/* USE_RC */
    #####:  383:    default:
    #####:  384:      fprintf (stderr, _("`%s' line %ld: (`%s') unmanaged error (%d)"),
call    0 never executed
        -:  385:	       module_name, module_line, _("internal"), exit_status);
        -:  386:    }
        1:  387:  S_NEWLINE (stderr);
call    0 returned 100%
        1:  388:  my_exit (exit_status);
call    0 returned 0%
    #####:  389:}
        -:  390:
        -:  391:
        -:  392:
        -:  393:#if HAVE_SIGNAL && (defined(SIGINT) || defined(SIGTERM) || defined(SIGHUP))
        -:  394:RETSIGTYPE
function handle_signal called 0 returned 0% blocks executed 0%
    #####:  395:handle_signal (the_signal)
        -:  396:     int the_signal;
        -:  397:/*!
        -:  398:   Signal handler function which displays the numeric ID of the
        -:  399:     received signal on STDERR channel and terminates the program
        -:  400:     with ERR_TERMINATION_BY_SIGNAL exit status.
        -:  401:*/
        -:  402:{
    #####:  403:  fflush (stdout);
call    0 never executed
    #####:  404:  fprintf (stderr, _("\n%s: program aborted by signal %d\n"), prgr_name,
call    0 never executed
        -:  405:	   the_signal);
    #####:  406:  my_exit (ERR_TERMINATION_BY_SIGNAL);
call    0 never executed
    #####:  407:}
        -:  408:#endif /* HAVE_SIGNAL && (SIGINT || SIGTERM || SIGHUP) */
        -:  409:
        -:  410:
        -:  411:
        -:  412:void
function my_exit called 35 returned 0% blocks executed 54%
       35:  413:my_exit (exit_status)
        -:  414:     const int exit_status;
        -:  415:/*!
        -:  416:   Tries to erase all temporary files before without error checking
        -:  417:     and quits the program by calling the systems `exit()' function.
        -:  418:*/
        -:  419:{
        -:  420:#if USE_RC
       35:  421:  if (rc_tvar_tfp != (FILE *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  422:    (void) fclose (rc_tvar_tfp);
call    0 never executed
       35:  423:  if (rc_tvar_tfn != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  424:    (void) unlink (rc_tvar_tfn);
call    0 never executed
       35:  425:  if (rc_here_fp != (FILE *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  426:    (void) fclose (rc_here_fp);
call    0 never executed
       35:  427:  if (rc_here_fn != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  428:    (void) unlink (rc_here_fn);
call    0 never executed
        -:  429:#endif
        -:  430:#ifdef GCAL_EMAIL
       35:  431:  if (tfp != (FILE *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  432:    (void) fclose (tfp);
call    0 never executed
       35:  433:  if (tfn != (char *) NULL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  434:    (void) unlink (tfn);
call    0 never executed
        -:  435:#endif
       35:  436:  exit (exit_status);
        -:  437:}
        -:  438:
        -:  439:
        -:  440:
        -:  441:int
function my_atoi called 23 returned 100% blocks executed 100%
       23:  442:my_atoi (string)
        -:  443:     const char *string;
        -:  444:/*!
        -:  445:   Converts given `string' to a positiv integer value
        -:  446:     skipping leading zeroes and returns values in
        -:  447:     range 0...YEAR_MAX only (invalid values are set to 0).
        -:  448:*/
        -:  449:{
       48:  450:  while (*string == '0')
branch  0 taken 8%
branch  1 taken 92% (fallthrough)
        2:  451:    string++;
       23:  452:  if (*string == '-' || (int) strlen (string) > len_year_max)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 9% (fallthrough)
branch  3 taken 91%
        2:  453:    return (0);
        -:  454:
       21:  455:  return (atoi (string));
        -:  456:}
        -:  457:
        -:  458:
        -:  459:
        -:  460:int
function my_system called 0 returned 0% blocks executed 0%
    #####:  461:my_system (command)
        -:  462:     const char *command;
        -:  463:/*!
        -:  464:   Wrapper for the system() function.
        -:  465:*/
        -:  466:{
        -:  467:#if HAVE_SYSTEM
    #####:  468:  return (((unsigned int) system (command) >> 8) & 0xff);
call    0 never executed
        -:  469:#else /* !HAVE_SYSTEM */
        -:  470:  return (-1);
        -:  471:#endif /* !HAVE_SYSTEM */
        -:  472:}
        -:  473:
        -:  474:
        -:  475:
        -:  476:#if !HAVE_STRSTR
        -:  477:char *
        -:  478:my_strstr (text, pattern)
        -:  479:     const char *text;
        -:  480:     const char *pattern;
        -:  481:/*!
        -:  482:   Search the `pattern' needle in haystack `text'   =8^)
        -:  483:     (emulates the ANSI C strstr() function; not very well optimized).
        -:  484:*/
        -:  485:{
        -:  486:  register int i = (int) strlen (text);
        -:  487:  register int j = (int) strlen (pattern);
        -:  488:  register int k;
        -:  489:  auto const char *ptr_char = text;
        -:  490:
        -:  491:
        -:  492:  if (!j)
        -:  493:    return (ptr_char);
        -:  494:  if (i < j)
        -:  495:    return (NULL);
        -:  496:  for (i = 0; *ptr_char; i++, ptr_char++)
        -:  497:    {
        -:  498:      for (k = 0, j = i; pat[k] && (text[j] == pattern[k]); j++, k++)
        -:  499:	;
        -:  500:      if (k && !pattern[k])
        -:  501:	return (ptr_char);
        -:  502:    }
        -:  503:
        -:  504:  return (NULL);
        -:  505:}
        -:  506:#endif /* !HAVE_STRSTR */
        -:  507:
        -:  508:
        -:  509:
        -:  510:#if !HAVE_STRCSPN
        -:  511:int
        -:  512:my_strcspn (s1, s2)
        -:  513:     const char *s1;
        -:  514:     const char *s2;
        -:  515:/*!
        -:  516:   Find length of initial segment of `s1' consisting entirely
        -:  517:   of characters not from `s2' (emulates the ANSI C strcspn() function).
        -:  518:*/
        -:  519:{
        -:  520:  register int count = 0;
        -:  521:  auto const char *scan1;
        -:  522:  auto const char *scan2;
        -:  523:
        -:  524:
        -:  525:  for (scan1 = s1; *scan1; scan1++)
        -:  526:    {
        -:  527:      for (scan2 = s2; *scan2;)
        -:  528:	if (*scan1 == *scan2++)
        -:  529:	  return (count);
        -:  530:      count++;
        -:  531:    }
        -:  532:
        -:  533:  return (count);
        -:  534:}
        -:  535:#endif /* !HAVE_STRCSPN */
        -:  536:
        -:  537:
        -:  538:
        -:  539:#if !HAVE_STRCASECMP
        -:  540:int
        -:  541:my_strcasecmp (s1, s2)
        -:  542:     const char *s1;
        -:  543:     const char *s2;
        -:  544:/*!
        -:  545:   Same as the ANSI C `strcmp()' function, but case insensitive.
        -:  546:*/
        -:  547:{
        -:  548:  auto const Uchar *p1 = (const Uchar *) s1;
        -:  549:  auto const Uchar *p2 = (const Uchar *) s2;
        -:  550:  auto Uchar c1;
        -:  551:  auto Uchar c2;
        -:  552:
        -:  553:
        -:  554:  if (p1 == p2)
        -:  555:    return (0);
        -:  556:  do
        -:  557:    {
        -:  558:      c1 = tolower (*p1++);
        -:  559:      c2 = tolower (*p2++);
        -:  560:      if (!c1)
        -:  561:	break;
        -:  562:    }
        -:  563:  while (c1 == c2);
        -:  564:
        -:  565:  return (c1 - c2);
        -:  566:}
        -:  567:#endif /* !HAVE_STRCASECMP */
        -:  568:
        -:  569:
        -:  570:
        -:  571:#if !HAVE_STRNCASECMP
        -:  572:int
        -:  573:my_strncasecmp (s1, s2, len)
        -:  574:     const char *s1;
        -:  575:     const char *s2;
        -:  576:     int len;
        -:  577:/*!
        -:  578:   Same as the ANSI C `strncmp()' function, but case insensitive.
        -:  579:*/
        -:  580:{
        -:  581:  auto const Uchar *p1 = (const Uchar *) s1;
        -:  582:  auto const Uchar *p2 = (const Uchar *) s2;
        -:  583:  auto Uchar c1;
        -:  584:  auto Uchar c2;
        -:  585:
        -:  586:
        -:  587:  if (!len || p1 == p2)
        -:  588:    return (0);
        -:  589:  if (len < 0)
        -:  590:    len = -len;
        -:  591:  do
        -:  592:    {
        -:  593:      c1 = tolower (*p1++);
        -:  594:      c2 = tolower (*p2++);
        -:  595:      if (!c1 || c1 != c2)
        -:  596:	return (c1 - c2);
        -:  597:    }
        -:  598:  while (--len);
        -:  599:
        -:  600:  return (c1 - c2);
        -:  601:}
        -:  602:#endif /* !HAVE_STRNCASECMP */
        -:  603:
        -:  604:
        -:  605:
        -:  606:Bool
function get_actual_date called 70 returned 100% blocks executed 38%
       70:  607:get_actual_date ()
        -:  608:/*!
        -:  609:   Gets the actual local/GMT date and time from the system resp.,
        -:  610:     evaluates the "actual" date from global `rc_adate'-ptr to string.
        -:  611:     Returns TRUE if it's possible to evaluate `rc_adate', otherwise FALSE.
        -:  612:*/
        -:  613:{
        -:  614:  auto struct tm *sys_date;
        -:  615:  auto MY_TIME_T sys_time;
        -:  616:  static Bool got_time = FALSE;
        -:  617:
        -:  618:
       70:  619:  sys_time = time ((MY_TIME_T *) NULL);
call    0 returned 100%
       70:  620:  sys_date = localtime (&sys_time);
call    0 returned 100%
       70:  621:  true_day = act_day = sys_date->tm_mday;
       70:  622:  true_month = act_month = sys_date->tm_mon + 1;
       70:  623:  act_year = sys_date->tm_year;
       70:  624:  if (act_year < CENTURY)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       70:  625:    act_year += CENTURY;
       70:  626:  true_year = act_year;
       70:  627:  if (!got_time)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  628:    {
       70:  629:      act_sec = sys_date->tm_sec;
       70:  630:      act_min = sys_date->tm_min;
       70:  631:      act_hour = sys_date->tm_hour;
       70:  632:      buf_ad = act_day;
       70:  633:      buf_am = act_month;
       70:  634:      buf_ay = act_year;
        -:  635:    }
        -:  636:#if USE_RC
        -:  637:  /*
        -:  638:     Actual date modifier %DATE given.
        -:  639:   */
       70:  640:  if (rc_adate != (char *) NULL)
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
        -:  641:    {
        9:  642:      auto int d = 0;
        9:  643:      auto int m = 0;
        9:  644:      auto int y = 0;
        9:  645:      auto int n = 0;
        9:  646:      auto int hn = 0;
        9:  647:      auto int hwd = 0;
        -:  648:      auto int i_dummy;
        9:  649:      auto char hc = '\0';
        9:  650:      auto char *c_dummy = (char *) NULL;
        -:  651:      auto Bool b_dummy;
        -:  652:
        -:  653:
        9:  654:      if (!*rc_adate || *rc_adate == RC_HDY_CHAR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 22% (fallthrough)
branch  3 taken 78%
        9:  655:	return (FALSE);
        -:  656:      /*
        -:  657:         Pre-initialize month and year to actual date.
        -:  658:       */
        7:  659:      m = act_month;
        7:  660:      y = act_year;
        -:  661:      /*
        -:  662:         Check if a numeric date is given.
        -:  663:       */
        7:  664:      if (isdigit (*rc_adate))
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        -:  665:	{
        -:  666:	  /*
        -:  667:	     Check if a numeric day in month is given.
        -:  668:	   */
        4:  669:	  if ((int) strlen (rc_adate) <= 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  670:	    {
        4:  671:	      d = atoi (rc_adate);
        4:  672:	      if (!d)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  673:		/*
        -:  674:		   Error, invalid day number given.
        -:  675:		 */
        1:  676:		return (FALSE);
        -:  677:	    }
        -:  678:	  else
    #####:  679:	    (void) rc_get_date (rc_adate, lptrs3, FALSE, &b_dummy, &d, &m, &y,
call    0 never executed
        -:  680:				&n, &i_dummy, &hc, &hn, &hwd, _("Internal"),
        -:  681:				-1L, rc_adate, FALSE);
        -:  682:	}
        -:  683:      else
        -:  684:	{
        -:  685:	  /*
        -:  686:	     Check if textual weekday name is given.
        -:  687:	   */
        3:  688:	  d = compare_d_m_name (rc_adate, DAy);
call    0 returned 100%
        3:  689:	  if (d)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  690:	    {
        -:  691:	      /*
        -:  692:	         If a digit (1...5, 9) trails the textual weekday name,
        -:  693:	         generate "N'th weekday of month" date.
        -:  694:	       */
    #####:  695:	      c_dummy = rc_adate;
    #####:  696:	      while (isalpha (*c_dummy))
branch  0 never executed
branch  1 never executed
    #####:  697:		c_dummy++;
    #####:  698:	      if (*c_dummy)
branch  0 never executed
branch  1 never executed
        -:  699:		{
    #####:  700:		  n = atoi (c_dummy);
    #####:  701:		  if (!n)
branch  0 never executed
branch  1 never executed
        -:  702:		    /*
        -:  703:		       Error, invalid "N'th weekday of month" given (must be 1...5, 9).
        -:  704:		     */
    #####:  705:		    return (FALSE);
        -:  706:		  /*
        -:  707:		     Check if the digit is trailed by anything further...
        -:  708:		   */
    #####:  709:		  c_dummy++;
    #####:  710:		  if (*c_dummy)
branch  0 never executed
branch  1 never executed
        -:  711:		    /*
        -:  712:		       Error, invalid "N'th weekday of month" given.
        -:  713:		     */
    #####:  714:		    return (FALSE);
        -:  715:		}
        -:  716:	      else
        -:  717:		{
        -:  718:		  /*
        -:  719:		     Only textual weekday name found, so compute absolute day
        -:  720:		     in month of that weekday (of current week).
        -:  721:		   */
    #####:  722:		  hn = act_day;
    #####:  723:		  i_dummy = weekday_of_date (act_day, act_month, act_year);
call    0 never executed
    #####:  724:		  if (d > i_dummy)
branch  0 never executed
branch  1 never executed
        -:  725:		    do
        -:  726:		      {
    #####:  727:			(void) next_date (&hn, &m, &y);
call    0 never executed
        -:  728:		      }
    #####:  729:		    while (d != weekday_of_date (hn, m, y));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  730:		  else if (d < i_dummy)
branch  0 never executed
branch  1 never executed
        -:  731:		    do
        -:  732:		      {
    #####:  733:			(void) prev_date (&hn, &m, &y);
call    0 never executed
        -:  734:		      }
    #####:  735:		    while (d != weekday_of_date (hn, m, y));
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  736:		  d = hn;
        -:  737:		}
        -:  738:	    }
        -:  739:	  else
        -:  740:	    {
        -:  741:	      /*
        -:  742:	         Check if short month name is given.
        -:  743:	       */
        3:  744:	      m = compare_d_m_name (rc_adate, MOnth);
call    0 returned 100%
        3:  745:	      if (!m)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  746:		/*
        -:  747:		   Error, invalid month name given.
        -:  748:		 */
        3:  749:		return (FALSE);
        -:  750:	      /*
        -:  751:	         Check if a day number trails textual a month name.
        -:  752:	       */
    #####:  753:	      c_dummy = rc_adate;
    #####:  754:	      while (isupper (*c_dummy)
branch  0 never executed
branch  1 never executed
    #####:  755:		     || islower (*c_dummy))
branch  0 never executed
branch  1 never executed
    #####:  756:		c_dummy++;
    #####:  757:	      if (*c_dummy)
branch  0 never executed
branch  1 never executed
        -:  758:		{
    #####:  759:		  d = atoi (c_dummy);
    #####:  760:		  if (!d)
branch  0 never executed
branch  1 never executed
        -:  761:		    /*
        -:  762:		       Error, invalid trailing day number given.
        -:  763:		     */
    #####:  764:		    return (FALSE);
        -:  765:		}
        -:  766:	      else
    #####:  767:		d = act_day;
        -:  768:	    }
        -:  769:	}
        3:  770:      if (y >= 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  771:	{
        3:  772:	  if (!y)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  773:	    y = act_year;
        3:  774:	  if (!m)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  775:	    m = act_month;
        3:  776:	  if (n)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  777:	    {
    #####:  778:	      if (d > DAY_MAX)
branch  0 never executed
branch  1 never executed
    #####:  779:		return (FALSE);
    #####:  780:	      if (!d)
branch  0 never executed
branch  1 never executed
    #####:  781:		d = weekday_of_date (act_day, m, y);
call    0 never executed
    #####:  782:	      if (m == 2)
branch  0 never executed
branch  1 never executed
    #####:  783:		i_dummy = days_of_february (y);
call    0 never executed
        -:  784:	      else
    #####:  785:		i_dummy = dvec[m - 1];
    #####:  786:	      if (n == 9)
branch  0 never executed
branch  1 never executed
    #####:  787:		d = eval_holiday (i_dummy, m, y, d, FALSE);
call    0 never executed
    #####:  788:	      else if ((n >= 1) && (n <= 5))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  789:		{
    #####:  790:		  d = eval_holiday (DAY_MIN, m, y, d, TRUE);
call    0 never executed
    #####:  791:		  d += (DAY_MAX * (n - 1));
        -:  792:		  /*
        -:  793:		     The "N'th weekday of month" doesn't occur in month:
        -:  794:		     generate no "actual" date.
        -:  795:		   */
    #####:  796:		  if (d > i_dummy)
branch  0 never executed
branch  1 never executed
    #####:  797:		    return (FALSE);
        -:  798:		}
        -:  799:	      else
    #####:  800:		return (FALSE);
        -:  801:	    }
        3:  802:	  else if (hc)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  803:	    {
        -:  804:	      /*
        -:  805:	         If no explicit year is given in the actual date modifier %DATE,
        -:  806:	         like %0@e|t|DVAR[[-]N[WW[W]]] resp., %0*d|wN[WW[W]], compute
        -:  807:	         the date respecting the displacement, which was returned by
        -:  808:	         the function `rc_get_date()' in variable `&hn' and `&hwd'.
        -:  809:	       */
    #####:  810:	      switch (hc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:  811:		{
    #####:  812:		case RC_EASTER_CHAR:
        -:  813:		case RC_TODAY_CHAR:
    #####:  814:		  if (!precomp_date (hn, hwd, &d, &m, y,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  815:				     (hc == RC_EASTER_CHAR) ? EAster : TOday))
    #####:  816:		    return (FALSE);
    #####:  817:		  break;
    #####:  818:		case 'D':
        -:  819:		case 'W':
    #####:  820:		  if (!precomp_nth_wd (hn, hwd, &n, &d, &m, &y,
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  821:				       ((hc == 'D') ? DAy : WEek)))
    #####:  822:		    return (FALSE);
    #####:  823:		  break;
    #####:  824:		default:
    #####:  825:		  if (!islower (hc))
branch  0 never executed
branch  1 never executed
    #####:  826:		    return (FALSE);
    #####:  827:		  else if (!precomp_date (hn, hwd, &d, &m, y, DVar))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  828:		    return (FALSE);
        -:  829:		}
        -:  830:	    }
        3:  831:	  else if (!d)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  832:	    d = act_day;
        3:  833:	  else if (d == 99)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  834:	    {
        -:  835:	      /*
        -:  836:	         Assume last day of month.
        -:  837:	       */
        1:  838:	      if (m == 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  839:		d = days_of_february (y);
call    0 never executed
        -:  840:	      else
        1:  841:		d = dvec[m - 1];
        -:  842:	    }
        3:  843:	  if (valid_date (d, m, y))
call    0 returned 100%
branch  1 taken 67% (fallthrough)
branch  2 taken 33%
        -:  844:	    {
        2:  845:	      act_day = d;
        2:  846:	      act_month = m;
        2:  847:	      act_year = y;
        -:  848:	    }
        -:  849:	  else
        1:  850:	    return (FALSE);
        -:  851:	}
        -:  852:      else
    #####:  853:	return (FALSE);
        -:  854:    }
        -:  855:#endif /* USE_RC */
        -:  856:  /*
        -:  857:     If the period of the Gregorian Reformation is past the actual local
        -:  858:     (Gregorian) system date, convert it to the proper Julian date.
        -:  859:   */
       63:  860:  gregorian2julian (&act_day, &act_month, &act_year);
call    0 returned 100%
       63:  861:  if (!got_time)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  862:    {
       63:  863:      got_time = TRUE;
        -:  864:#if USE_RC
        -:  865:      /*
        -:  866:         Get the actual GMT and date.
        -:  867:       */
       63:  868:      sys_date = gmtime (&sys_time);
call    0 returned 100%
       63:  869:      gmt_min = sys_date->tm_min;
       63:  870:      gmt_hour = sys_date->tm_hour;
       63:  871:      buf_gd = sys_date->tm_mday;
       63:  872:      buf_gm = sys_date->tm_mon + 1;
       63:  873:      buf_gy = sys_date->tm_year;
       63:  874:      if (buf_gy < CENTURY)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       63:  875:	buf_gy += CENTURY;
        -:  876:      /*
        -:  877:         If the period of the Gregorian Reformation is past the actual GMT
        -:  878:         (Gregorian) system date, convert it to the proper Julian date.
        -:  879:       */
       63:  880:      gregorian2julian (&buf_gd, &buf_gm, &buf_gy);
call    0 returned 100%
        -:  881:      /*
        -:  882:         Compute the day difference between the actual GMT date
        -:  883:         and the local time date.
        -:  884:       */
       63:  885:      gmt_loc_diff =
       63:  886:	(int) d_between (buf_ad, buf_am, buf_ay, buf_gd, buf_gm, buf_gy);
call    0 returned 100%
        -:  887:#endif /* USE_RC */
       63:  888:      buf_ad = act_day;
       63:  889:      buf_am = act_month;
       63:  890:      buf_ay = act_year;
        -:  891:    }
        -:  892:
       63:  893:  return (TRUE);
        -:  894:}
        -:  895:
        -:  896:
        -:  897:
        -:  898:int
function compare_d_m_name called 25 returned 100% blocks executed 82%
       25:  899:compare_d_m_name (string, mode)
        -:  900:     const char *string;
        -:  901:     const Cmode_enum mode;
        -:  902:/*!
        -:  903:   Compares the given day/month name `string' with built-in names and
        -:  904:     returns (1...7|1...12) either if `string' matches partly (until `\0'
        -:  905:     or first digit found in `string') or `string' matches complete.
        -:  906:     If `string' doesn't match or the length of `string' is less 2 for a day
        -:  907:     name or less 3 for a month name (we need such lengths to distinguish in a
        -:  908:     save way!), the function returns 0 always.
        -:  909:     This function checks first if a native language day/month name is given,
        -:  910:     if such a name can't be found, it checks next whether an "default" English
        -:  911:     day/month name is given.
        -:  912:   Depending on mode:
        -:  913:     mode==DAy:
        -:  914:       Compares delivered day name `string' with the built-in day names
        -:  915:         and returns: 1...7 == dayname 1...7 found ; 0 otherwise
        -:  916:     mode==MOnth:
        -:  917:       Compares delivered month name `string' with the built-in month names
        -:  918:         and returns: 1...12 == monthname 1...12 found ; 0 otherwise
        -:  919:*/
        -:  920:{
       25:  921:  register int len = (int) strlen (string);
       25:  922:  register const int len_min = (mode == DAy) ? TXTLEN_DAY : TXTLEN_MONTH;
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  923:  register int i;
       25:  924:  register int imax = (mode == DAy) ? DAY_MAX : MONTH_MAX;
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
       25:  925:  register int j = 0;
        -:  926:  register int checks;
       25:  927:  auto const char *ptr_char = string;
        -:  928:
        -:  929:
        -:  930:#ifdef GCAL_NLS
       25:  931:  if (is_en)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  932:    checks = 1;
        -:  933:  else
       25:  934:    checks = 2;
        -:  935:#else /* !GCAL_NLS */
        -:  936:  checks = 1;
        -:  937:#endif	/* !GCAL_NLS */
       25:  938:  if (len >= TXTLEN_DAY)
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -:  939:    {
       32:  940:      while (*(ptr_char + j)
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -:  941:#if USE_RC
       24:  942:	     && !isdigit (*(ptr_char + j))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       24:  943:	     && (*(ptr_char + j) != RC_REPEAT_CHAR)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       24:  944:	     && (*(ptr_char + j) != RC_APPEARS_CHAR)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  945:#endif
        -:  946:	)
       20:  947:	j++;
        6:  948:      if (j >= len_min)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  949:	do
        -:  950:	  {
       52:  951:	    for (i = (mode == DAy) ? DAY_MIN : MONTH_MIN; i <= imax; i++)
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -:  952:	      {
       48:  953:		if (checks == 2)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       24:  954:		  ptr_char = (mode == DAy) ? day_name (i) : month_name (i);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:  955:		else
       24:  956:		  ptr_char =
       24:  957:		    (mode == DAy) ? dflt_day_name (i) : dflt_month_name (i);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
       48:  958:		j = 0;
       96:  959:		while (*(ptr_char + j) && string[j])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
       48:  960:		  if (tolower (*(ptr_char + j)) == tolower (string[j]))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  961:		    j++;
        -:  962:		  else
       48:  963:		    break;
       48:  964:		if (j == len
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  965:#if USE_RC
       48:  966:		    || (j
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  967:			&& (isdigit (string[j])
branch  0 never executed
branch  1 never executed
    #####:  968:			    || string[j] == RC_REPEAT_CHAR
branch  0 never executed
branch  1 never executed
    #####:  969:			    || string[j] == RC_APPEARS_CHAR))
branch  0 never executed
branch  1 never executed
        -:  970:#endif
       48:  971:		    || !*(ptr_char + j))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  972:		  return (i);
        -:  973:	      }
        -:  974:	  }
        4:  975:	while (--checks);
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
        -:  976:    }
        -:  977:
       25:  978:  return (0);
        -:  979:}
        -:  980:
        -:  981:
        -:  982:
        -:  983:int
function asc_sort called 0 returned 0% blocks executed 0%
    #####:  984:asc_sort (a, b)
        -:  985:     const char **a;
        -:  986:     const char **b;
        -:  987:/*!
        -:  988:   The (q)sort compare function; ascending order.
        -:  989:*/
        -:  990:{
    #####:  991:  return (strcmp (*a, *b));
        -:  992:}
        -:  993:
        -:  994:
        -:  995:
        -:  996:int
function des_sort called 0 returned 0% blocks executed 0%
    #####:  997:des_sort (a, b)
        -:  998:     const char **a;
        -:  999:     const char **b;
        -: 1000:/*!
        -: 1001:   The (q)sort compare function; descending order.
        -: 1002:*/
        -: 1003:{
    #####: 1004:  return (strcmp (*b, *a));
        -: 1005:}
        -: 1006:
        -: 1007:
        -: 1008:
        -: 1009:Bool
function is_presorted called 0 returned 0% blocks executed 0%
    #####: 1010:is_presorted (table, elems)
        -: 1011:     char **table;
        -: 1012:     int elems;
        -: 1013:/*!
        -: 1014:   Checks whether the textual entries in `&table[]' are presorted in
        -: 1015:      ascending sort order.  Returns TRUE if the entries in `table'
        -: 1016:      are presorted, otherwise FALSE.
        -: 1017:*/
        -: 1018:{
    #####: 1019:  if (--elems > 0)
branch  0 never executed
branch  1 never executed
        -: 1020:    {
    #####: 1021:      register int i = 0;
    #####: 1022:      register int j = 0;
        -: 1023:
        -: 1024:
    #####: 1025:      while (elems--)
branch  0 never executed
branch  1 never executed
        -: 1026:	{
    #####: 1027:	  j++;
    #####: 1028:	  if (*table[i] >= *table[j])
branch  0 never executed
branch  1 never executed
    #####: 1029:	    if (strcmp (table[i], table[j]) > 0)
branch  0 never executed
branch  1 never executed
    #####: 1030:	      return (FALSE);
    #####: 1031:	  i++;
        -: 1032:	}
        -: 1033:    }
        -: 1034:
    #####: 1035:  return (TRUE);
        -: 1036:}
        -: 1037:
        -: 1038:
        -: 1039:
        -: 1040:void
function reverse_order called 0 returned 0% blocks executed 0%
    #####: 1041:reverse_order (table, elems)
        -: 1042:     char **table;
        -: 1043:     const int elems;
        -: 1044:/*!
        -: 1045:   Rearranges (reverts) the sort order of the textual entries in
        -: 1046:     `&table[]' from  ascending sort order to descending sort order
        -: 1047:     by swapping the `table' pointers.
        -: 1048:*/
        -: 1049:{
    #####: 1050:  register int right = elems - 1;
        -: 1051:
        -: 1052:
    #####: 1053:  if (right > 0)
branch  0 never executed
branch  1 never executed
        -: 1054:    {
    #####: 1055:      register int left = 0;
        -: 1056:      auto char *ptr_elem;
        -: 1057:
        -: 1058:
    #####: 1059:      while (left < right)
branch  0 never executed
branch  1 never executed
        -: 1060:	{
    #####: 1061:	  ptr_elem = table[left];
    #####: 1062:	  table[left++] = table[right];
    #####: 1063:	  table[right--] = ptr_elem;
        -: 1064:	}
        -: 1065:    }
    #####: 1066:}
        -: 1067:
        -: 1068:
        -: 1069:
        -: 1070:const char *
function day_suffix called 252 returned 100% blocks executed 67%
      252: 1071:day_suffix (day)
        -: 1072:     int day;
        -: 1073:/*!
        -: 1074:   Returns the ordinal suffix (st, nd, rd or th) which is added to a single day number.
        -: 1075:*/
        -: 1076:{
        -: 1077:  static const char *suffix[] = {
        -: 1078:    /*
        -: 1079:     *** Translators, this text should be a proper abbreviation of "fourth...".
        -: 1080:     */
        -: 1081:    N_("th"),
        -: 1082:    /*
        -: 1083:     *** Translators, this text should be a proper abbreviation of "first".
        -: 1084:     */
        -: 1085:    N_("st"),
        -: 1086:    /*
        -: 1087:     *** Translators, this text should be a proper abbreviation of "second".
        -: 1088:     */
        -: 1089:    N_("nd"),
        -: 1090:    /*
        -: 1091:     *** Translators, this text should be a proper abbreviation of "third".
        -: 1092:     */
        -: 1093:    N_("rd")
        -: 1094:  };
      252: 1095:  register int i = 0;
        -: 1096:
        -: 1097:
      252: 1098:  if (day < 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1099:    day = -day;
      252: 1100:  if (day > 10000)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1101:    day %= 10000;
      252: 1102:  if (day > 1000)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1103:    day %= 1000;
      252: 1104:  if (day > 100)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1105:    day %= 100;
      252: 1106:  if (day < 11 || day > 13)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
      252: 1107:    i = day % 10;
      252: 1108:  if (i > 3)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
       63: 1109:    i = 0;
        -: 1110:
      252: 1111:  return (_(suffix[i]));
        -: 1112:}
        -: 1113:
        -: 1114:
        -: 1115:
        -: 1116:const char *
function short3_day_name called 0 returned 0% blocks executed 0%
    #####: 1117:short3_day_name (day)
        -: 1118:     const int day;
        -: 1119:/*!
        -: 1120:   Returns the short name of the day using the `printf()' format "%-3s".
        -: 1121:*/
        -: 1122:{
        -: 1123:  static const char *name[] = {
        -: 1124:    N_("invalid day"),
        -: 1125:    /*
        -: 1126:     *** Translators, please translate this as a fixed 3-character text.
        -: 1127:     *** This text should be a proper abbreviation of "Monday".
        -: 1128:     */
        -: 1129:    N_("Mon"),
        -: 1130:    /*
        -: 1131:     *** Translators, please translate this as a fixed 3-character text.
        -: 1132:     *** This text should be a proper abbreviation of "Tuesday".
        -: 1133:     */
        -: 1134:    N_("Tue"),
        -: 1135:    /*
        -: 1136:     *** Translators, please translate this as a fixed 3-character text.
        -: 1137:     *** This text should be a proper abbreviation of "Wednesday".
        -: 1138:     */
        -: 1139:    N_("Wed"),
        -: 1140:    /*
        -: 1141:     *** Translators, please translate this as a fixed 3-character text.
        -: 1142:     *** This text should be a proper abbreviation of "Thursday".
        -: 1143:     */
        -: 1144:    N_("Thu"),
        -: 1145:    /*
        -: 1146:     *** Translators, please translate this as a fixed 3-character text.
        -: 1147:     *** This text should be a proper abbreviation of "Friday".
        -: 1148:     */
        -: 1149:    N_("Fri"),
        -: 1150:    /*
        -: 1151:     *** Translators, please translate this as a fixed 3-character text.
        -: 1152:     *** This text should be a proper abbreviation of "Saturday".
        -: 1153:     */
        -: 1154:    N_("Sat"),
        -: 1155:    /*
        -: 1156:     *** Translators, please translate this as a fixed 3-character text.
        -: 1157:     *** This text should be a proper abbreviation of "Sunday".
        -: 1158:     */
        -: 1159:    N_("Sun")
        -: 1160:  };
        -: 1161:
    #####: 1162:  return (((day < DAY_MIN) || (day > DAY_MAX)) ? _(name[0]) : _(name[day]));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1163:}
        -: 1164:
        -: 1165:
        -: 1166:
        -: 1167:const char *
function short_day_name called 42 returned 100% blocks executed 83%
       42: 1168:short_day_name (day)
        -: 1169:     const int day;
        -: 1170:/*!
        -: 1171:   Returns the short name of the day using the `printf()' format "%-2s".
        -: 1172:*/
        -: 1173:{
        -: 1174:  static const char *name[] = {
        -: 1175:    N_("invalid day"),
        -: 1176:    /*
        -: 1177:     *** Translators, please translate this as a fixed 2-character text.
        -: 1178:     *** This text should be a proper abbreviation of "Monday".
        -: 1179:     */
        -: 1180:    N_("Mo"),
        -: 1181:    /*
        -: 1182:     *** Translators, please translate this as a fixed 2-character text.
        -: 1183:     *** This text should be a proper abbreviation of "Tuesday".
        -: 1184:     */
        -: 1185:    N_("Tu"),
        -: 1186:    /*
        -: 1187:     *** Translators, please translate this as a fixed 2-character text.
        -: 1188:     *** This text should be a proper abbreviation of "Wednesday".
        -: 1189:     */
        -: 1190:    N_("We"),
        -: 1191:    /*
        -: 1192:     *** Translators, please translate this as a fixed 2-character text.
        -: 1193:     *** This text should be a proper abbreviation of "Thursday".
        -: 1194:     */
        -: 1195:    N_("Th"),
        -: 1196:    /*
        -: 1197:     *** Translators, please translate this as a fixed 2-character text.
        -: 1198:     *** This text should be a proper abbreviation of "Friday".
        -: 1199:     */
        -: 1200:    N_("Fr"),
        -: 1201:    /*
        -: 1202:     *** Translators, please translate this as a fixed 2-character text.
        -: 1203:     *** This text should be a proper abbreviation of "Saturday".
        -: 1204:     */
        -: 1205:    N_("Sa"),
        -: 1206:    /*
        -: 1207:     *** Translators, please translate this as a fixed 2-character text.
        -: 1208:     *** This text should be a proper abbreviation of "Sunday".
        -: 1209:     */
        -: 1210:    N_("Su")
        -: 1211:  };
        -: 1212:
       42: 1213:  return (((day < DAY_MIN) || (day > DAY_MAX)) ? _(name[0]) : _(name[day]));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1214:}
        -: 1215:
        -: 1216:
        -: 1217:
        -: 1218:const char *
function day_name called 848 returned 100% blocks executed 83%
      848: 1219:day_name (day)
        -: 1220:     const int day;
        -: 1221:/*!
        -: 1222:   Returns the complete name of the day.
        -: 1223:*/
        -: 1224:{
        -: 1225:  static const char *name[] = {
        -: 1226:    N_("invalid day"),
        -: 1227:    N_("Monday"), N_("Tuesday"), N_("Wednesday"), N_("Thursday"),
        -: 1228:    N_("Friday"), N_("Saturday"), N_("Sunday")
        -: 1229:  };
        -: 1230:
      848: 1231:  return (((day < DAY_MIN) || (day > DAY_MAX)) ? _(name[0]) : _(name[day]));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1232:}
        -: 1233:
        -: 1234:
        -: 1235:
        -: 1236:const char *
function short_month_name called 0 returned 0% blocks executed 0%
    #####: 1237:short_month_name (month)
        -: 1238:     const int month;
        -: 1239:/*!
        -: 1240:   Returns the short name of the month using the `printf()' format "%-3s".
        -: 1241:*/
        -: 1242:{
        -: 1243:  static const char *name[] = {
        -: 1244:    N_("invalid month"),
        -: 1245:    /*
        -: 1246:     *** Translators, please translate this as a fixed 3-character text.
        -: 1247:     *** This text should be a proper abbreviation of "January".
        -: 1248:     */
        -: 1249:    N_("Jan"),
        -: 1250:    /*
        -: 1251:     *** Translators, please translate this as a fixed 3-character text.
        -: 1252:     *** This text should be a proper abbreviation of "February".
        -: 1253:     */
        -: 1254:    N_("Feb"),
        -: 1255:    /*
        -: 1256:     *** Translators, please translate this as a fixed 3-character text.
        -: 1257:     *** This text should be a proper abbreviation of "March".
        -: 1258:     */
        -: 1259:    N_("Mar"),
        -: 1260:    /*
        -: 1261:     *** Translators, please translate this as a fixed 3-character text.
        -: 1262:     *** This text should be a proper abbreviation of "April".
        -: 1263:     */
        -: 1264:    N_("Apr"),
        -: 1265:    /*
        -: 1266:     *** Translators, please translate this as a fixed 3-character text.
        -: 1267:     *** This text should be a proper abbreviation of "May".
        -: 1268:     */
        -: 1269:    N_("May"),
        -: 1270:    /*
        -: 1271:     *** Translators, please translate this as a fixed 3-character text.
        -: 1272:     *** This text should be a proper abbreviation of "June".
        -: 1273:     */
        -: 1274:    N_("Jun"),
        -: 1275:    /*
        -: 1276:     *** Translators, please translate this as a fixed 3-character text.
        -: 1277:     *** This text should be a proper abbreviation of "July".
        -: 1278:     */
        -: 1279:    N_("Jul"),
        -: 1280:    /*
        -: 1281:     *** Translators, please translate this as a fixed 3-character text.
        -: 1282:     *** This text should be a proper abbreviation of "August".
        -: 1283:     */
        -: 1284:    N_("Aug"),
        -: 1285:    /*
        -: 1286:     *** Translators, please translate this as a fixed 3-character text.
        -: 1287:     *** This text should be a proper abbreviation of "September".
        -: 1288:     */
        -: 1289:    N_("Sep"),
        -: 1290:    /*
        -: 1291:     *** Translators, please translate this as a fixed 3-character text.
        -: 1292:     *** This text should be a proper abbreviation of "October".
        -: 1293:     */
        -: 1294:    N_("Oct"),
        -: 1295:    /*
        -: 1296:     *** Translators, please translate this as a fixed 3-character text.
        -: 1297:     *** This text should be a proper abbreviation of "November".
        -: 1298:     */
        -: 1299:    N_("Nov"),
        -: 1300:    /*
        -: 1301:     *** Translators, please translate this as a fixed 3-character text.
        -: 1302:     *** This text should be a proper abbreviation of "December".
        -: 1303:     */
        -: 1304:    N_("Dec")
        -: 1305:  };
        -: 1306:
        -: 1307:  return (((month < MONTH_MIN)
    #####: 1308:	   || (month > MONTH_MAX)) ? _(name[0]) : _(name[month]));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1309:}
        -: 1310:
        -: 1311:
        -: 1312:
        -: 1313:const char *
function month_name called 887 returned 100% blocks executed 93%
      887: 1314:month_name (month)
        -: 1315:     const int month;
        -: 1316:/*!
        -: 1317:   Returns the complete name of the month.
        -: 1318:*/
        -: 1319:{
        -: 1320:  static char *name[] = {
        -: 1321:    N_("invalid month"),
        -: 1322:    N_("January"), N_("February"),
        -: 1323:    N_("March"), N_("April"),
        -: 1324:    /*
        -: 1325:     *** Translators, please translate this as the complete month name "May".
        -: 1326:     *** This text contains a final BLANK character, otherwise it is not
        -: 1327:     *** distinguished from the 3-letter abbreviation of the complete month
        -: 1328:     *** name "May", which is also "May".
        -: 1329:     *** Your translation of this text should NOT contain any final BLANK
        -: 1330:     *** characters, even the abbreviated and complete month names are
        -: 1331:     *** the same in the language you are translating to.
        -: 1332:     */
        -: 1333:    N_("May "),
        -: 1334:    N_("June"), N_("July"),
        -: 1335:    N_("August"), N_("September"),
        -: 1336:    N_("October"), N_("November"), N_("December")
        -: 1337:  };
        -: 1338:
        -: 1339:
      887: 1340:  if (month == 5)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -: 1341:    {
        -: 1342:      static char *mayname;
        -: 1343:      static Bool is_initialized = FALSE;
        -: 1344:
        -: 1345:
        -: 1346:      /*
        -: 1347:         Now let's remove the trailing BLANK character
        -: 1348:         from the complete text for the month MAY.
        -: 1349:       */
       69: 1350:      if (!is_initialized)
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
        -: 1351:	{
        -: 1352:	  register int len;
       63: 1353:	  auto char *s = _(name[month]);
        -: 1354:
        -: 1355:
       63: 1356:	  len = (int) strlen (s) - 1;
       63: 1357:	  mayname = (char *) my_malloc (len,
call    0 returned 100%
        -: 1358:					ERR_NO_MEMORY_AVAILABLE,
        -: 1359:					__FILE__, ((long) __LINE__) - 2L,
        -: 1360:					"mayname", 0);
       63: 1361:	  strcpy (mayname, s);
      189: 1362:	  while (*(mayname + len) == ' ')
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
       63: 1363:	    *(mayname + len--) = '\0';
       63: 1364:	  is_initialized = TRUE;
        -: 1365:	}
        -: 1366:
       69: 1367:      return (mayname);
        -: 1368:    }
        -: 1369:
        -: 1370:  return (((month < MONTH_MIN)
      818: 1371:	   || (month > MONTH_MAX)) ? _(name[0]) : _(name[month]));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1372:}
        -: 1373:
        -: 1374:
        -: 1375:
        -: 1376:Ulint
function date2num called 190 returned 100% blocks executed 63%
      190: 1377:date2num (day, month, year)
        -: 1378:     const int day;
        -: 1379:     const int month;
        -: 1380:     const int year;
        -: 1381:/*!
        -: 1382:   Returns the absolute number of days of the given date since
        -: 1383:     00010101(==YYYYMMDD) respecting the missing period of the
        -: 1384:     Gregorian Reformation.
        -: 1385:*/
        -: 1386:{
      190: 1387:  auto Ulint mjd =
      190: 1388:    (Ulint) ((year - 1) * (Ulint) (DAY_LAST) + ((year - 1) >> 2));
        -: 1389:
        -: 1390:
      190: 1391:  if (year > greg->year
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1392:      || ((year == greg->year)
branch  0 never executed
branch  1 never executed
    #####: 1393:	  && (month > greg->month
branch  0 never executed
branch  1 never executed
    #####: 1394:	      || ((month == greg->month) && (day > greg->last_day)))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
      190: 1395:    mjd -= (Ulint) (greg->last_day - greg->first_day + 1);
      190: 1396:  if (year > greg->year)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1397:    {
      190: 1398:      mjd += (((year - 1) / 400) - (greg->year / 400));
      190: 1399:      mjd -= (((year - 1) / 100) - (greg->year / 100));
      190: 1400:      if (!(greg->year % 100) && (greg->year % 400))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####: 1401:	mjd--;
        -: 1402:    }
      190: 1403:  mjd += (Ulint) mvec[month - 1];
      190: 1404:  mjd += day;
      190: 1405:  if ((days_of_february (year) == 29) && (month > 2))
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 69% (fallthrough)
branch  4 taken 31%
      132: 1406:    mjd++;
        -: 1407:
      190: 1408:  return (mjd);
        -: 1409:}
        -: 1410:
        -: 1411:
        -: 1412:
        -: 1413:void
function num2date called 0 returned 0% blocks executed 0%
    #####: 1414:num2date (mjd, day, month, year)
        -: 1415:     Ulint mjd;
        -: 1416:     int *day;
        -: 1417:     int *month;
        -: 1418:     int *year;
        -: 1419:/*!
        -: 1420:   Converts a delivered absolute number of days `mjd' to a standard
        -: 1421:     date (since 00010101(==YYYYMMDD), returned in `&day', `&month' and `&year')
        -: 1422:     respecting the missing period of the Gregorian Reformation.
        -: 1423:*/
        -: 1424:{
        -: 1425:  auto double x;
    #####: 1426:  auto Ulint jdays = date2num (greg->first_day - 1, greg->month, greg->year);
call    0 never executed
        -: 1427:  register int i;
        -: 1428:
        -: 1429:
    #####: 1430:  if (mjd > jdays)
branch  0 never executed
branch  1 never executed
    #####: 1431:    mjd += (Ulint) (greg->last_day - greg->first_day + 1);
    #####: 1432:  x = (double) mjd / (DAY_LAST + 0.25);
    #####: 1433:  i = (int) x;
    #####: 1434:  if ((double) i != x)
branch  0 never executed
branch  1 never executed
    #####: 1435:    *year = i + 1;
        -: 1436:  else
        -: 1437:    {
    #####: 1438:      *year = i;
    #####: 1439:      i--;
        -: 1440:    }
    #####: 1441:  if (mjd > jdays)
branch  0 never executed
branch  1 never executed
        -: 1442:    {
        -: 1443:      /*
        -: 1444:         Correction for Gregorian years.
        -: 1445:       */
    #####: 1446:      mjd -= (Ulint) ((*year / 400) - (greg->year / 400));
    #####: 1447:      mjd += (Ulint) ((*year / 100) - (greg->year / 100));
    #####: 1448:      x = (double) mjd / (DAY_LAST + 0.25);
    #####: 1449:      i = (int) x;
    #####: 1450:      if ((double) i != x)
branch  0 never executed
branch  1 never executed
    #####: 1451:	*year = i + 1;
        -: 1452:      else
        -: 1453:	{
    #####: 1454:	  *year = i;
    #####: 1455:	  i--;
        -: 1456:	}
    #####: 1457:      if ((*year % 400) && !(*year % 100))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1458:	mjd--;
        -: 1459:    }
    #####: 1460:  i = (int) (mjd - (Ulint) (i * (DAY_LAST + 0.25)));
        -: 1461:  /*
        -: 1462:     Correction for Gregorian centuries.
        -: 1463:   */
    #####: 1464:  if ((*year > greg->year)
branch  0 never executed
branch  1 never executed
    #####: 1465:      && (*year % 400)
branch  0 never executed
branch  1 never executed
    #####: 1466:      && !(*year % 100)
branch  0 never executed
branch  1 never executed
    #####: 1467:      && (i <
branch  0 never executed
branch  1 never executed
    #####: 1468:	  ((*year / 100) - (greg->year / 100)) - ((*year / 400) -
    #####: 1469:						  (greg->year / 400))))
    #####: 1470:    i++;
    #####: 1471:  (void) doy2date (i, (days_of_february (*year) == 29), day, month);
call    0 never executed
call    1 never executed
    #####: 1472:}
        -: 1473:
        -: 1474:
        -: 1475:
        -: 1476:Bool
function doy2date called 1 returned 100% blocks executed 80%
        1: 1477:doy2date (doy, is_leap_year, day, month)
        -: 1478:     int doy;
        -: 1479:     const int is_leap_year;
        -: 1480:     int *day;
        -: 1481:     int *month;
        -: 1482:/*!
        -: 1483:   Converts a given number of days of a year to a standard date
        -: 1484:     (returned in `&day' and `&month') and returns:
        -: 1485:       TRUE in case the `day_of_year' number is valid;
        -: 1486:       FALSE otherwise.
        -: 1487:*/
        -: 1488:{
        -: 1489:  register int i;
        -: 1490:  auto Bool decrement_date;
        -: 1491:
        -: 1492:
        1: 1493:  if (doy > DAY_LAST + is_leap_year || doy < DAY_MIN)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1494:    return (FALSE);
        1: 1495:  decrement_date = (Bool) (is_leap_year && (doy > mvec[2]));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1: 1496:  if (decrement_date)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1497:    doy--;
        8: 1498:  for (i = MONTH_MIN; i < MONTH_MAX; i++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -: 1499:    {
        8: 1500:      doy -= dvec[i - 1];
        8: 1501:      if (doy <= 0)
branch  0 taken 13% (fallthrough)
branch  1 taken 88%
        -: 1502:	{
        1: 1503:	  doy += dvec[i - 1];
        1: 1504:	  break;
        -: 1505:	}
        -: 1506:    }
        1: 1507:  *month = i;
        1: 1508:  *day = doy;
        1: 1509:  if (decrement_date && (*month == 2) && (*day == 28))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
    #####: 1510:    (*day)++;
        -: 1511:
        1: 1512:  return (TRUE);
        -: 1513:  /*
        -: 1514:     Alternative floating-point algorithm for managing this stuff:
        -: 1515:     ...
        -: 1516:     if (doy-is_leap_year > mvec[2])
        -: 1517:     {
        -: 1518:     month = (int)((63 + doy - is_leap_year) / 30.61) - 1;
        -: 1519:     day = (int)(63 + doy - is_leap_year - abs((int)((month + 1) * 30.61)));
        -: 1520:     }
        -: 1521:     else
        -: 1522:     {
        -: 1523:     month = (int)((428 + doy) / 30.61) - 13;
        -: 1524:     day = (int)(428 + doy - abs((int)((month + 13) * 30.61)));
        -: 1525:     }
        -: 1526:     ...
        -: 1527:   */
        -: 1528:}
        -: 1529:
        -: 1530:
        -: 1531:
        -: 1532:int
function weekday_of_date called 64 returned 100% blocks executed 100%
       64: 1533:weekday_of_date (day, month, year)
        -: 1534:     const int day;
        -: 1535:     const int month;
        -: 1536:     const int year;
        -: 1537:/*!
        -: 1538:   Returns the weekday of a Gregorian/Julian calendar date
        -: 1539:     (month must be 1...12) and returns 1...7 (1==mo, 2==tu...7==su).
        -: 1540:*/
        -: 1541:{
       64: 1542:  auto Ulint mjd = date2num (day, month, year) % DAY_MAX;
call    0 returned 100%
        -: 1543:
       64: 1544:  return ((mjd > 2) ? (int) mjd - 2 : (int) mjd + 5);
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -: 1545:}
        -: 1546:
        -: 1547:
        -: 1548:
        -: 1549:int
function day_of_year called 73 returned 100% blocks executed 83%
       73: 1550:day_of_year (day, month, year)
        -: 1551:     const int day;
        -: 1552:     const int month;
        -: 1553:     const int year;
        -: 1554:/*!
        -: 1555:   Returns the day of the year of a Gregorian or Julian calendar date
        -: 1556:     (month must be 1...12) and returns 1...365|366.
        -: 1557:*/
        -: 1558:{
        -: 1559:  register int i;
        -: 1560:
        -: 1561:
       73: 1562:  if (month < 3)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1563:    i = mvec[month - 1] + day;
        -: 1564:  else
       73: 1565:    i = mvec[month - 1] + day + (days_of_february (year) == 29);
call    0 returned 100%
        -: 1566:
       73: 1567:  return (i);
        -: 1568:}
        -: 1569:
        -: 1570:
        -: 1571:
        -: 1572:int
function days_of_february called 2132 returned 100% blocks executed 35%
     2132: 1573:days_of_february (year)
        -: 1574:     const int year;
        -: 1575:/*!
        -: 1576:   Returns the number of days in February --- respecting the Gregorian
        -: 1577:     Reformation period likewise the leap year rule as used by the
        -: 1578:     Eastern Orthodox churches.
        -: 1579:*/
        -: 1580:{
        -: 1581:  register int day;
        -: 1582:
        -: 1583:
     2132: 1584:  if ((year > greg->year)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1585:      || ((year == greg->year)
branch  0 never executed
branch  1 never executed
    #####: 1586:	  && (greg->month == 1
branch  0 never executed
branch  1 never executed
    #####: 1587:	      || ((greg->month == 2) && (greg->last_day >= 28)))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1588:    {
     4264: 1589:      if (orthodox_calendar)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1590:	day =
    #####: 1591:	  (year & 3) ? 28 : ((!(year % 100))
branch  0 never executed
branch  1 never executed
    #####: 1592:			     ? (((year % 9) == 2
    #####: 1593:				 || (year % 9) == 6) ? 29 : 28) : 29);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1594:      else
     2132: 1595:	day = (year & 3) ? 28 : ((!(year % 100) && (year % 400)) ? 28 : 29);
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
branch  4 never executed
branch  5 never executed
        -: 1596:    }
        -: 1597:  else
    #####: 1598:    day = (year & 3) ? 28 : 29;
branch  0 never executed
branch  1 never executed
        -: 1599:  /*
        -: 1600:     Exception, the year 4 AD was historically NO leap year!
        -: 1601:   */
     2132: 1602:  if (year == 4)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1603:    day--;
        -: 1604:
     2132: 1605:  return (day);
        -: 1606:}
        -: 1607:
        -: 1608:
        -: 1609:
        -: 1610:Bool
function valid_date called 22022 returned 100% blocks executed 100%
    22022: 1611:valid_date (day, month, year)
        -: 1612:     const int day;
        -: 1613:     const int month;
        -: 1614:     const int year;
        -: 1615:/*!
        -: 1616:   Checks whether a delivered date is valid.
        -: 1617:*/
        -: 1618:{
    22022: 1619:  if (day < 0
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    22022: 1620:      || month < MONTH_MIN
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    22022: 1621:      || month > MONTH_MAX
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    22022: 1622:      || ((month != 2)
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
    20284: 1623:	  && (day > dvec[month - 1]))
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
    21361: 1624:      || ((month == 2) && (day > days_of_february (year))))
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
call    2 returned 100%
branch  3 taken 3% (fallthrough)
branch  4 taken 97%
      721: 1625:    return (FALSE);
        -: 1626:
    21301: 1627:  return (TRUE);
        -: 1628:}
        -: 1629:
        -: 1630:
        -: 1631:
        -: 1632:Bool
function prev_date called 0 returned 0% blocks executed 0%
    #####: 1633:prev_date (day, month, year)
        -: 1634:     int *day;
        -: 1635:     int *month;
        -: 1636:     int *year;
        -: 1637:/*!
        -: 1638:   Sets a delivered date back by one day (to yesterday's date)
        -: 1639:     respecting the missing period of the Gregorian Reformation.
        -: 1640:     Returns FALSE in case a date was within the missing period
        -: 1641:       of Gregorian Reformation, otherwise TRUE;
        -: 1642:*/
        -: 1643:{
    #####: 1644:  auto Bool no_missing_date = TRUE;
        -: 1645:
        -: 1646:
    #####: 1647:  if ((*day <= greg->last_day + 1)
branch  0 never executed
branch  1 never executed
    #####: 1648:      && (*day >= greg->first_day)
branch  0 never executed
branch  1 never executed
    #####: 1649:      && (*month == greg->month) && (*year == greg->year))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1650:    {
    #####: 1651:      no_missing_date = FALSE;
    #####: 1652:      *day = greg->first_day - 1;
        -: 1653:    }
        -: 1654:  else
        -: 1655:    {
    #####: 1656:      (*day)--;
    #####: 1657:      if (!*day || !valid_date (*day, *month, *year))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1658:	{
    #####: 1659:	  (*month)--;
    #####: 1660:	  if (*month < MONTH_MIN)
branch  0 never executed
branch  1 never executed
        -: 1661:	    {
    #####: 1662:	      *month = MONTH_MAX;
    #####: 1663:	      (*year)--;
        -: 1664:	    }
    #####: 1665:	  if (*month == 2)
branch  0 never executed
branch  1 never executed
    #####: 1666:	    *day = days_of_february (*year);
call    0 never executed
        -: 1667:	  else
    #####: 1668:	    *day = dvec[*month - 1];
        -: 1669:	}
        -: 1670:    }
        -: 1671:
    #####: 1672:  return (no_missing_date);
        -: 1673:}
        -: 1674:
        -: 1675:
        -: 1676:
        -: 1677:Bool
function next_date called 0 returned 0% blocks executed 0%
    #####: 1678:next_date (day, month, year)
        -: 1679:     int *day;
        -: 1680:     int *month;
        -: 1681:     int *year;
        -: 1682:/*!
        -: 1683:   Sets the delivered date forwards by one day (to tomorrow's date)
        -: 1684:     respecting the missing period of the Gregorian Reformation.
        -: 1685:     Returns FALSE in case a date was in the missing period
        -: 1686:       of Gregorian Reformation, otherwise TRUE.
        -: 1687:*/
        -: 1688:{
    #####: 1689:  auto Bool no_missing_date = TRUE;
        -: 1690:
        -: 1691:
    #####: 1692:  if ((*day >= greg->first_day - 1)
branch  0 never executed
branch  1 never executed
    #####: 1693:      && (*day <= greg->last_day)
branch  0 never executed
branch  1 never executed
    #####: 1694:      && (*month == greg->month) && (*year == greg->year))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1695:    {
    #####: 1696:      no_missing_date = FALSE;
    #####: 1697:      *day = greg->last_day + 1;
        -: 1698:    }
        -: 1699:  else
        -: 1700:    {
    #####: 1701:      (*day)++;
    #####: 1702:      if (!valid_date (*day, *month, *year))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1703:	{
    #####: 1704:	  *day = DAY_MIN;
    #####: 1705:	  if (*month == MONTH_MAX)
branch  0 never executed
branch  1 never executed
        -: 1706:	    {
    #####: 1707:	      *month = MONTH_MIN;
    #####: 1708:	      (*year)++;
        -: 1709:	    }
        -: 1710:	  else
    #####: 1711:	    (*month)++;
        -: 1712:	}
        -: 1713:    }
        -: 1714:
    #####: 1715:  return (no_missing_date);
        -: 1716:}
        -: 1717:
        -: 1718:
        -: 1719:
        -: 1720:int
function week_number called 0 returned 0% blocks executed 0%
    #####: 1721:week_number (day, month, year, is_iso_week, start_day_of_week)
        -: 1722:     const int day;
        -: 1723:     const int month;
        -: 1724:     const int year;
        -: 1725:     const Bool is_iso_week;
        -: 1726:     const int start_day_of_week;
        -: 1727:/*!
        -: 1728:   Returns either a ISO-8601:1988 standard week number of the given date
        -: 1729:     if the `is_iso_week' variable is TRUE, or a special value for marking
        -: 1730:     a special event, which can be managed by the caller in a special way
        -: 1731:     if needed!  Note that an ISO week starts on a Monday(=1) and ends on
        -: 1732:     a Sunday(=7), and the first week of a year is the one which includes
        -: 1733:     the first Thursday; equivalently, the one which includes 4th January.
        -: 1734:     If the `is_iso_week' variable is FALSE, either return a non-ISO week
        -: 1735:     number of the given date, or a special or a special value for marking
        -: 1736:     a special event, which can be managed by the caller in a special way
        -: 1737:     if needed!  Note that a non-ISO week can start on any weekday, and the
        -: 1738:     first week of a year is the one which includes the first starting day
        -: 1739:     of the week. The function return values are:
        -: 1740:     -(WEEK_MAX+1) : Date appears both in 53rd (=last) week of previous year
        -: 1741:                       and first days of year, BUT these first days of year
        -: 1742:                       are NOT IN the first week of year.
        -: 1743:     -WEEK_MAX     : Date appears both in 52nd (=last) week of previous year
        -: 1744:                       and first days of year, BUT these first days of year
        -: 1745:                       are NOT IN the first week of year.
        -: 1746:     -(WEEK_MAX-1) : Date appears both in 51rd (=last) week of previous year
        -: 1747:                       and first days of year, BUT these first days of year
        -: 1748:                       are NOT IN the first week of year.
        -: 1749:                       This special event only happens in the December of
        -: 1750:                       the year of Gregorian Reformation or in the January of
        -: 1751:                       the year after the year of Gregorian Reformation!
        -: 1752:      0            : Date appears both in 53rd (=last) week of previous year
        -: 1753:                       and first days of year, AND these first days of year
        -: 1754:                       are IN the first week of year.
        -: 1755:      1...WEEK_MAX : Date appears in the year.
        -: 1756:*/
        -: 1757:{
    #####: 1758:  register int i =
call    0 never executed
        -: 1759:    raw_week_number (day, month, year, is_iso_week, start_day_of_week);
        -: 1760:  register int j;
    #####: 1761:  register int wmax = WEEK_MAX;
        -: 1762:
        -: 1763:
    #####: 1764:  if ((i > 1) && (year == greg->year))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1765:    wmax = ((DAY_LAST + (days_of_february (greg->year) == 29)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1766:	     - (greg->last_day - greg->first_day + 1)) / DAY_MAX) + 1;
    #####: 1767:  if (i >= wmax)
branch  0 never executed
branch  1 never executed
        -: 1768:    {
    #####: 1769:      if (month == MONTH_MIN)
branch  0 never executed
branch  1 never executed
        -: 1770:	{
    #####: 1771:	  j =
call    0 never executed
    #####: 1772:	    raw_week_number (dvec[MONTH_MAX - 1], MONTH_MAX, year - 1,
        -: 1773:			     is_iso_week, start_day_of_week);
    #####: 1774:	  if (i == j)
branch  0 never executed
branch  1 never executed
    #####: 1775:	    i = -i;
        -: 1776:	  else
    #####: 1777:	    i = 0;
        -: 1778:	}
        -: 1779:      else
        -: 1780:	{
    #####: 1781:	  j =
call    0 never executed
    #####: 1782:	    raw_week_number (DAY_MIN, MONTH_MIN, year + 1, is_iso_week,
        -: 1783:			     start_day_of_week);
    #####: 1784:	  if (i == j)
branch  0 never executed
branch  1 never executed
    #####: 1785:	    i = -i;
    #####: 1786:	  else if ((j == 1) && (i == wmax + 1))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1787:	    i = 0;
        -: 1788:	}
        -: 1789:    }
    #####: 1790:  else if (i == 1)
branch  0 never executed
branch  1 never executed
        -: 1791:    {
    #####: 1792:      if ((is_iso_week
branch  0 never executed
branch  1 never executed
    #####: 1793:	   && (weekday_of_date (DAY_MIN, MONTH_MIN, year) <= 4))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1794:	  || (!is_iso_week
branch  0 never executed
branch  1 never executed
    #####: 1795:	      && (weekday_of_date (DAY_MIN, MONTH_MIN, year) <=
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1796:		  start_day_of_week)))
        -: 1797:	{
    #####: 1798:	  j =
call    0 never executed
    #####: 1799:	    raw_week_number (dvec[MONTH_MAX - 1], MONTH_MAX, year - 1,
        -: 1800:			     is_iso_week, start_day_of_week);
    #####: 1801:	  if (year - 1 == greg->year)
branch  0 never executed
branch  1 never executed
    #####: 1802:	    wmax = ((DAY_LAST + (days_of_february (greg->year) == 29)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1803:		     - (greg->last_day - greg->first_day + 1)) / DAY_MAX) + 1;
    #####: 1804:	  if (j != wmax)
branch  0 never executed
branch  1 never executed
    #####: 1805:	    i = 0;
        -: 1806:	}
        -: 1807:    }
        -: 1808:  else
    #####: 1809:    if ((i == wmax - 1) && (month == MONTH_MIN) && (year == greg->year + 1))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1810:    i = -i;
        -: 1811:
    #####: 1812:  return (i);
        -: 1813:}
        -: 1814:
        -: 1815:
        -: 1816:
        -: 1817:int
function weekno2doy called 0 returned 0% blocks executed 0%
    #####: 1818:weekno2doy (week, year, is_iso_week, start_day_of_week)
        -: 1819:     int week;
        -: 1820:     const int year;
        -: 1821:     const Bool is_iso_week;
        -: 1822:     const int start_day_of_week;
        -: 1823:/*!
        -: 1824:   Returns the "day_of_year" number of a Julian or Gregorian calendar year,
        -: 1825:     the given week number (either ISO-8601:1988 or non-ISO) starts at.
        -: 1826:     Week number may be:
        -: 1827:       (a)  0           == Returns day_of_year number of first week of year.
        -: 1828:                             resp., that dates, which occur both in last week
        -: 1829:                             of previous year and first week of year
        -: 1830:                             (in this case, the function return value is
        -: 1831:                              -5...0 indicating how many days+1 are in
        -: 1832:                              the previous year).
        -: 1833:       (b)  1...52      == Returns day_of_year number always.
        -: 1834:       (c) 53           == Returns day_of_year_number or if year has
        -: 1835:                             NO 53rd week, returns -WEEK_MAX [=special value]).
        -: 1836:       (d) 99           == Returns day_of_year number of last week of year.
        -: 1837:     Return values are:
        -: 1838:           -WEEK_MAX    == Event (c) has occurred and year has NO 53rd week.
        -: 1839:           -5...0       == In case event (a) has occurred and the first days
        -: 1840:                             of year occur both in last week of previous year
        -: 1841:                             and first week of year.
        -: 1842:            1...365|366 == Events (b), (c) and (d).
        -: 1843:*/
        -: 1844:{
    #####: 1845:  register int wd = weekday_of_date (DAY_MIN, MONTH_MIN, year);
call    0 never executed
    #####: 1846:  register int ww =
call    0 never executed
        -: 1847:    week_number (DAY_MIN, MONTH_MIN, year, is_iso_week, start_day_of_week);
    #####: 1848:  register int wm =
call    0 never executed
    #####: 1849:    week_number (dvec[MONTH_MAX - 1], MONTH_MAX, year, is_iso_week,
        -: 1850:		 start_day_of_week);
    #####: 1851:  register int wmax = WEEK_MAX;
    #####: 1852:  register int i = DAY_MIN;
        -: 1853:
        -: 1854:
    #####: 1855:  if (wm < 0)
branch  0 never executed
branch  1 never executed
    #####: 1856:    wm = -wm;
    #####: 1857:  if (ww == -(wmax - 1) || year == greg->year)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1858:    wmax = ((DAY_LAST + (days_of_february (greg->year) == 29)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1859:	     - (greg->last_day - greg->first_day + 1)) / DAY_MAX) + 1;
    #####: 1860:  if (ww < 0)
branch  0 never executed
branch  1 never executed
    #####: 1861:    ww = -ww;
    #####: 1862:  if (ww > 1)
branch  0 never executed
branch  1 never executed
    #####: 1863:    i += SDAY (DAY_MAX - wd + 1, start_day_of_week);
branch  0 never executed
branch  1 never executed
    #####: 1864:  else if (!ww)
branch  0 never executed
branch  1 never executed
    #####: 1865:    i -= SDAY (wd - 1, start_day_of_week);
branch  0 never executed
branch  1 never executed
    #####: 1866:  if (wm && (wm != wmax + 1) && (week == wmax + 1))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1867:    return (-WEEK_MAX);
    #####: 1868:  else if (week == 99)
branch  0 never executed
branch  1 never executed
        -: 1869:    {
    #####: 1870:      week = wm;
    #####: 1871:      if (!wm)
branch  0 never executed
branch  1 never executed
    #####: 1872:	week = wmax + 1;
    #####: 1873:      i += (((week - 1) * DAY_MAX));
        -: 1874:    }
        -: 1875:  else
        -: 1876:    {
    #####: 1877:      i += (((week - 1) * DAY_MAX));
    #####: 1878:      if (!week && (i <= -(DAY_MAX - 1)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1879:	i += DAY_MAX;
        -: 1880:    }
        -: 1881:  /*
        -: 1882:     Correction in case week occurs during Gregorian Reformation period.
        -: 1883:   */
    #####: 1884:  if (year == greg->year)
branch  0 never executed
branch  1 never executed
    #####: 1885:    if (i + (greg->last_day - greg->first_day + 1) >
branch  0 never executed
branch  1 never executed
    #####: 1886:	day_of_year (greg->last_day, greg->month, greg->year))
call    0 never executed
    #####: 1887:      i += (greg->last_day - greg->first_day + 1);
    #####: 1888:  if (i > DAY_LAST + (days_of_february (year) == 29))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 1889:    return (-WEEK_MAX);
        -: 1890:
    #####: 1891:  return (i);
        -: 1892:}
        -: 1893:
        -: 1894:
        -: 1895:
        -: 1896:int
function knuth_easter_formula called 65 returned 100% blocks executed 47%
       65: 1897:knuth_easter_formula (year)
        -: 1898:     const int year;
        -: 1899:/*!
        -: 1900:   This procedure calculates the day and month of Easter giving the year.
        -: 1901:   It returns the "actual day_of_year date" of Western Eastern (not the
        -: 1902:   Eastern Easter of the Eastern Orthodox churches) after AD 463.
        -: 1903:   ***
        -: 1904:   *** ANNOTATION by Thomas Esken <esken@uni-muenster.de>, 12-DEC-1996
        -: 1905:   ***
        -: 1906:   *** But in fact, this procedure works correctly for
        -: 1907:   *** calculating the Easter Sunday's date after AD 29.
        -: 1908:   *** (Ref.: Hans Lietzmann, Zeitrechnung, De gryter 1984, 4te Auflage)
        -: 1909:   ***
        -: 1910:   `golden_number' is the number of the year in the Metonic cycle, used
        -: 1911:   to determine the position of the calendar Moon.
        -: 1912:   `gregorian_correction' is the number of preceding years like 1700, 1800,
        -: 1913:   1900 when leap year was not held.
        -: 1914:   `clavian_correction' is a correction for the Metonic cycle of about
        -: 1915:   8 days every 2500 years.
        -: 1916:   `epact' is the age of the calendar Moon at the beginning of the year.
        -: 1917:   `extra_days' specifies when Sunday occurs in March.  `epact' specifies
        -: 1918:   when Full Moon occurs.  Easter is the first Sunday following the first
        -: 1919:   Full Moon which occurs on or after March 21.  (Ref.: De Morgan, A Budget
        -: 1920:   of Paradoxes)
        -: 1921:   This basic Algorithm was given by Don Knuth in CACM 5(1962), 209-210,
        -: 1922:   and is altered accordingly for managing different Gregorian Reformation
        -: 1923:   periods.
        -: 1924:*/
        -: 1925:{
        -: 1926:  auto long extra_days;
       65: 1927:  register int golden_number = (year % 19) + 1;
        -: 1928:  register int century;
        -: 1929:  register int gregorian_correction;
        -: 1930:  register int clavian_correction;
        -: 1931:  register int epact;
        -: 1932:  register int day;
        -: 1933:  register int month;
        -: 1934:  register int easter;
       65: 1935:  auto Bool was_julian = FALSE;
        -: 1936:
        -: 1937:
       65: 1938:  if ((year > greg->year)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    #####: 1939:      || ((year == greg->year)
branch  0 never executed
branch  1 never executed
    #####: 1940:	  && (greg->month < 3
branch  0 never executed
branch  1 never executed
    #####: 1941:	      || ((greg->month == 3) && (greg->last_day < 22)))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1942:    {
        -: 1943:      /*
        -: 1944:         Computation for Gregorian years.
        -: 1945:       */
       65: 1946:    LABEL_compute_gregorian:
       65: 1947:      century = year / 100 + 1;
       65: 1948:      gregorian_correction = (3 * century / 4) - 12;
       65: 1949:      clavian_correction = ((8 * century + 5) / 25) - 5;
       65: 1950:      extra_days = (5L * year / 4) - gregorian_correction - 10;
       65: 1951:      epact =
       65: 1952:	(11 * golden_number + 20 + clavian_correction -
        -: 1953:	 gregorian_correction) % 30;
        -: 1954:      /*
        -: 1955:         BTW, the earliest year the calculated epact is negative or null
        -: 1956:         is the year 1710!
        -: 1957:         (see chapter 1.3.2 "THE MIX ASSEMBLY LANGUAGE", page 155,
        -: 1958:         question 15 of Don Knuth's "The Art of Computer Programming", Vol. 1)
        -: 1959:       */
       65: 1960:      if (epact <= 0)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        2: 1961:	epact += 30;
      130: 1962:      if (((epact == 25) && (golden_number > 11)) || epact == 24)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####: 1963:	epact++;
        -: 1964:    }
        -: 1965:  else
        -: 1966:    {
        -: 1967:      /*
        -: 1968:         Computation for Julian calendar years.
        -: 1969:       */
    #####: 1970:      was_julian = TRUE;
    #####: 1971:      extra_days = (5L * year) / 4;
    #####: 1972:      epact = ((11 * golden_number - 4) % 30) + 1;
        -: 1973:    }
       65: 1974:  day = 44 - epact;
       65: 1975:  if (day < 21)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        2: 1976:    day += 30;
       65: 1977:  day += DAY_MAX - (int) ((extra_days + day) % DAY_MAX);
       65: 1978:  if (day > MONTH_LAST)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -: 1979:    {
        2: 1980:      day -= MONTH_LAST;
        2: 1981:      month = 4;
        -: 1982:    }
        -: 1983:  else
       63: 1984:    month = 3;
       65: 1985:  easter = day_of_year (day, month, year);
call    0 returned 100%
        -: 1986:  /*
        -: 1987:     Correction for potential Reformation period which occurred
        -: 1988:     during the period Easter Sunday may take place (22-MAR...25-APR).
        -: 1989:     I assume if such a Reformation periods happens, the proper
        -: 1990:     solution for computing Easter Sunday's date has to be
        -: 1991:     done for the Gregorian year instead of the Julian year.
        -: 1992:   */
       65: 1993:  if (was_julian
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1994:      && (year == greg->year)
branch  0 never executed
branch  1 never executed
    #####: 1995:      && (greg->month == 3 || ((greg->month == 4) && (greg->last_day <= 25))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1996:    {
    #####: 1997:      was_julian = FALSE;
    #####: 1998:      if ((easter >= day_of_year (greg->first_day, greg->month, greg->year))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1999:	  && (easter <=
branch  0 never executed
branch  1 never executed
    #####: 2000:	      day_of_year (greg->last_day, greg->month, greg->year)))
call    0 never executed
    #####: 2001:	goto LABEL_compute_gregorian;
        -: 2002:    }
        -: 2003:
       65: 2004:  return (easter);
        -: 2005:}
        -: 2006:
        -: 2007:
        -: 2008:
        -: 2009:int
function julian_gregorian_diff called 0 returned 0% blocks executed 0%
    #####: 2010:julian_gregorian_diff (day, month, year)
        -: 2011:     const int day;
        -: 2012:     const int month;
        -: 2013:     const int year;
        -: 2014:/*!
        -: 2015:   Returns the day difference between the given Gregorian calendar date
        -: 2016:     and the according Julian calendar date, i.e. the amount of days,
        -: 2017:     the Julian calendar is past the Gregorian calendar.
        -: 2018:*/
        -: 2019:{
    #####: 2020:  auto Ulint mjd =
    #####: 2021:    (Ulint) ((year - 1) * (Ulint) (DAY_LAST) + ((year - 1) >> 2));
        -: 2022:
        -: 2023:
    #####: 2024:  mjd += (Ulint) (mvec[month - 1] + day);
    #####: 2025:  if ((days_of_february (year) == 29) && (month > 2))
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####: 2026:    mjd++;
        -: 2027:
    #####: 2028:  return ((int) (mjd - date2num (day, month, year)));
call    0 never executed
        -: 2029:}
        -: 2030:
        -: 2031:
        -: 2032:
        -: 2033:static void
function gregorian2julian called 126 returned 100% blocks executed 30%
      126: 2034:gregorian2julian (day, month, year)
        -: 2035:     int *day;
        -: 2036:     int *month;
        -: 2037:     int *year;
        -: 2038:/*!
        -: 2039:   Converts a Gregorian date to a Julian date.
        -: 2040:*/
        -: 2041:{
      126: 2042:  if (*year < greg->year
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      126: 2043:      || ((*year == greg->year)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 2044:	  && (*month < greg->month
branch  0 never executed
branch  1 never executed
    #####: 2045:	      || ((*month == greg->month) && (*day < greg->first_day)))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2046:    {
        -: 2047:      auto Greg_struct tmp_greg;
        -: 2048:      auto Ulint mjd;
        -: 2049:      register int diff;
        -: 2050:
        -: 2051:
        -: 2052:      /*
        -: 2053:         So first we need to buffer the Gregorian Reformation period actually used.
        -: 2054:       */
    #####: 2055:      tmp_greg.first_day = greg->first_day;
    #####: 2056:      tmp_greg.last_day = greg->last_day;
    #####: 2057:      tmp_greg.month = greg->month;
    #####: 2058:      tmp_greg.year = greg->year;
        -: 2059:      /*
        -: 2060:         Then we set the Gregorian Reformation period to the date
        -: 2061:         it has happened historically (this was 05-Oct-1582...14-Oct-1582).
        -: 2062:       */
    #####: 2063:      greg->first_day = 5;
    #####: 2064:      greg->last_day = 14;
    #####: 2065:      greg->month = 10;
    #####: 2066:      greg->year = 1582;
        -: 2067:      /*
        -: 2068:         Now let's adjust the date.
        -: 2069:       */
    #####: 2070:      mjd = date2num (*day, *month, *year);
call    0 never executed
    #####: 2071:      diff = julian_gregorian_diff (*day, *month, *year);
call    0 never executed
    #####: 2072:      num2date (mjd - diff, day, month, year);
call    0 never executed
        -: 2073:      /*
        -: 2074:         And restore the buffered Gregorian Reformation date actually used.
        -: 2075:       */
    #####: 2076:      greg->year = tmp_greg.year;
    #####: 2077:      greg->month = tmp_greg.month;
    #####: 2078:      greg->last_day = tmp_greg.last_day;
    #####: 2079:      greg->first_day = tmp_greg.first_day;
        -: 2080:    }
      126: 2081:}
        -: 2082:
        -: 2083:
        -: 2084:
        -: 2085:static int
function raw_week_number called 0 returned 0% blocks executed 0%
    #####: 2086:raw_week_number (day, month, year, is_iso_week, start_day_of_week)
        -: 2087:     const int day;
        -: 2088:     const int month;
        -: 2089:     const int year;
        -: 2090:     const Bool is_iso_week;
        -: 2091:     const int start_day_of_week;
        -: 2092:/*!
        -: 2093:   Returns either the raw ISO-8601:1988 standard week number of the given
        -: 2094:     date if the `is_iso_week' variable is TRUE.  Note that an ISO week
        -: 2095:     starts on a Monday(=1) and ends on a Sunday(=7), and the first week
        -: 2096:     of a year is the one which includes the first Thursday; equivalently,
        -: 2097:     the one which includes 4th January.
        -: 2098:     If the `is_iso_week' variable is FALSE, return a raw non-ISO week
        -: 2099:     number of the given date.  Note that a non-ISO week can start on any
        -: 2100:     weekday, and the first week of a year is the one which includes the
        -: 2101:     first starting day of the week.
        -: 2102:*/
        -: 2103:{
    #####: 2104:  register int jd = day_of_year (day, month, year);
call    0 never executed
    #####: 2105:  register int sd = weekday_of_date (DAY_MIN, MONTH_MIN, year);
call    0 never executed
        -: 2106:  register int ww;
        -: 2107:
        -: 2108:
    #####: 2109:  if ((year == greg->year)
branch  0 never executed
branch  1 never executed
    #####: 2110:      && (month > greg->month
branch  0 never executed
branch  1 never executed
    #####: 2111:	  || ((month == greg->month) && (day > greg->last_day))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2112:    jd -= (greg->last_day - greg->first_day + 1);
    #####: 2113:  if (is_iso_week)
branch  0 never executed
branch  1 never executed
        -: 2114:    {
        -: 2115:      /*
        -: 2116:         Correct the computed day_of_year number of delivered date.
        -: 2117:       */
    #####: 2118:      if (sd > 4)
branch  0 never executed
branch  1 never executed
        -: 2119:	/*
        -: 2120:	   Starting day of year is Friday...Sunday.
        -: 2121:	 */
    #####: 2122:	jd -= ((DAY_MAX - sd) + 1);
        -: 2123:      else
        -: 2124:	/*
        -: 2125:	   Starting day of year is Monday...Thursday.
        -: 2126:	 */
    #####: 2127:	jd += (sd - 1);
        -: 2128:    }
        -: 2129:  else
        -: 2130:    {
        -: 2131:      /*
        -: 2132:         Correct the computed day_of_year number of delivered date.
        -: 2133:       */
    #####: 2134:      if (sd > start_day_of_week)
branch  0 never executed
branch  1 never executed
        -: 2135:	/*
        -: 2136:	   Starting day of year is greater the starting day of week.
        -: 2137:	 */
    #####: 2138:	jd -= (DAY_MAX - (sd - start_day_of_week));
        -: 2139:      else
        -: 2140:	/*
        -: 2141:	   Starting day of year is less than the starting day of week.
        -: 2142:	 */
    #####: 2143:	jd += (sd - start_day_of_week);
        -: 2144:    }
        -: 2145:  /*
        -: 2146:     Compute week number of delivered date.
        -: 2147:   */
    #####: 2148:  if (jd > 0)
branch  0 never executed
branch  1 never executed
        -: 2149:    /*
        -: 2150:       Date has consecutive week number of current year: Compute it.
        -: 2151:     */
    #####: 2152:    ww = (jd - 1) / DAY_MAX + 1;
        -: 2153:  else
        -: 2154:    /*
        -: 2155:       Date has week number of last week of previous year:
        -: 2156:       Detect that week number by calling this function recursivly  ;)
        -: 2157:     */
    #####: 2158:    ww =
call    0 never executed
    #####: 2159:      raw_week_number (dvec[MONTH_MAX - 1], MONTH_MAX, year - 1, is_iso_week,
        -: 2160:		       start_day_of_week);
        -: 2161:
    #####: 2162:  return (ww);
        -: 2163:}
        -: 2164:
        -: 2165:
        -: 2166:
        -: 2167:static const char *
function dflt_day_name called 0 returned 0% blocks executed 0%
    #####: 2168:dflt_day_name (day)
        -: 2169:     const int day;
        -: 2170:/*!
        -: 2171:   Returns the complete default (==English) name of the day
        -: 2172:     (needed by the `compare_d_m_name()' function if another native language
        -: 2173:     other than English must be supported).
        -: 2174:*/
        -: 2175:{
        -: 2176:  static const char *name[] = {
        -: 2177:    "invalid day",
        -: 2178:    "Monday", "Tuesday", "Wednesday", "Thursday",
        -: 2179:    "Friday", "Saturday", "Sunday"
        -: 2180:  };
        -: 2181:
    #####: 2182:  return (((day < DAY_MIN) || (day > DAY_MAX)) ? name[0] : name[day]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2183:}
        -: 2184:
        -: 2185:
        -: 2186:
        -: 2187:static const char *
function dflt_month_name called 24 returned 100% blocks executed 83%
       24: 2188:dflt_month_name (month)
        -: 2189:     const int month;
        -: 2190:/*!
        -: 2191:   Returns the complete default (==English) name of the month
        -: 2192:     (needed by the `compare_d_m_name()' function if another native lanuage
        -: 2193:     other than English must be supported).
        -: 2194:*/
        -: 2195:{
        -: 2196:  static const char *name[] = {
        -: 2197:    "invalid month",
        -: 2198:    "January", "February", "March",
        -: 2199:    "April", "May", "June",
        -: 2200:    "July", "August", "September",
        -: 2201:    "October", "November", "December"
        -: 2202:  };
        -: 2203:
        -: 2204:  return (((month < MONTH_MIN)
       24: 2205:	   || (month > MONTH_MAX)) ? name[0] : name[month]);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 2206:}
