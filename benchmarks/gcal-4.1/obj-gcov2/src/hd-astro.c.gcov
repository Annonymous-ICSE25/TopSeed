        -:    0:Source:../../src/hd-astro.c
        -:    0:Programs:20
        -:    1:/*!
        -:    2:*  \file hd-astro.c
        -:    3:*  \brief Astronomical and support functions used by the eternal holiday list.
        -:    4:*/
        -:    5:/*
        -:    6:*  Copyright (c) 1994, 95, 96, 1997, 2000 Thomas Esken
        -:    7:*  Copyright (c) 2010, 2011, 2013 Free Software Foundation, Inc.
        -:    8:*
        -:    9:*  This software doesn't claim completeness, correctness or usability.
        -:   10:*  On principle I will not be liable for ANY damages or losses (implicit
        -:   11:*  or explicit), which result from using or handling my software.
        -:   12:*  If you use this software, you agree without any exception to this
        -:   13:*  agreement, which binds you LEGALLY !!
        -:   14:*
        -:   15:*  This program is free software; you can redistribute it and/or modify
        -:   16:*  it under the terms of the `GNU General Public License' as published by
        -:   17:*  the `Free Software Foundation'; either version 3, or (at your option)
        -:   18:*  any later version.
        -:   19:*
        -:   20:*  You should have received a copy of the `GNU General Public License'
        -:   21:*  along with this program; if not, write to the:
        -:   22:*
        -:   23:*/
        -:   24:
        -:   25:
        -:   26:/*
        -:   27:*  Include header files.
        -:   28:*/
        -:   29:#include "tailor.h"
        -:   30:#if HAVE_MATH_H && HAVE_LIBM
        -:   31:# include <math.h>
        -:   32:#endif
        -:   33:#include "common.h"
        -:   34:#include "globals.h"
        -:   35:#include "utils.h"
        -:   36:#include "hd-astro.h"
        -:   37:
        -:   38:
        -:   39:
        -:   40:/*
        -:   41:*  static functions prototypes.
        -:   42:*/
        -:   43:__BEGIN_DECLARATIONS
        -:   44:/*
        -:   45:************************************************** Defined in `hd-astro.c'.
        -:   46:*/
        -:   47:static double
        -:   48:  meeus_equinox_solstice __P_ ((const double mode,
        -:   49:				const int year, int hour, int min));
        -:   50:__END_DECLARATIONS
        -:   51:/*
        -:   52:*  Function implementations.
        -:   53:*/
        -:   54:  static double
function meeus_equinox_solstice called 0 returned 0% blocks executed 0%
    #####:   55:meeus_equinox_solstice (mode, year, hour, min)
        -:   56:     const double mode;
        -:   57:     const int year;
        -:   58:     int hour;
        -:   59:     int min;
        -:   60:/*!
        -:   61:   According to MODE (== 0.0|90.0|180.0|270.0), this function calculates the
        -:   62:     dates of equinoxes and solstices for the given YEAR (range: 0001...9999)
        -:   63:     and returns the properly converted Julian/Gregorian date and time fraction.
        -:   64:     Calculations are done for a line at a definite meridian expressed as a
        -:   65:     time value in HOUR and MIN.  If HOUR and MIN are set to zero, calculations
        -:   66:     are done for UTC/GMT.  If HOUR and MIN have a positive sign, calculations
        -:   67:     are done for meridians East of Greenwich, otherwise for meridians West
        -:   68:     of Greenwich.
        -:   69:   The computed result is quite precise when compared with the results
        -:   70:     created by standard ephemeris software (aa, moontool, xephemer...)
        -:   71:     for the years AD 0001...5999 (about), but the ``error'' increases
        -:   72:     significantly for far future years.  As you surely know, such an ``error''
        -:   73:     can be really critical when it appears for dates computed near midnight,
        -:   74:     by reason the computed date can be different the ``true'' date!
        -:   75:   The formula is taken from Jean Meeus' "Astronomical Algorithms"
        -:   76:     and adapted to Gcal's needs.
        -:   77:*/
        -:   78:{
    #####:   79:  auto double meridian_time = HHMM2DAY (hour, min);
    #####:   80:  auto double jc = ((double) year - 2000.0) / 1000;
        -:   81:  auto double mjd;
        -:   82:  auto double w;
        -:   83:  auto double c;
        -:   84:  auto double l;
        -:   85:  auto int d;
        -:   86:  auto int m;
        -:   87:  auto int y;
        -:   88:
        -:   89:
    #####:   90:  switch ((int) ROUND (mode))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
        -:   91:    {
    #####:   92:    case 0:
        -:   93:      /*
        -:   94:         Northern hemisphere: vernal equinox
        -:   95:         Southern hemisphere: autumnal equinox
        -:   96:       */
    #####:   97:      mjd = 730201.30984
    #####:   98:	+ (365242.37404 +
    #####:   99:	   (0.05169 - (0.00411 + 0.00057 * jc) * jc) * jc) * jc;
    #####:  100:      break;
    #####:  101:    case 90:
        -:  102:      /*
        -:  103:         Northern hemisphere: summer solstice
        -:  104:         Southern hemisphere: winter solstice
        -:  105:       */
    #####:  106:      mjd = 730294.06767
    #####:  107:	+ (365241.62603 +
    #####:  108:	   (0.00325 + (0.00888 - 0.00030 * jc) * jc) * jc) * jc;
    #####:  109:      break;
    #####:  110:    case 180:
        -:  111:      /*
        -:  112:         Northern hemisphere: autumnal equinox
        -:  113:         Southern hemisphere: vernal equinox
        -:  114:       */
    #####:  115:      mjd = 730387.71715
    #####:  116:	+ (365242.01767 -
    #####:  117:	   (0.11575 - (0.00337 + 0.00078 * jc) * jc) * jc) * jc;
    #####:  118:      break;
    #####:  119:    case 270:
        -:  120:      /*
        -:  121:         Northern hemisphere: winter solstice
        -:  122:         Southern hemisphere: summer solstice
        -:  123:       */
    #####:  124:      mjd = 730477.55925
    #####:  125:	+ (365242.74049 -
    #####:  126:	   (0.06223 + (0.00823 - 0.00032 * jc) * jc) * jc) * jc;
    #####:  127:      break;
    #####:  128:    default:
    #####:  129:      abort ();			/* Error, invalid mode! */
call    0 never executed
        -:  130:    }
        -:  131:  /*
        -:  132:     Epoch starts 01-Jan-2000 12:00:00 UT.
        -:  133:   */
    #####:  134:  jc = (mjd - 730122.5) / 36525.0;
        -:  135:  /*
        -:  136:     Perform some correction terms.
        -:  137:   */
    #####:  138:  w = 35999.373 * jc - 2.47;
    #####:  139:  l = 1.0 + 0.0334 * cos (TORAD (w)) + 0.0007 * cos (TORAD (2.0 * w));
    #####:  140:  c = 0.00485 * cos (TORAD (324.96 + 1934.136 * jc))
    #####:  141:    + 0.00203 * cos (TORAD (337.23 + 32964.467 * jc))
    #####:  142:    + 0.00199 * cos (TORAD (342.08 + 20.186 * jc))
    #####:  143:    + 0.00182 * cos (TORAD (27.85 + 445267.112 * jc))
    #####:  144:    + 0.00156 * cos (TORAD (73.14 + 45036.886 * jc))
    #####:  145:    + 0.00136 * cos (TORAD (171.52 + 22518.443 * jc))
    #####:  146:    + 0.00077 * cos (TORAD (222.54 + 65928.934 * jc))
    #####:  147:    + 0.00074 * cos (TORAD (296.72 + 3034.906 * jc))
    #####:  148:    + 0.00070 * cos (TORAD (243.58 + 9037.513 * jc))
    #####:  149:    + 0.00058 * cos (TORAD (119.81 + 33718.147 * jc))
    #####:  150:    + 0.00052 * cos (TORAD (297.17 + 150.678 * jc))
    #####:  151:    + 0.00050 * cos (TORAD (21.02 + 2281.226 * jc))
    #####:  152:    + 0.00045 * cos (TORAD (247.54 + 29929.562 * jc))
    #####:  153:    + 0.00044 * cos (TORAD (325.15 + 31555.956 * jc))
    #####:  154:    + 0.00029 * cos (TORAD (60.93 + 4443.417 * jc))
    #####:  155:    + 0.00018 * cos (TORAD (155.12 + 67555.328 * jc))
    #####:  156:    + 0.00017 * cos (TORAD (288.79 + 4562.452 * jc))
    #####:  157:    + 0.00016 * cos (TORAD (198.04 + 62894.029 * jc))
    #####:  158:    + 0.00014 * cos (TORAD (199.76 + 31436.921 * jc))
    #####:  159:    + 0.00012 * cos (TORAD (95.39 + 14577.848 * jc))
    #####:  160:    + 0.00012 * cos (TORAD (287.11 + 31931.756 * jc))
    #####:  161:    + 0.00012 * cos (TORAD (320.81 + 34777.259 * jc))
    #####:  162:    + 0.00009 * cos (TORAD (227.73 + 1222.114 * jc))
    #####:  163:    + 0.00008 * cos (TORAD (15.45 + 16859.074 * jc));
    #####:  164:  mjd += (c / l);
        -:  165:  /*
        -:  166:     Convert TDT to UT.
        -:  167:   */
    #####:  168:  num2date ((Ulint) mjd, &d, &m, &y);
call    0 never executed
    #####:  169:  val2hours (mjd, &hour, &min, NULL);
call    0 never executed
    #####:  170:  mjd -= SS2DAY (delta_t (d, m, y, hour, min));
call    0 never executed
        -:  171:  /*
        -:  172:     Convert UT to local time.
        -:  173:   */
    #####:  174:  mjd += meridian_time;
        -:  175:
    #####:  176:  return (mjd);
        -:  177:}
        -:  178:
        -:  179:
        -:  180:
        -:  181:double
function equinox_solstice called 0 returned 0% blocks executed 0%
    #####:  182:equinox_solstice (longitude, day, month, year, hour, min)
        -:  183:     const double longitude;
        -:  184:     int *day;
        -:  185:     int *month;
        -:  186:     int *year;
        -:  187:     const int hour;
        -:  188:     const int min;
        -:  189:/*!
        -:  190:   Wrapper/driver function for selecting the proper function
        -:  191:     that calculates the date and time of the equinoxes/solstices
        -:  192:     ``most precise'' for the given YEAR.
        -:  193:*/
        -:  194:{
        -:  195:  auto double mjd;
        -:  196:
        -:  197:
    #####:  198:  if (*year < 6000)
branch  0 never executed
branch  1 never executed
        -:  199:    {
    #####:  200:      mjd = meeus_equinox_solstice (longitude, *year, hour, min);
call    0 never executed
    #####:  201:      num2date ((Ulint) mjd, day, month, year);
call    0 never executed
        -:  202:    }
        -:  203:  else
    #####:  204:    mjd = sun_longitude (longitude, day, month, year, hour, min, FALSE);
call    0 never executed
        -:  205:
    #####:  206:  return (mjd);
        -:  207:}
        -:  208:
        -:  209:
        -:  210:
function delta_t called 0 returned 0% blocks executed 0%
    #####:  211:double delta_t (day, month, year, hour, min)
        -:  212:     const int day;
        -:  213:     const int month;
        -:  214:     const int year;
        -:  215:     const int hour;
        -:  216:     const int min;
        -:  217:/*!
        -:  218:   Returns the approximate Delta_T in seconds plus fraction for the given
        -:  219:     Julian/Gregorian calendar date (range 00010101..99991231), which is the
        -:  220:     difference between Terrestrial Dynamical Time, TDT (formerly called
        -:  221:     Ephemeris Time, ET), and Universal Time, UT, so `Delta_T = TDT - UT'.
        -:  222:     This function is taken from the `aa.arc' archive, which is a nice and
        -:  223:     precise ephemeris calculation software written by Stephen L. Moshier
        -:  224:     <moshier@mediaone.net>; adapted and pretty-printed according to Gcal's needs.
        -:  225:     One major adaption made is to let the table of Delta_T values start in
        -:  226:     AD 1630 instead of AD 1620, because this fits better to the Delta_T values
        -:  227:     prior AD 1630 that are calculated by using the formula from Stevenson
        -:  228:     and Morrison (now, the gap is only about 30 seconds from 31-Dec-1629 to
        -:  229:     01-Jan-1630 instead of about 60 seconds from 31-Dec-1619 to 01-Jan-1620)!
        -:  230:     Here are Stephen's essential (and reformatted) remarks:
        -:  231:   The tabulated values of Delta_T, in hundredths of a second, were taken from
        -:  232:     "The Astronomical Almanac", page K8.  This function adjusts for a value of
        -:  233:     secular tidal acceleration NDOT.  It is -25.8 arcsec per century squared
        -:  234:     for JPL's DE403 ephemeris.  ELP2000 and DE200 use the value -23.8946.
        -:  235:   The tabulated range is 1620.0...2004.0.  Bessel's interpolation formula is
        -:  236:     implemented to obtain fourth order interpolated values at intermediate
        -:  237:     times.  Updated Delta_T predictions can be obtained from this network
        -:  238:     archive:  ftp://maia.usno.navy.mil/ser7/deltat.[preds|data]
        -:  239:   For dates earlier than the tabulated range, this function calculates
        -:  240:     approximate formulae of Stephenson and Morrison or K. M. Borkowski.
        -:  241:     These approximations have an estimated error of 15 minutes at 1500 BC.
        -:  242:     They are not adjusted for small improvements in the current estimate of
        -:  243:     NDOT because the formulas were derived from studies of ancient eclipses
        -:  244:     and other historical information, whose interpretation depends only
        -:  245:     partly on NDOT.
        -:  246:   A quadratic extrapolation formula, that agrees in value and slope with
        -:  247:     current data, predicts future values of Delta_T.
        -:  248:   References:
        -:  249:   * Stephenson, F. R., and L. V. Morrison, "Long-term changes in the rotation
        -:  250:     of the Earth: 700 BC to AD 1980", Philosophical Transactions of the
        -:  251:     Royal Society of London Series A 313, 47-70 (1984).
        -:  252:     Note: Stephenson and Morrison's table starts at the year 1630.
        -:  253:   * Borkowski, K. M., "ELP2000-85 and the Dynamical Time - Universal Time
        -:  254:     relation", Astronomy and Astrophysics 205, L8-L10 (1988).
        -:  255:     Note: Borkowski's formula is derived from eclipses going back to
        -:  256:           2137 BC and uses lunar position based on tidal coefficient
        -:  257:           of -23.9 arcsec/cy^2.
        -:  258:   * Chapront-Touze, Michelle, and Jean Chapront, "Lunar Tables and Programs
        -:  259:     from 4000 BC to AD 8000", Willmann-Bell 1991.
        -:  260:     Note: Their table agrees with the one here, but the entries are rounded
        -:  261:           to the nearest whole second.  The Chapronts' table does not agree
        -:  262:           with the Almanac prior to 1630.
        -:  263:   * Stephenson, F. R., and M. A. Houlden, "Atlas of Historical Eclipse Maps",
        -:  264:     Cambridge U. Press (1986).
        -:  265:   * U.S. Government Printing Office, "The Astronomical Almanac" (AA), 1986.
        -:  266:*/
        -:  267:{
        -:  268:  static short int dt_table[] = {
        -:  269:    /*
        -:  270:       The actual accuracy decreases rapidly prior to 1780!
        -:  271:       Years 1620.0...1659.0.
        -:  272:     */
        -:  273:#if 0
        -:  274:    12400, 11900, 11500, 11000, 10600, 10200, 9800, 9500, 9100, 8800,
        -:  275:#endif
        -:  276:    8500, 8200, 7900, 7700, 7400, 7200, 7000, 6700, 6500, 6300,
        -:  277:    6200, 6000, 5800, 5700, 5500, 5400, 5300, 5100, 5000, 4900,
        -:  278:    4800, 4700, 4600, 4500, 4400, 4300, 4200, 4100, 4000, 3800,
        -:  279:    /*
        -:  280:       Years 1660.0...1699.0.
        -:  281:     */
        -:  282:    3700, 3600, 3500, 3400, 3300, 3200, 3100, 3000, 2800, 2700,
        -:  283:    2600, 2500, 2400, 2300, 2200, 2100, 2000, 1900, 1800, 1700,
        -:  284:    1600, 1500, 1400, 1400, 1300, 1200, 1200, 1100, 1100, 1000,
        -:  285:    1000, 1000, 900, 900, 900, 900, 900, 900, 900, 900,
        -:  286:    /*
        -:  287:       Years 1700.0...1739.0.
        -:  288:     */
        -:  289:    900, 900, 900, 900, 900, 900, 900, 900, 1000, 1000,
        -:  290:    1000, 1000, 1000, 1000, 1000, 1000, 1000, 1100, 1100, 1100,
        -:  291:    1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100,
        -:  292:    1100, 1100, 1100, 1100, 1200, 1200, 1200, 1200, 1200, 1200,
        -:  293:    /*
        -:  294:       Years 1740.0...1779.0.
        -:  295:     */
        -:  296:    1200, 1200, 1200, 1200, 1300, 1300, 1300, 1300, 1300, 1300,
        -:  297:    1300, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1500, 1500,
        -:  298:    1500, 1500, 1500, 1500, 1500, 1600, 1600, 1600, 1600, 1600,
        -:  299:    1600, 1600, 1600, 1600, 1600, 1700, 1700, 1700, 1700, 1700,
        -:  300:    /*
        -:  301:       Years 1780.0...1819.0.
        -:  302:     */
        -:  303:    1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700,
        -:  304:    1700, 1700, 1600, 1600, 1600, 1600, 1500, 1500, 1400, 1400,
        -:  305:    1370, 1340, 1310, 1290, 1270, 1260, 1250, 1250, 1250, 1250,
        -:  306:    1250, 1250, 1250, 1250, 1250, 1250, 1250, 1240, 1230, 1220,
        -:  307:    /*
        -:  308:       Years 1820.0...1859.0.
        -:  309:     */
        -:  310:    1200, 1170, 1140, 1110, 1060, 1020, 960, 910, 860, 800,
        -:  311:    750, 700, 660, 630, 600, 580, 570, 560, 560, 560,
        -:  312:    570, 580, 590, 610, 620, 630, 650, 660, 680, 690,
        -:  313:    710, 720, 730, 740, 750, 760, 770, 770, 780, 780,
        -:  314:    /*
        -:  315:       Years 1860.0...1899.0.
        -:  316:     */
        -:  317:    788, 782, 754, 697, 640, 602, 541, 410, 292, 182,
        -:  318:    161, 10, -102, -128, -269, -324, -364, -454, -471, -511,
        -:  319:    -540, -542, -520, -546, -546, -579, -563, -564, -580, -566,
        -:  320:    -587, -601, -619, -664, -644, -647, -609, -576, -466, -374,
        -:  321:    /*
        -:  322:       Years 1900.0...1939.0.
        -:  323:     */
        -:  324:    -272, -154, -2, 124, 264, 386, 537, 614, 775, 913,
        -:  325:    1046, 1153, 1336, 1465, 1601, 1720, 1824, 1906, 2025, 2095,
        -:  326:    2116, 2225, 2241, 2303, 2349, 2362, 2386, 2449, 2434, 2408,
        -:  327:    2402, 2400, 2387, 2395, 2386, 2393, 2373, 2392, 2396, 2402,
        -:  328:    /*
        -:  329:       Years 1940.0...1979.0.
        -:  330:     */
        -:  331:    2433, 2483, 2530, 2570, 2624, 2677, 2728, 2778, 2825, 2871,
        -:  332:    2915, 2957, 2997, 3036, 3072, 3107, 3135, 3168, 3218, 3268,
        -:  333:    3315, 3359, 3400, 3447, 3503, 3573, 3654, 3743, 3829, 3920,
        -:  334:    4018, 4117, 4223, 4337, 4449, 4548, 4646, 4752, 4853, 4959,
        -:  335:    /*
        -:  336:       Years 1980.0...1995.0.
        -:  337:     */
        -:  338:    5054, 5138, 5217, 5296, 5379, 5434, 5487, 5532, 5582, 5630,
        -:  339:    5686, 5757, 5831, 5912, 5998, 6078,
        -:  340:    /*
        -:  341:       Years 1996.0...2011.0 extrapolated values (USNO).
        -:  342:     */
        -:  343:    6163, 6240, 6330, 6410,
        -:  344:    6480, 6580, 6700, 6800, 6900, 7000, 7100, 7200, 7300, 7400,
        -:  345:    7500, 7600
        -:  346:  };
        -:  347:  auto double julian_years;
        -:  348:  auto double result;
        -:  349:  auto double p;
        -:  350:  auto double b;
        -:  351:  static int dt_table_size = sizeof dt_table / sizeof (short int);
        -:  352:  static int dt_table_end;
        -:  353:  static int dt_table_start = 1630;
        -:  354:  auto int dt_diff[6];
        -:  355:  register int n;
        -:  356:  register int i;
        -:  357:  register int j;
        -:  358:  static Bool is_initialized = FALSE;
        -:  359:
        -:  360:
    #####:  361:  if (!is_initialized)
branch  0 never executed
branch  1 never executed
        -:  362:    {
    #####:  363:      dt_table_end = dt_table_start + dt_table_size - 1;
    #####:  364:      is_initialized = TRUE;
        -:  365:    }
        -:  366:  /*
        -:  367:     Epoch starts 01-Jan-2000 00:00:00 UT.
        -:  368:   */
    #####:  369:  julian_years =
    #####:  370:    2000.0 + (date2num (day, month, year) + HHMM2DAY (hour, min) -
call    0 never executed
    #####:  371:	      730122.0) / 365.25;
    #####:  372:  if (year > dt_table_end)
branch  0 never executed
branch  1 never executed
        -:  373:    {
        -:  374:#if 0
        -:  375:      /*
        -:  376:         Morrison, L. V. and F. R. Stephenson, "Sun and Planetary System",
        -:  377:         Vol 96,73 eds. W. Fricke, G. Teleki, Reidel, Dordrecht (1982).
        -:  378:       */
        -:  379:      b = 0.01 * (julian_years - 1800.0) - 0.1;
        -:  380:      return (-15.0 + 32.5 * b * b);
        -:  381:#endif /* 0 */
        -:  382:      /*
        -:  383:         Extrapolate forward by a second-degree curve that agrees with the
        -:  384:         most recent data in value and slope, and vaguely fits over the
        -:  385:         past century.  This idea communicated by Paul Muller, who says
        -:  386:         NASA used to do something like it.
        -:  387:       */
    #####:  388:      b = julian_years - dt_table_end;
        -:  389:      /*
        -:  390:         Slope.
        -:  391:       */
    #####:  392:      p = dt_table[dt_table_size - 1] - dt_table[dt_table_size - 2];
        -:  393:      /*
        -:  394:         Square term.
        -:  395:       */
    #####:  396:      result =
    #####:  397:	(dt_table[dt_table_size - 101] -
    #####:  398:	 (dt_table[dt_table_size - 1] - 100.0 * p)) * 0.0001;
    #####:  399:      return (0.01 * (dt_table[dt_table_size - 1] + p * b + result * b * b));
        -:  400:    }
    #####:  401:  if (year < dt_table_start)
branch  0 never executed
branch  1 never executed
        -:  402:    {
    #####:  403:      b = 0.01 * (julian_years - 2000.0);
    #####:  404:      if (year >= 948)
branch  0 never executed
branch  1 never executed
        -:  405:	/*
        -:  406:	   Stephenson and Morrison, stated domain is 948.0...1600.0:
        -:  407:	   25.5(centuries from 1800)^2 - 1.9159(centuries from 1955)^2.
        -:  408:	 */
    #####:  409:	return ((23.58 * b + 100.3) * b + 101.6);
        -:  410:      /*
        -:  411:         Borkowski.
        -:  412:       */
    #####:  413:      b += 3.75;
    #####:  414:      return (35.0 * b * b + 40.0);
        -:  415:    }
        -:  416:  do
        -:  417:    {
        -:  418:      /*
        -:  419:         Besselian interpolation from tabulated values.  See AA page K11.
        -:  420:       */
    #####:  421:      i = year - dt_table_start;
    #####:  422:      j = i + 1;
        -:  423:      /*
        -:  424:         Zeroth order estimate is value at start of year.
        -:  425:       */
    #####:  426:      result = dt_table[i];
    #####:  427:      if (j >= dt_table_size)
branch  0 never executed
branch  1 never executed
    #####:  428:	break;
        -:  429:      /*
        -:  430:         The fraction of tabulation interval.
        -:  431:       */
    #####:  432:      p = julian_years - year;
        -:  433:      /*
        -:  434:         First order interpolated value.
        -:  435:       */
    #####:  436:      result += (p * (dt_table[j] - dt_table[i]));
    #####:  437:      if (i - 1 < 0 || i + 2 >= dt_table_size)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  438:	break;
        -:  439:      /*
        -:  440:         Make table of first differences.
        -:  441:       */
    #####:  442:      j = i - 2;
    #####:  443:      for (n = 0; n < 5; n++, j++)
branch  0 never executed
branch  1 never executed
        -:  444:	{
    #####:  445:	  if (j < 0 || j + 1 >= dt_table_size)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  446:	    dt_diff[n] = 0;
        -:  447:	  else
    #####:  448:	    dt_diff[n] = dt_table[j + 1] - dt_table[j];
        -:  449:	}
        -:  450:      /*
        -:  451:         Compute second differences.
        -:  452:       */
    #####:  453:      for (n = 0; n < 4; n++)
branch  0 never executed
branch  1 never executed
    #####:  454:	dt_diff[n] = dt_diff[n + 1] - dt_diff[n];
    #####:  455:      b = 0.25 * p * (p - 1.0);
    #####:  456:      result += b * (dt_diff[1] + dt_diff[2]);
    #####:  457:      if (i + 2 >= dt_table_size)
branch  0 never executed
branch  1 never executed
    #####:  458:	break;
        -:  459:      /*
        -:  460:         Compute third differences.
        -:  461:       */
    #####:  462:      for (n = 0; n < 3; n++)
branch  0 never executed
branch  1 never executed
    #####:  463:	dt_diff[n] = dt_diff[n + 1] - dt_diff[n];
    #####:  464:      b = 2.0 * b / 3.0;
    #####:  465:      result += ((p - 0.5) * b * dt_diff[1]);
    #####:  466:      if (i - 2 < 0 || i + 3 > dt_table_size)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  467:	break;
        -:  468:      /*
        -:  469:         Compute fourth differences.
        -:  470:       */
    #####:  471:      for (n = 0; n < 2; n++)
branch  0 never executed
branch  1 never executed
    #####:  472:	dt_diff[n] = dt_diff[n + 1] - dt_diff[n];
    #####:  473:      b = 0.125 * b * (p + 1.0) * (p - 2.0);
    #####:  474:      result += (b * (dt_diff[0] + dt_diff[1]));
        -:  475:    }
        -:  476:  while (FALSE);
        -:  477:  /*
        -:  478:     The "Astronomical Almanac" table is corrected by adding the expression
        -:  479:     `-0.000091*(NDOT+26)*(julian_years-1955)^2 seconds' to entries prior
        -:  480:     to 1955 (AA page K8), where NDOT is the secular tidal term in the mean
        -:  481:     motion of the Moon.  Entries after 1955 are referred to atomic time
        -:  482:     standards and are not affected by errors in lunar or planetary theory.
        -:  483:   */
    #####:  484:  result *= 0.01;
    #####:  485:  if (year < 1955)
branch  0 never executed
branch  1 never executed
        -:  486:    {
    #####:  487:      b = (julian_years - 1955.0);
    #####:  488:      result += (-0.000091 * (-25.8 + 26.0) * b * b);
        -:  489:    }
        -:  490:
    #####:  491:  return (result);
        -:  492:}
        -:  493:
        -:  494:
        -:  495:
        -:  496:double
function moonphase called 0 returned 0% blocks executed 0%
    #####:  497:moonphase (phase_selector, find_eclipse, eclipse_type, lunation,
        -:  498:	   day, month, year, hour, min)
        -:  499:     const double phase_selector;
        -:  500:     const Bool find_eclipse;
        -:  501:     double *eclipse_type;
        -:  502:     Ulint *lunation;
        -:  503:     int *day;
        -:  504:     int *month;
        -:  505:     int *year;
        -:  506:     int hour;
        -:  507:     int min;
        -:  508:/*!
        -:  509:   According to PHASE_SELECTOR, this function calculates the requested Moon
        -:  510:     phase, which occurs on or later the given Julian/Gregorian date (range
        -:  511:     00010101...99991231).  This is the case if LUNATION is set to zero.
        -:  512:     If LUNATION is set to a value greater than zero, this function calculates
        -:  513:     the requested Moon phase for the given LUNATION.  The LUNATION is a
        -:  514:     posivite integer number counted from the beginning of the Christian
        -:  515:     Era by reason I define that the LUNATION number 1 is equivalent to the
        -:  516:     New Moon phase on AD 13-Jan-0001.
        -:  517:     If FIND_ECLIPSE is TRUE, this functions also checks whether a
        -:  518:     lunar eclipse happens while the Full Moon phase occurs (MPHASE_FUL),
        -:  519:     respectively, whether also a solar eclipse happens while the New Moon
        -:  520:     phase occurs (MPHASE_NEW).  If an eclipse occurs during such a Moon
        -:  521:     phase, its Julian date and time fraction based on the Christian
        -:  522:     Era is returned via the address of ECLIPSE_TYPE, otherwise ECLIPSE_TYPE
        -:  523:     is set to SPECIAL_VALUE.  If an eclipse occurs, ECLIPSE_TYPE also
        -:  524:     contains the type of the eclipse, which is added by using a proper
        -:  525:     (large) constant value that identifies the type of the eclipse.
        -:  526:   Returns the calculated Julian date and time fraction of the requested
        -:  527:     Moon phase based on the Christian Era, which is a number starting from
        -:  528:     1 at AD 01-Jan-0001.  Properly converted, this number is also passed via
        -:  529:     the addresses of DAY, MONTH and YEAR.  And furthermore, the (calculated)
        -:  530:     lunation number is passed via the address of LUNATION, too.
        -:  531:   Calculations are done for a line at a definite meridian expressed as
        -:  532:     a time value in HOUR and MIN.  If HOUR and MIN are set to zero,
        -:  533:     calculations are done for UTC/GMT.  If HOUR and MIN have a positive
        -:  534:     sign, calculations are done for meridians East of Greenwich, otherwise
        -:  535:     for meridians West of Greenwich.
        -:  536:   The base formula is taken from Jean Meeus' "Astronomical Algorithms"
        -:  537:     and adapted to Gcal's needs.
        -:  538:*/
        -:  539:{
        -:  540:  auto double the_lunation;
        -:  541:  auto double jc_julian_centuries;
        -:  542:  auto double jc_jc;
        -:  543:  auto double julian_date;
        -:  544:  auto double sea_sun_eccent_anomaly;
        -:  545:  auto double sea_sea;
        -:  546:  auto double sma_sun_mean_anomaly;
        -:  547:  auto double sma_2;
        -:  548:  auto double mma_moon_mean_anomaly;
        -:  549:  auto double mma_2;
        -:  550:  auto double mma_3;
        -:  551:  auto double mma_m_sma;
        -:  552:  auto double mma_p_sma;
        -:  553:  auto double mla_moon_latitude;
        -:  554:  auto double mla_2;
        -:  555:  auto double moon_longitude;
    #####:  556:  auto double meridian_time = HHMM2DAY (hour, min);
    #####:  557:  auto double mjd = 0.0;
    #####:  558:  auto double jd = 0.0;
        -:  559:  auto double jd2;
        -:  560:  auto double a;
        -:  561:  auto double coeff1;
        -:  562:  auto double coeff2;
    #####:  563:  register int selector = (int) ROUND (phase_selector * 4.0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  564:  auto Bool is_lunation_given = (*lunation != 0L);
        -:  565:
        -:  566:
    #####:  567:  if (!is_lunation_given)
branch  0 never executed
branch  1 never executed
        -:  568:    {
        -:  569:      /*
        -:  570:         Convert local time to UT.
        -:  571:       */
    #####:  572:      jd = date2num (*day, *month, *year) + meridian_time;
call    0 never executed
    #####:  573:      num2date ((Ulint) jd, day, month, year);
call    0 never executed
    #####:  574:      val2hours (jd, &hour, &min, NULL);
call    0 never executed
        -:  575:      /*
        -:  576:         Convert UT to TDT.
        -:  577:       */
    #####:  578:      mjd = jd + SS2DAY (delta_t (*day, *month, *year, hour, min));
call    0 never executed
        -:  579:      /*
        -:  580:         Calculate the approximate lunation number first.
        -:  581:       */
    #####:  582:      the_lunation = (Slint) ((mjd + 0.11111112) / 29.5305892) + 1.0;
    #####:  583:      *lunation = (Ulint) the_lunation;
        -:  584:    }
        -:  585:  else
    #####:  586:    the_lunation = *lunation;
        -:  587:  /*
        -:  588:     Normalize the lunation number so it refers to Christian Era's
        -:  589:     New Moon phase at 13-Jan-0001, which I've defined as LUNATION number 1.
        -:  590:   */
    #####:  591:  the_lunation -= (24725.0 - phase_selector);
        -:  592:  LOOP
        -:  593:  {
    #####:  594:    jc_julian_centuries = the_lunation / 1236.85;
    #####:  595:    jc_jc = jc_julian_centuries * jc_julian_centuries;
        -:  596:    /*
        -:  597:       Approximated Julian Date.
        -:  598:     */
    #####:  599:    jd2 = julian_date = 2451550.09765
    #####:  600:      + 29.530588853 * the_lunation
    #####:  601:      + jc_jc * (0.0001337 +
    #####:  602:		 jc_julian_centuries * (-0.000000150 +
    #####:  603:					0.00000000073 * jc_julian_centuries));
    #####:  604:    sea_sun_eccent_anomaly =
    #####:  605:      1.0 + jc_julian_centuries * (-0.002516 +
    #####:  606:				   -0.0000074 * jc_julian_centuries);
    #####:  607:    sma_sun_mean_anomaly =
    #####:  608:      TORAD (2.5534 + 29.10535669 * the_lunation +
        -:  609:	     jc_jc * (-0.0000218 + -0.00000011 * jc_julian_centuries));
    #####:  610:    mma_moon_mean_anomaly =
    #####:  611:      TORAD (201.5643 + 385.81693528 * the_lunation +
        -:  612:	     jc_jc * (0.0107438 +
        -:  613:		      jc_julian_centuries * (0.00001239 +
        -:  614:					     -0.000000058 *
        -:  615:					     jc_julian_centuries)));
    #####:  616:    mla_moon_latitude =
    #####:  617:      TORAD (160.7108 + 390.67050274 * the_lunation +
        -:  618:	     jc_jc * (-0.0016341 * jc_julian_centuries *
        -:  619:		      (-0.00000227 + 0.000000011 * jc_julian_centuries)));
    #####:  620:    moon_longitude =
    #####:  621:      TORAD (124.7746 - 1.56375580 * the_lunation +
        -:  622:	     jc_jc * (0.0020691 + 0.00000215 * jc_julian_centuries));
    #####:  623:    mla_2 = 2.0 * mla_moon_latitude;
    #####:  624:    sma_2 = 2.0 * sma_sun_mean_anomaly;
    #####:  625:    mma_2 = 2.0 * mma_moon_mean_anomaly;
    #####:  626:    mma_3 = 3.0 * mma_moon_mean_anomaly;
    #####:  627:    mma_m_sma = mma_moon_mean_anomaly - sma_sun_mean_anomaly;
    #####:  628:    mma_p_sma = mma_moon_mean_anomaly + sma_sun_mean_anomaly;
    #####:  629:    sea_sea = sea_sun_eccent_anomaly * sea_sun_eccent_anomaly;
        -:  630:    /*
        -:  631:       Calculate correction values.
        -:  632:     */
    #####:  633:    a = TORAD (299.77 + 0.107408 * the_lunation - 0.009173 * jc_jc);
    #####:  634:    coeff1 = 0.000325 * sin (a)
    #####:  635:      + 0.000165 * sin (TORAD (251.88 + 0.016321 * the_lunation))
    #####:  636:      + 0.000164 * sin (TORAD (251.83 + 26.651886 * the_lunation))
    #####:  637:      + 0.000126 * sin (TORAD (349.42 + 36.412478 * the_lunation))
    #####:  638:      + 0.000110 * sin (TORAD (84.66 + 18.206239 * the_lunation))
    #####:  639:      + 0.000062 * sin (TORAD (141.74 + 53.303771 * the_lunation))
    #####:  640:      + 0.000060 * sin (TORAD (207.14 + 2.453732 * the_lunation))
    #####:  641:      + 0.000056 * sin (TORAD (154.84 + 7.306860 * the_lunation))
    #####:  642:      + 0.000047 * sin (TORAD (34.52 + 27.261239 * the_lunation))
    #####:  643:      + 0.000042 * sin (TORAD (207.19 + 0.121824 * the_lunation))
    #####:  644:      + 0.000040 * sin (TORAD (291.34 + 1.844379 * the_lunation))
    #####:  645:      + 0.000037 * sin (TORAD (161.72 + 24.198154 * the_lunation))
    #####:  646:      + 0.000035 * sin (TORAD (239.56 + 25.513099 * the_lunation))
    #####:  647:      + 0.000023 * sin (TORAD (331.55 + 3.592518 * the_lunation));
    #####:  648:    if (!(selector & 1))
branch  0 never executed
branch  1 never executed
    #####:  649:      coeff2 = -0.00111 * sin (mma_moon_mean_anomaly - mla_2)
    #####:  650:	- 0.00057 * sin (mma_moon_mean_anomaly + mla_2)
    #####:  651:	+ 0.00056 * sin (mma_2 +
    #####:  652:			 sma_sun_mean_anomaly) * sea_sun_eccent_anomaly -
    #####:  653:	0.00042 * sin (mma_3) + 0.00042 * sin (sma_sun_mean_anomaly +
    #####:  654:					       mla_2) *
    #####:  655:	sea_sun_eccent_anomaly + 0.00038 * sin (sma_sun_mean_anomaly -
    #####:  656:						mla_2) *
    #####:  657:	sea_sun_eccent_anomaly - 0.00024 * sin (mma_2 -
    #####:  658:						sma_sun_mean_anomaly) *
    #####:  659:	sea_sun_eccent_anomaly - 0.00017 * sin (moon_longitude) -
    #####:  660:	0.00007 * sin (mma_moon_mean_anomaly + sma_2) + 0.00004 * sin (mma_2 -
        -:  661:								       mla_2)
    #####:  662:	+ 0.00004 * sin (3.0 * sma_sun_mean_anomaly) +
    #####:  663:	0.00003 * sin (mma_p_sma - mla_2) + 0.00003 * sin (mma_2 + mla_2) -
    #####:  664:	0.00003 * sin (mma_p_sma + mla_2) + 0.00003 * sin (mma_m_sma +
    #####:  665:							   mla_2) -
    #####:  666:	0.00002 * sin (mma_m_sma - mla_2) - 0.00002 * sin (mma_3 +
        -:  667:							   sma_sun_mean_anomaly)
    #####:  668:	+ 0.00002 * sin (4.0 * mma_moon_mean_anomaly);
        -:  669:    else
    #####:  670:      coeff2 = 0.00306
    #####:  671:	- 0.00038 * cos (sma_sun_mean_anomaly) * sea_sun_eccent_anomaly
    #####:  672:	+ 0.00026 * cos (mma_moon_mean_anomaly)
    #####:  673:	- 0.00002 * cos (mma_m_sma)
    #####:  674:	+ 0.00002 * cos (mma_p_sma) + 0.00002 * cos (mla_2);
        -:  675:    /*
        -:  676:       Correct Julian Date.
        -:  677:     */
    #####:  678:    switch (selector)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
        -:  679:      {
    #####:  680:      case 0:
        -:  681:	/*
        -:  682:	   New Moon phase.
        -:  683:	 */
    #####:  684:	julian_date += (-0.40720 * sin (mma_moon_mean_anomaly)
    #####:  685:			+
    #####:  686:			0.17241 * sin (sma_sun_mean_anomaly) *
    #####:  687:			sea_sun_eccent_anomaly + 0.01608 * sin (mma_2) +
    #####:  688:			0.01039 * sin (mla_2) +
    #####:  689:			0.00739 * sin (mma_m_sma) * sea_sun_eccent_anomaly -
    #####:  690:			0.00514 * sin (mma_p_sma) * sea_sun_eccent_anomaly +
    #####:  691:			0.00208 * sin (sma_2) * sea_sea);
    #####:  692:	break;
    #####:  693:      case 2:
        -:  694:	/*
        -:  695:	   Full Moon phase.
        -:  696:	 */
    #####:  697:	julian_date += (-0.40614 * sin (mma_moon_mean_anomaly)
    #####:  698:			+
    #####:  699:			0.17302 * sin (sma_sun_mean_anomaly) *
    #####:  700:			sea_sun_eccent_anomaly + 0.01614 * sin (mma_2) +
    #####:  701:			0.01043 * sin (mla_2) +
    #####:  702:			0.00734 * sin (mma_m_sma) * sea_sun_eccent_anomaly -
    #####:  703:			0.00515 * sin (mma_p_sma) * sea_sun_eccent_anomaly +
    #####:  704:			0.00209 * sin (sma_2) * sea_sea);
    #####:  705:	break;
    #####:  706:      case 3:
        -:  707:	/*
        -:  708:	   Last quarter phase.
        -:  709:	 */
    #####:  710:	coeff2 = -coeff2;
        -:  711:	/* Fallthrough. */
    #####:  712:      case 1:
        -:  713:	/*
        -:  714:	   First quarter phase.
        -:  715:	 */
    #####:  716:	julian_date += (-0.62801 * sin (mma_moon_mean_anomaly)
    #####:  717:			+
    #####:  718:			0.17172 * sin (sma_sun_mean_anomaly) *
    #####:  719:			sea_sun_eccent_anomaly -
    #####:  720:			0.01183 * sin (mma_p_sma) * sea_sun_eccent_anomaly +
    #####:  721:			0.00862 * sin (mma_2) + 0.00804 * sin (mla_2) +
    #####:  722:			0.00454 * sin (mma_m_sma) * sea_sun_eccent_anomaly +
    #####:  723:			0.00204 * sin (sma_2) * sea_sea -
    #####:  724:			0.00180 * sin (mma_moon_mean_anomaly - mla_2) -
    #####:  725:			0.00070 * sin (mma_moon_mean_anomaly + mla_2) -
    #####:  726:			0.00040 * sin (mma_3) - 0.00034 * sin (mma_2 -
        -:  727:							       sma_sun_mean_anomaly)
    #####:  728:			* sea_sun_eccent_anomaly +
    #####:  729:			0.00032 * sin (sma_sun_mean_anomaly +
    #####:  730:				       mla_2) * sea_sun_eccent_anomaly +
    #####:  731:			0.00032 * sin (sma_sun_mean_anomaly -
    #####:  732:				       mla_2) * sea_sun_eccent_anomaly -
    #####:  733:			0.00028 * sin (mma_moon_mean_anomaly +
    #####:  734:				       sma_2) * sea_sea +
    #####:  735:			0.00027 * sin (mma_2 +
    #####:  736:				       sma_sun_mean_anomaly) *
    #####:  737:			sea_sun_eccent_anomaly -
    #####:  738:			0.00017 * sin (moon_longitude) -
    #####:  739:			0.00005 * sin (mma_m_sma - mla_2) +
    #####:  740:			0.00004 * sin (mma_2 + mla_2) -
    #####:  741:			0.00004 * sin (mma_p_sma + mla_2) +
    #####:  742:			0.00004 * sin (mma_moon_mean_anomaly - sma_2) +
    #####:  743:			0.00003 * sin (mma_p_sma - mla_2) +
    #####:  744:			0.00003 * sin (3.0 * sma_sun_mean_anomaly) +
    #####:  745:			0.00002 * sin (mma_2 - mla_2) +
    #####:  746:			0.00002 * sin (mma_m_sma + mla_2) -
    #####:  747:			0.00002 * sin (mma_3 + sma_sun_mean_anomaly));
    #####:  748:	break;
    #####:  749:      default:
        -:  750:	/*
        -:  751:	   This case must be an internal error!
        -:  752:	 */
    #####:  753:	abort ();
call    0 never executed
        -:  754:      }
    #####:  755:    julian_date += (coeff1 + coeff2);
        -:  756:    /*
        -:  757:       Convert to Christian Era.
        -:  758:     */
    #####:  759:    julian_date -= (MIN_BCE_TO_1_CE - 1.5);
        -:  760:    /*
        -:  761:       Convert TDT to UT.
        -:  762:     */
    #####:  763:    num2date ((Ulint) julian_date, day, month, year);
call    0 never executed
    #####:  764:    val2hours (julian_date, &hour, &min, NULL);
call    0 never executed
    #####:  765:    julian_date -= SS2DAY (delta_t (*day, *month, *year, hour, min));
call    0 never executed
        -:  766:    /*
        -:  767:       Convert UT to local time.
        -:  768:     */
    #####:  769:    julian_date += meridian_time;
    #####:  770:    num2date ((Ulint) julian_date, day, month, year);
call    0 never executed
    #####:  771:    if (!is_lunation_given)
branch  0 never executed
branch  1 never executed
        -:  772:      {
        -:  773:	/*
        -:  774:	   And check whether we have found the proper Moon phase.
        -:  775:	 */
    #####:  776:	if ((Ulint) julian_date < (Ulint) jd)
branch  0 never executed
branch  1 never executed
        -:  777:	  {
        -:  778:	    /*
        -:  779:	       No, let's try the next lunation.
        -:  780:	     */
    #####:  781:	    the_lunation += 1.0;
    #####:  782:	    (*lunation)++;
        -:  783:	  }
        -:  784:	else
    #####:  785:	  break;
        -:  786:      }
        -:  787:    else
    #####:  788:      break;
        -:  789:  }
    #####:  790:  if (eclipse_type != (double *) NULL)
branch  0 never executed
branch  1 never executed
    #####:  791:    *eclipse_type = SPECIAL_VALUE;
    #####:  792:  if (find_eclipse && !(selector & 1))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  793:    {
    #####:  794:      if (eclipse_type == (double *) NULL)
branch  0 never executed
branch  1 never executed
        -:  795:	/*
        -:  796:	   Internal error, invalid address for ECLIPSE_MODE given.
        -:  797:	 */
    #####:  798:	abort ();
call    0 never executed
    #####:  799:      if (sin (abs (mla_moon_latitude)) <= 0.36)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  800:	{
        -:  801:	  auto double f;
        -:  802:	  auto double f_2;
        -:  803:	  auto double p;
        -:  804:	  auto double q;
        -:  805:	  auto double g;
        -:  806:	  auto double u;
        -:  807:
        -:  808:
    #####:  809:	  f = mla_moon_latitude - 0.02665 * sin (moon_longitude);
    #####:  810:	  f_2 = 2.0 * f;
    #####:  811:	  p = 0.2070 * sin (sma_sun_mean_anomaly) * sea_sun_eccent_anomaly
    #####:  812:	    + 0.0024 * sin (sma_2) * sea_sun_eccent_anomaly
    #####:  813:	    - 0.0392 * sin (mma_moon_mean_anomaly)
    #####:  814:	    + 0.0116 * sin (mma_2)
    #####:  815:	    - 0.0730 * sin (mma_p_sma) * sea_sun_eccent_anomaly
    #####:  816:	    + 0.0067 * sin (mma_m_sma) * sea_sun_eccent_anomaly
    #####:  817:	    + 0.0118 * sin (f_2);
    #####:  818:	  q = 5.2207
    #####:  819:	    - 0.0048 * cos (sma_sun_mean_anomaly) * sea_sun_eccent_anomaly
    #####:  820:	    + 0.0020 * cos (sma_2) * sea_sun_eccent_anomaly
    #####:  821:	    - 0.3299 * cos (mma_moon_mean_anomaly)
    #####:  822:	    - 0.0060 * cos (mma_p_sma) * sea_sun_eccent_anomaly
    #####:  823:	    + 0.0041 * cos (mma_m_sma) * sea_sun_eccent_anomaly;
    #####:  824:	  g = (p * cos (f) + q * sin (f)) * (1.0 - 0.0048 * cos (abs (f)));
branch  0 never executed
branch  1 never executed
    #####:  825:	  u = 0.0059
    #####:  826:	    + 0.0046 * cos (sma_sun_mean_anomaly) * sea_sun_eccent_anomaly
    #####:  827:	    - 0.0182 * cos (mma_moon_mean_anomaly)
    #####:  828:	    + 0.0004 * cos (mma_2) - 0.0005 * cos (mma_p_sma);
    #####:  829:	  if (phase_selector == MPHASE_FUL)
branch  0 never executed
branch  1 never executed
        -:  830:	    {
        -:  831:	      /*
        -:  832:	         Find lunar eclipse.
        -:  833:	       */
    #####:  834:	      f = (1.0248 - u - abs (g)) / 0.545;
branch  0 never executed
branch  1 never executed
    #####:  835:	      if (f > -1.059)
branch  0 never executed
branch  1 never executed
        -:  836:		{
    #####:  837:		  if (f < 0.0)
branch  0 never executed
branch  1 never executed
    #####:  838:		    *eclipse_type = ECLIPSE_PENUMBRAL;
        -:  839:		  else
        -:  840:		    {
    #####:  841:		      if (((1.0128 - u - abs (g)) / 0.545 > 0.0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  842:			  && ((0.4678 - u) * (0.4678 - u) - g * g > 0.0))
branch  0 never executed
branch  1 never executed
    #####:  843:			*eclipse_type = ECLIPSE_TOTAL;
        -:  844:		      else
    #####:  845:			*eclipse_type = ECLIPSE_PARTIAL;
        -:  846:		    }
    #####:  847:		  coeff1 = -0.4065;
    #####:  848:		  coeff2 = 0.1727;
        -:  849:		}
        -:  850:	    }
        -:  851:	  else
        -:  852:	    /*
        -:  853:	       Find solar eclipse.
        -:  854:	     */
    #####:  855:	  if (abs (g) <= 1.5433 + u)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  856:	    {
    #####:  857:	      if (((g >= -0.9972)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  858:		   && (g <= 0.9972))
branch  0 never executed
branch  1 never executed
    #####:  859:		  || ((abs (g) >= 0.9972) && (abs (g) < 0.9972 + abs (u))))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:  860:		{
    #####:  861:		  if (u < 0.0
branch  0 never executed
branch  1 never executed
    #####:  862:		      || ((g > 0.0)
branch  0 never executed
branch  1 never executed
    #####:  863:			  && (u >= 0.0)
branch  0 never executed
branch  1 never executed
    #####:  864:			  && (u <= 0.0047)
branch  0 never executed
branch  1 never executed
    #####:  865:			  && (u < 0.00464 * sqrt (1.0 - g * g))))
branch  0 never executed
branch  1 never executed
    #####:  866:		    *eclipse_type = ECLIPSE_TOTAL;
        -:  867:		  else
    #####:  868:		    *eclipse_type = ECLIPSE_ANNULAR;
        -:  869:		}
        -:  870:	      else
    #####:  871:		*eclipse_type = ECLIPSE_PARTIAL;
    #####:  872:	      coeff1 = -0.4075;
    #####:  873:	      coeff2 = 0.1721;
        -:  874:	    }
    #####:  875:	  if (*eclipse_type != SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
        -:  876:	    {
        -:  877:	      auto int d;
        -:  878:	      auto int m;
        -:  879:	      auto int y;
        -:  880:
        -:  881:
    #####:  882:	      jd2 += (coeff1 * sin (mma_moon_mean_anomaly)
    #####:  883:		      +
    #####:  884:		      coeff2 * sin (sma_sun_mean_anomaly) *
    #####:  885:		      sea_sun_eccent_anomaly + 0.0161 * sin (mma_2) -
    #####:  886:		      0.0097 * sin (f_2) +
    #####:  887:		      0.0073 * sin (mma_m_sma) * sea_sun_eccent_anomaly -
    #####:  888:		      0.0050 * sin (mma_p_sma) * sea_sun_eccent_anomaly -
    #####:  889:		      0.0023 * sin (mma_moon_mean_anomaly - f_2) +
    #####:  890:		      0.0021 * sin (sma_2) * sea_sun_eccent_anomaly +
    #####:  891:		      0.0012 * sin (mma_moon_mean_anomaly + f_2) +
    #####:  892:		      0.0006 * sin (mma_2 +
    #####:  893:				    sma_sun_mean_anomaly) *
    #####:  894:		      sea_sun_eccent_anomaly - 0.0004 * sin (mma_3) -
    #####:  895:		      0.0003 * sin (sma_sun_mean_anomaly +
    #####:  896:				    f_2) * sea_sun_eccent_anomaly +
    #####:  897:		      0.0003 * sin (a) - 0.0002 * sin (sma_sun_mean_anomaly -
    #####:  898:						       f_2) *
    #####:  899:		      sea_sun_eccent_anomaly - 0.0002 * sin (mma_2 -
        -:  900:							     sma_sun_mean_anomaly)
    #####:  901:		      * sea_sun_eccent_anomaly -
    #####:  902:		      0.0002 * sin (moon_longitude));
        -:  903:	      /*
        -:  904:	         Convert to Christian Era.
        -:  905:	       */
    #####:  906:	      jd2 -= (MIN_BCE_TO_1_CE - 1.5);
        -:  907:	      /*
        -:  908:	         Convert TDT to UT.
        -:  909:	       */
    #####:  910:	      num2date ((Ulint) jd2, &d, &m, &y);
call    0 never executed
    #####:  911:	      val2hours (jd2, &hour, &min, NULL);
call    0 never executed
    #####:  912:	      jd2 -= SS2DAY (delta_t (d, m, y, hour, min));
call    0 never executed
        -:  913:	      /*
        -:  914:	         Convert UT to local time.
        -:  915:	       */
    #####:  916:	      jd2 += meridian_time;
    #####:  917:	      *eclipse_type += jd2;
        -:  918:	    }
        -:  919:	}
        -:  920:    }
        -:  921:
    #####:  922:  return (julian_date);
        -:  923:}
        -:  924:
        -:  925:
        -:  926:
        -:  927:double
function next_sun_longitude called 0 returned 0% blocks executed 0%
    #####:  928:next_sun_longitude (longitude, step, mjd, day, month, year, hour, min)
        -:  929:     double *longitude;
        -:  930:     const double step;
        -:  931:     const double mjd;
        -:  932:     int *day;
        -:  933:     int *month;
        -:  934:     int *year;
        -:  935:     const int hour;
        -:  936:     const int min;
        -:  937:/*!
        -:  938:   Calculates and returns the Julian/Gregorian date and time fraction
        -:  939:     (properly converted, and this number is also passed via the addresses
        -:  940:     of DAY, MONTH and YEAR), at which the true solar longitude degree has
        -:  941:     moved by STEP degrees from the base LONGITUDE in the given base YEAR.
        -:  942:     The date of the LONGITUDE, expressed as a Julian/Gregorian date and time
        -:  943:     fraction, must be given via MJD, so the date of the ``next'' longitude can
        -:  944:     be computed (which can possibly be a date in a ``next'' year).  The caller
        -:  945:     has to guarantee that LONGITUDE and STEP are set to proper values within
        -:  946:     the range 0...359.9~.  Calculations are done for a line at a definite
        -:  947:     meridian expressed as a time value in HOUR and MIN.  If HOUR and MIN are
        -:  948:     set to zero, calculations are done for UTC/GMT.  If HOUR and MIN have a
        -:  949:     positive sign, calculations are done for meridians East of Greenwich,
        -:  950:     otherwise for meridians West of Greenwich.
        -:  951:     If LONGITUDE does not appear in YEAR, or LONGITUDE is during the period
        -:  952:     00010101...0001-ONE-DAY-PRIOR-VERNAL_EQUINOX, SPECIAL_VALUE is returned.
        -:  953:*/
        -:  954:{
        -:  955:  auto double next;
        -:  956:
        -:  957:
    #####:  958:  *longitude += step;
    #####:  959:  if (*longitude >= DEGS_PER_24_HOURS)
branch  0 never executed
branch  1 never executed
    #####:  960:    *longitude =
    #####:  961:      (double) ((((int) *longitude) % (int) DEGS_PER_24_HOURS) +
    #####:  962:		(*longitude - (int) *longitude));
    #####:  963:  next = sun_longitude (*longitude, day, month, year, hour, min, TRUE);
call    0 never executed
    #####:  964:  if ((Slint) next - (Slint) mjd < 0L
branch  0 never executed
branch  1 never executed
    #####:  965:      || (Slint) next - (Slint) mjd > DAY_LAST || next == SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  966:    {
    #####:  967:      if ((Slint) next - (Slint) mjd > DAY_LAST)
branch  0 never executed
branch  1 never executed
        -:  968:	{
    #####:  969:	  (*year)--;
    #####:  970:	  next =
call    0 never executed
    #####:  971:	    sun_longitude (*longitude, day, month, year, hour, min, FALSE);
        -:  972:	}
        -:  973:      else
        -:  974:	{
    #####:  975:	  (*year)++;
    #####:  976:	  next =
call    0 never executed
    #####:  977:	    sun_longitude (*longitude, day, month, year, hour, min, TRUE);
        -:  978:	}
        -:  979:    }
        -:  980:
    #####:  981:  return (next);
        -:  982:}
        -:  983:
        -:  984:
        -:  985:
        -:  986:double
function sun_longitude called 0 returned 0% blocks executed 0%
    #####:  987:sun_longitude (longitude, day, month, year, hour, min, next_mode)
        -:  988:     const double longitude;
        -:  989:     int *day;
        -:  990:     int *month;
        -:  991:     int *year;
        -:  992:     int hour;
        -:  993:     int min;
        -:  994:     const Bool next_mode;
        -:  995:/*!
        -:  996:   If LONGITUDE is set to SPECIAL_VALUE, this function calculates and returns
        -:  997:     the approximate apparent geocentric solar ecliptic longitude degree for
        -:  998:     the given Julian/Gregorian date (range 00010101...99991231), which occurs
        -:  999:     at HOUR:MIN UTC/GMT.  The addresses of DAY, MONTH and YEAR remain
        -: 1000:     untouched in this case.
        -: 1001:   If LONGITUDE is set to 0.0...359.9~, this function calculates and returns
        -: 1002:     the Julian/Gregorian date and time fraction (properly converted, and this
        -: 1003:     number is also passed via the addresses of DAY, MONTH and YEAR), at which
        -: 1004:     the approximate apparent geocentric solar ecliptic longitude degree is
        -: 1005:     approximately equal the given/searched LONGITUDE in the given YEAR.
        -: 1006:     The caller has to guarantee that LONGITUDE is set to a proper value within
        -: 1007:     the range described above.  Calculations are done for a line at a definite
        -: 1008:     meridian expressed as a time value in HOUR and MIN.  If HOUR and MIN are
        -: 1009:     set to zero, calculations are done for UTC/GMT.  If HOUR and MIN have a
        -: 1010:     positive sign, calculations are done for meridians East of Greenwich,
        -: 1011:     otherwise for meridians West of Greenwich.
        -: 1012:     If LONGITUDE does not appear in YEAR, or LONGITUDE is during the period
        -: 1013:     00010101...0001-ONE-DAY-PRIOR-VERNAL_EQUINOX, SPECIAL_VALUE is returned.
        -: 1014:   The maximum error of this function is less than |0.028| degree
        -: 1015:     (about 1.7 arcminutes, respectively, 0h42' minutes of time) for some dates
        -: 1016:     in the respected period AD 0001...9999 --typically near the maximum year--
        -: 1017:     when compared with the results created by standard ephemeris software
        -: 1018:     (aa, moontool, xephemer...), but normally much much smaller than this
        -: 1019:     value.  The error can be really critical when it appears for dates
        -: 1020:     computed near midnight, by reason the computed date can be different
        -: 1021:     the real date!
        -: 1022:   References:
        -: 1023:     * "Practical Astronomy with your Calculator", Peter Duffet-Smith,
        -: 1024:       3rd edition.  Cambridge University Press 1988, ISBN 0-521-35699-7.
        -: 1025:     * "Astronomical Formulae for Calculators", Jean Meeus, 4th ed,
        -: 1026:       Willmann-Bell 1988, ISBN 0-943396-22-0.
        -: 1027:     * "Astronomical Algorithms", Jean Meeus, 1st ed, Willmann-Bell 1991,
        -: 1028:       ISBN 0-943396-35-2.
        -: 1029:     * The WWW documents "How to compute planetary positions" and
        -: 1030:       "How to compute rise/set times and altitude above horizon"
        -: 1031:       by Paul Schlyter, <http://welcome.to/pausch> or
        -: 1032:       <http://hotel04.ausys.se/pausch>.
        -: 1033:   Btw., Keith Burnett publishes a lot of diverse --good quality--
        -: 1034:     astronomical sources and links at <http://www.xylem.demon.co.uk/kepler>.
        -: 1035:*/
        -: 1036:{
        -: 1037:  auto double x;
    #####: 1038:  auto double low = 0.0;
    #####: 1039:  auto double high = 0.0;
        -: 1040:  auto double delta;
    #####: 1041:  auto double meridian_time = HHMM2DAY (hour, min);
        -: 1042:  auto double mjd;
        -: 1043:  auto double jc;
        -: 1044:  auto double argument_of_perihelion;
        -: 1045:  auto double mean_anomaly;
        -: 1046:  auto double eccentricity;
        -: 1047:  auto double anomaly_of_eccentric;
        -: 1048:  auto double divisor_term;
        -: 1049:  auto double true_anomaly;
        -: 1050:  auto double ecliptic_longitude;
    #####: 1051:  register int y = *year;
    #####: 1052:  register int steps = 0;
        -: 1053:  register int i;
        -: 1054:
        -: 1055:
    #####: 1056:LABEL_sel_start:
    #####: 1057:  i = 0;
        -: 1058:  /*
        -: 1059:     Epoch starts 01-Jan-2000 12:00:00 UT, convert UT to TDT.
        -: 1060:   */
    #####: 1061:  if (longitude == SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####: 1062:    mjd = date2num (*day, *month, *year)
call    0 never executed
    #####: 1063:      + SS2DAY (delta_t (*day, *month, *year, hour, min))
call    0 never executed
    #####: 1064:      + meridian_time - 730122.5;
        -: 1065:  else
        -: 1066:    {
    #####: 1067:      mjd = date2num (DAY_MIN, MONTH_MIN, *year)
call    0 never executed
    #####: 1068:	+ SS2DAY (delta_t (DAY_MIN, MONTH_MIN, *year, hour, min)) - 730122.5;
call    0 never executed
        -: 1069:      /*
        -: 1070:         Perform correction if it is a proleptic Julian date.
        -: 1071:       */
    #####: 1072:      if (*year <= greg->year)
branch  0 never executed
branch  1 never executed
    #####: 1073:	mjd -= ((*year / 100) - (*year / 400) - 2);
        -: 1074:      /*
        -: 1075:         Set proper starting values for the binary search.
        -: 1076:       */
    #####: 1077:      low = mjd + longitude + 65.0;
    #####: 1078:      high = mjd + longitude + 95.0;
    #####: 1079:      mjd = (high + low) * 0.5;
        -: 1080:    }
        -: 1081:  LOOP
        -: 1082:  {
    #####: 1083:    jc = mjd / 36525.0;
    #####: 1084:    argument_of_perihelion = TORAD (FIXANGLE (282.93735
        -: 1085:					      + (0.71953 +
        -: 1086:						 (0.00046 * jc)) * jc));
    #####: 1087:    mean_anomaly =
    #####: 1088:      TORAD (FIXANGLE
        -: 1089:	     (357.52910 +
        -: 1090:	      (35999.05030 - (0.0001559 + 0.00000048 * jc) * jc) * jc));
    #####: 1091:    eccentricity = 0.016708617 - (0.000042037 + (0.0000001236 * jc)) * jc;
    #####: 1092:    delta = mean_anomaly + eccentricity
    #####: 1093:      * sin (mean_anomaly) * (1.0 + eccentricity * cos (mean_anomaly));
        -: 1094:    do
        -: 1095:      {
    #####: 1096:	x = delta;
    #####: 1097:	delta = x - (x - eccentricity * sin (x) - mean_anomaly)
    #####: 1098:	  / (1.0 - eccentricity * cos (x));
        -: 1099:      }
    #####: 1100:    while (abs (abs (x) - abs (delta)) > 0.000001);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####: 1101:    anomaly_of_eccentric = delta;
    #####: 1102:    divisor_term = cos (anomaly_of_eccentric) - eccentricity;
    #####: 1103:    true_anomaly =
    #####: 1104:      atan ((sqrt (1.0 - eccentricity * eccentricity) *
    #####: 1105:	     sin (anomaly_of_eccentric)) / divisor_term);
    #####: 1106:    if (divisor_term < 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1107:      true_anomaly += MY_PI;
    #####: 1108:    ecliptic_longitude =
    #####: 1109:      FIXANGLE (TODEG (true_anomaly + argument_of_perihelion) + jc - 0.00569 -
        -: 1110:		0.00479 *
        -: 1111:		sin (TORAD (124.90 - (1934.134 - (0.002063 * jc)) * jc)));
    #####: 1112:    if (longitude == SPECIAL_VALUE)
branch  0 never executed
branch  1 never executed
    #####: 1113:      return (ecliptic_longitude);
    #####: 1114:    delta = abs (longitude - abs (ecliptic_longitude));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1115:    /*
        -: 1116:       Check whether we are searching around the zero degree range,
        -: 1117:       which is a discontinuity in this case and must be treated specially.
        -: 1118:     */
    #####: 1119:    if (delta > DEGS_PER_12_HOURS)
branch  0 never executed
branch  1 never executed
        -: 1120:      {
        -: 1121:	/*
        -: 1122:	   Discontinuity detected, so perform proper adjustments
        -: 1123:	   to keep the convergence of the interpolation.
        -: 1124:	 */
    #####: 1125:	ecliptic_longitude -= DEGS_PER_24_HOURS;
    #####: 1126:	if ((longitude > 330.0) && (abs (ecliptic_longitude) < longitude))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1127:	  ecliptic_longitude = longitude + 1.0;
    #####: 1128:	else if (ecliptic_longitude < -DEGS_PER_12_HOURS)
branch  0 never executed
branch  1 never executed
    #####: 1129:	  ecliptic_longitude = -ecliptic_longitude;
        -: 1130:      }
        -: 1131:    /*
        -: 1132:       Check whether the actual delta value is greater than the given epsilon.
        -: 1133:     */
    #####: 1134:    if (delta > 0.000001)
branch  0 never executed
branch  1 never executed
        -: 1135:      {
        -: 1136:	/*
        -: 1137:	   Yes, perform next interpolation step with adjusted margins.
        -: 1138:	 */
    #####: 1139:	if (ecliptic_longitude > longitude)
branch  0 never executed
branch  1 never executed
    #####: 1140:	  high = mjd;
        -: 1141:	else
    #####: 1142:	  low = mjd;
    #####: 1143:	mjd = (high + low) * 0.5;
        -: 1144:      }
        -: 1145:    else
        -: 1146:      /*
        -: 1147:         No, the interpolation result is precise enough now.
        -: 1148:       */
    #####: 1149:      break;
        -: 1150:    /*
        -: 1151:       Avoid neverending loop if interpolation divergence is detected.
        -: 1152:     */
    #####: 1153:    if (++i >= 100)
branch  0 never executed
branch  1 never executed
    #####: 1154:      my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__, ((long) __LINE__) - 1L,
call    0 never executed
        -: 1155:		"sun_longitude():interpolation<", i);
        -: 1156:  }
        -: 1157:  /*
        -: 1158:     Convert TDT to UT.
        -: 1159:   */
    #####: 1160:  mjd += 730122.5;
    #####: 1161:  num2date ((Ulint) mjd, day, month, year);
call    0 never executed
    #####: 1162:  val2hours (mjd, &hour, &min, NULL);
call    0 never executed
    #####: 1163:  mjd -= SS2DAY (delta_t (*day, *month, *year, hour, min));
call    0 never executed
        -: 1164:  /*
        -: 1165:     Respect the given meridian's time value.
        -: 1166:   */
    #####: 1167:  mjd += meridian_time;
    #####: 1168:  num2date ((Ulint) mjd, day, month, year);
call    0 never executed
        -: 1169:  /*
        -: 1170:     Check if we have found the LONGITUDE in the given YEAR.
        -: 1171:   */
    #####: 1172:  if (!next_mode && (y != *year))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1173:    {
        -: 1174:      /*
        -: 1175:         We found the LONGITUDE beyond the given YEAR, so restart
        -: 1176:         searching the LONGITUDE in the year prior YEAR.
        -: 1177:       */
    #####: 1178:      if (++steps > 1)
branch  0 never executed
branch  1 never executed
        -: 1179:	/*
        -: 1180:	   Error, the LONGITUDE does not appear in YEAR.
        -: 1181:	 */
    #####: 1182:	return (SPECIAL_VALUE);
    #####: 1183:      *year -= 2;
    #####: 1184:      if (!*year)
branch  0 never executed
branch  1 never executed
        -: 1185:	/*
        -: 1186:	   Error, unable to manage the period
        -: 1187:	   AD 00010101...0001-ONE-DAY-PRIOR-VERNAL_EQUINOX.
        -: 1188:	 */
    #####: 1189:	return (SPECIAL_VALUE);
    #####: 1190:      goto LABEL_sel_start;
        -: 1191:    }
        -: 1192:  /*
        -: 1193:     Finally, correct the time fraction
        -: 1194:     if the calculated date is prior the Epoch.
        -: 1195:   */
    #####: 1196:  delta = mjd - (Slint) mjd;
    #####: 1197:  if (delta < 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1198:    mjd = (Slint) mjd + (1.0 + delta);
        -: 1199:
    #####: 1200:  return (mjd);
        -: 1201:}
        -: 1202:
        -: 1203:
        -: 1204:
        -: 1205:void
function val2hours called 0 returned 0% blocks executed 0%
    #####: 1206:val2hours (val, hour, min, sec)
        -: 1207:     double val;
        -: 1208:     int *hour;
        -: 1209:     int *min;
        -: 1210:     double *sec;
        -: 1211:/*!
        -: 1212:   Returns the day fraction which is given by VAL either converted to
        -: 1213:     a rounded 24-hour time value HH:MM via the addresses of HOUR and MIN
        -: 1214:     if SEC is NULL, or converted to a non-rounded 24-hour time value
        -: 1215:     HH:MM:SS.FRACTION via the addresses of HOUR, MIN and SEC.
        -: 1216:*/
        -: 1217:{
    #####: 1218:  register int sign = SGN (val);
branch  0 never executed
branch  1 never executed
        -: 1219:
        -: 1220:
    #####: 1221:  val = abs (val);
branch  0 never executed
branch  1 never executed
    #####: 1222:  val -= (Ulint) val;
    #####: 1223:  val *= HOURS_PER_DAY;
    #####: 1224:  *hour = (int) val;
    #####: 1225:  val -= (int) val;
    #####: 1226:  if (sec != (double *) NULL)
branch  0 never executed
branch  1 never executed
        -: 1227:    {
    #####: 1228:      val *= MINS_PER_HOUR;
    #####: 1229:      *min = (int) val;
    #####: 1230:      val -= (int) val;
    #####: 1231:      *sec = val * SECS_PER_MIN;
    #####: 1232:      if ((int) ROUND (*sec) > SECS_PER_MIN)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1233:	{
    #####: 1234:	  *sec = 0.0;
    #####: 1235:	  (*min)++;
    #####: 1236:	  if (*min > MINS_PER_HOUR)
branch  0 never executed
branch  1 never executed
        -: 1237:	    {
    #####: 1238:	      *min = 0;
    #####: 1239:	      (*hour)++;
    #####: 1240:	      if (*hour >= HOURS_PER_DAY)
branch  0 never executed
branch  1 never executed
    #####: 1241:		*hour = 0;
        -: 1242:	    }
        -: 1243:	}
        -: 1244:    }
        -: 1245:  else
        -: 1246:    {
    #####: 1247:      *min = (int) ROUND (val * MINS_PER_HOUR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1248:      if (*min >= MINS_PER_HOUR)
branch  0 never executed
branch  1 never executed
        -: 1249:	{
    #####: 1250:	  if ((*hour) + 1 >= HOURS_PER_DAY)
branch  0 never executed
branch  1 never executed
    #####: 1251:	    *min = MINS_PER_HOUR - 1;
        -: 1252:	  else
        -: 1253:	    {
    #####: 1254:	      (*hour)++;
    #####: 1255:	      *min = 0;
        -: 1256:	    }
        -: 1257:	}
        -: 1258:    }
    #####: 1259:  *hour *= sign;
    #####: 1260:  *min *= sign;
    #####: 1261:  if (sec != (double *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1262:    *sec *= sign;
    #####: 1263:}
        -: 1264:
        -: 1265:
        -: 1266:
        -: 1267:void
function val2degrees called 0 returned 0% blocks executed 0%
    #####: 1268:val2degrees (val, degree, min, sec)
        -: 1269:     double val;
        -: 1270:     int *degree;
        -: 1271:     int *min;
        -: 1272:     double *sec;
        -: 1273:/*!
        -: 1274:   Returns VAL either converted to a rounded 360-degree value DDDdMM'
        -: 1275:     via the addresses of DEGREE and MIN if SEC is NULL, or converted
        -: 1276:     to a non-rounded 360-degree value DDDdMM'SS.FRACTION via the
        -: 1277:     addresses of DEGREE, MIN and SEC.
        -: 1278:*/
        -: 1279:{
    #####: 1280:  register int sign = SGN (val);
branch  0 never executed
branch  1 never executed
        -: 1281:
        -: 1282:
    #####: 1283:  val = abs (val);
branch  0 never executed
branch  1 never executed
    #####: 1284:  val = FIXANGLE (val);
    #####: 1285:  *degree = (int) val;
    #####: 1286:  val -= (int) val;
    #####: 1287:  if (sec != (double *) NULL)
branch  0 never executed
branch  1 never executed
        -: 1288:    {
    #####: 1289:      val *= MINS_PER_HOUR;
    #####: 1290:      *min = (int) val;
    #####: 1291:      val -= (int) val;
    #####: 1292:      *sec = val * SECS_PER_MIN;
    #####: 1293:      if ((int) ROUND (*sec) > SECS_PER_MIN)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1294:	{
    #####: 1295:	  *sec = 0.0;
    #####: 1296:	  (*min)++;
    #####: 1297:	  if (*min > MINS_PER_HOUR)
branch  0 never executed
branch  1 never executed
        -: 1298:	    {
    #####: 1299:	      *min = 0;
    #####: 1300:	      (*degree)++;
    #####: 1301:	      if (*degree >= (int) DEGS_PER_24_HOURS)
branch  0 never executed
branch  1 never executed
    #####: 1302:		*degree = 0;
        -: 1303:	    }
        -: 1304:	}
        -: 1305:    }
        -: 1306:  else
        -: 1307:    {
    #####: 1308:      *min = (int) ROUND (val * MINS_PER_HOUR);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1309:      if (*min >= MINS_PER_HOUR)
branch  0 never executed
branch  1 never executed
        -: 1310:	{
    #####: 1311:	  if ((*degree) + 1 >= (int) DEGS_PER_24_HOURS)
branch  0 never executed
branch  1 never executed
    #####: 1312:	    *min = MINS_PER_HOUR - 1;
        -: 1313:	  else
        -: 1314:	    {
    #####: 1315:	      (*degree)++;
    #####: 1316:	      *min = 0;
        -: 1317:	    }
        -: 1318:	}
        -: 1319:    }
    #####: 1320:  *degree *= sign;
    #####: 1321:  *min *= sign;
    #####: 1322:  if (sec != (double *) NULL)
branch  0 never executed
branch  1 never executed
    #####: 1323:    *sec *= sign;
    #####: 1324:}
        -: 1325:
        -: 1326:
        -: 1327:
        -: 1328:double
function my_cot called 0 returned 0% blocks executed 0%
    #####: 1329:my_cot (x)
        -: 1330:     double x;
        -: 1331:/*!
        -: 1332:   Computes the "cotangent" of a given X by using the formula:
        -: 1333:
        -: 1334:     cotangent X := 1 / tangent X
        -: 1335:
        -: 1336:   Another alternative formula is:
        -: 1337:
        -: 1338:     cotangent X := cosine X / sine X
        -: 1339:*/
        -: 1340:{
    #####: 1341:  x = tan (x);
    #####: 1342:  if (x == 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1343:    my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__, ((long) __LINE__) - 1L,
call    0 never executed
        -: 1344:	      "my_cot()=", 0);
        -: 1345:
    #####: 1346:  return (1.0 / x);
        -: 1347:}
        -: 1348:
        -: 1349:
        -: 1350:
        -: 1351:double
function my_acot called 0 returned 0% blocks executed 0%
    #####: 1352:my_acot (x)
        -: 1353:     double x;
        -: 1354:/*!
        -: 1355:   Computes the "arc cotangent" of a given X by using the formulae:
        -: 1356:
        -: 1357:     arc cotangent X := arc tangent 1 / X
        -: 1358:
        -: 1359:   for X values greater than 0.0;
        -: 1360:
        -: 1361:     arc cotangent X := Pi / 2
        -: 1362:
        -: 1363:   for X values equal 0.0;
        -: 1364:
        -: 1365:     arc cotangent X := arc tangent 1 / X + Pi
        -: 1366:
        -: 1367:   for X values less than 0.0.
        -: 1368:*/
        -: 1369:{
    #####: 1370:  if (x == 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1371:    return (MY_HALF_PI);
    #####: 1372:  if (x > 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1373:    return (atan (1.0 / x));
        -: 1374:
    #####: 1375:  return (atan (1.0 / x) + MY_PI);
        -: 1376:}
        -: 1377:
        -: 1378:
        -: 1379:
        -: 1380:double
function my_atan2 called 0 returned 0% blocks executed 0%
    #####: 1381:my_atan2 (y, x)
        -: 1382:     double y;
        -: 1383:     double x;
        -: 1384:/*!
        -: 1385:   Computes the "arc tangent Y/X" selecting the correct quadrant,
        -: 1386:     i.e. returns the angle between 0 and 2 Pi whose tangent is Y/X.
        -: 1387:*/
        -: 1388:{
    #####: 1389:  if (x > 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1390:    return (atan (y / x));
    #####: 1391:  else if (x < 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1392:    return (atan (y / x) + MY_PI);
    #####: 1393:  else if (y > 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1394:    return (MY_HALF_PI);
    #####: 1395:  else if (y < 0.0)
branch  0 never executed
branch  1 never executed
    #####: 1396:    return (-MY_HALF_PI);
        -: 1397:
    #####: 1398:  return (0.0);
        -: 1399:}
        -: 1400:
        -: 1401:
        -: 1402:
        -: 1403:#if !HAVE_LIBM
        -: 1404:double
        -: 1405:my_floor (x)
        -: 1406:     double x;
        -: 1407:/*!
        -: 1408:   Returns the largest integer value not greater than X.
        -: 1409:*/
        -: 1410:{
        -: 1411:  auto double sign = 1.0;
        -: 1412:
        -: 1413:
        -: 1414:  /*
        -: 1415:     Get the sign of X.
        -: 1416:   */
        -: 1417:  if (x < 0.0)
        -: 1418:    {
        -: 1419:      x = -x;
        -: 1420:      sign = -sign;
        -: 1421:    }
        -: 1422:  /*
        -: 1423:     Calculate the `floor()' value.
        -: 1424:   */
        -: 1425:  if (x - (Slint) x >= 0.0)
        -: 1426:    {
        -: 1427:      x = (Slint) x;
        -: 1428:      if (sign < 0.0)
        -: 1429:	x += 1.0;
        -: 1430:    }
        -: 1431:
        -: 1432:  return (sign * x);
        -: 1433:}
        -: 1434:
        -: 1435:
        -: 1436:
        -: 1437:double
        -: 1438:my_ceil (x)
        -: 1439:     double x;
        -: 1440:/*!
        -: 1441:   Returns the smallest integer value not less than X.
        -: 1442:*/
        -: 1443:{
        -: 1444:  auto double sign = 1.0;
        -: 1445:
        -: 1446:
        -: 1447:  /*
        -: 1448:     Get the sign of X.
        -: 1449:   */
        -: 1450:  if (x < 0.0)
        -: 1451:    {
        -: 1452:      x = -x;
        -: 1453:      sign = -sign;
        -: 1454:    }
        -: 1455:  /*
        -: 1456:     Calculate the `ceil()' value.
        -: 1457:   */
        -: 1458:  if (x - (Slint) x >= 0.0)
        -: 1459:    {
        -: 1460:      x = (Slint) x;
        -: 1461:      if (sign > 0.0)
        -: 1462:	x += 1.0;
        -: 1463:    }
        -: 1464:
        -: 1465:  return (sign * x);
        -: 1466:}
        -: 1467:
        -: 1468:
        -: 1469:
        -: 1470:double
        -: 1471:my_sqrt (x)
        -: 1472:     double x;
        -: 1473:/*!
        -: 1474:   Computes the "square root" of a given X by using Newton's iteration formula:
        -: 1475:
        -: 1476:     sqrt X :=  X    = X - (f(X ) / f'(X )) , n=0,1,2,... , abs((f(X) * f''(X)) / (f'(X))^2) < 1
        -: 1477:                 n+1    n      n        n
        -: 1478:*/
        -: 1479:{
        -: 1480:  auto const double my_epsilon = 0.000001;
        -: 1481:  auto double old_term;
        -: 1482:  auto double current_term;
        -: 1483:
        -: 1484:
        -: 1485:  if (x == 0.0 || x == 1.0)
        -: 1486:    return (x);
        -: 1487:  if (x < 0.0)
        -: 1488:    my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__, ((long) __LINE__) - 1L,
        -: 1489:	      "my_sqrt()<", 0);
        -: 1490:  old_term = x;
        -: 1491:  current_term = 1.0;
        -: 1492:  LOOP
        -: 1493:  {
        -: 1494:    current_term = (current_term + x / current_term) * 0.5;
        -: 1495:    if (abs (current_term) - abs (old_term) < current_term * my_epsilon)
        -: 1496:      /*
        -: 1497:         Result does not change anymore, we have computed it with success.
        -: 1498:       */
        -: 1499:      break;
        -: 1500:    old_term = current_term;
        -: 1501:  }
        -: 1502:
        -: 1503:  return (current_term);
        -: 1504:}
        -: 1505:
        -: 1506:
        -: 1507:
        -: 1508:double
        -: 1509:my_log (x)
        -: 1510:     double x;
        -: 1511:/*!
        -: 1512:   Computes the "logarithm base e" (logarithmus naturalis, ln) of a given X
        -: 1513:     by using a series and the fact, that log  X^2 == 2 log  X:
        -: 1514:                                             e             e
        -: 1515:     log  X := 2 (  X
        -: 1516:        e         + (((X-1)/(X+1))^3) / 3
        -: 1517:                  + (((X-1)/(X+1))^5) / 5
        -: 1518:                  + ...
        -: 1519:                  + (((X-1)/(X+1))^(2n+1)) / (2n+1)) , r=inf , X > 0
        -: 1520:
        -: 1521:   This function is partly based on the ideas found in the `libmath.b' file of
        -: 1522:     the GNU `bc-1.05a' package written by Philip A. Nelson <phil@cs.wwu.edu>,
        -: 1523:     which is copyrighted by the FSF.  So see it for more information!
        -: 1524:     It is adapted and `pretty-printed' to the requirements of Gcal.
        -: 1525:*/
        -: 1526:{
        -: 1527:  auto double current_term;
        -: 1528:  auto double numerator_value;
        -: 1529:  auto double accumulated_value;
        -: 1530:  auto double temp;
        -: 1531:  auto Ulint factor = 2L;
        -: 1532:  register int n;
        -: 1533:
        -: 1534:
        -: 1535:  if (x <= 0.0)
        -: 1536:    my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__, ((long) __LINE__) - 1L,
        -: 1537:	      "my_log()<=", 0);
        -: 1538:  /*
        -: 1539:     Precondition X to make 0.5 < X < 2.0.
        -: 1540:   */
        -: 1541:  while (x >= 2.0)
        -: 1542:    {
        -: 1543:      /*
        -: 1544:         For large numbers.
        -: 1545:       */
        -: 1546:      factor *= 2L;
        -: 1547:      x = my_sqrt (x);
        -: 1548:    }
        -: 1549:  while (x <= 0.5)
        -: 1550:    {
        -: 1551:      /*
        -: 1552:         For small numbers.
        -: 1553:       */
        -: 1554:      factor *= 2L;
        -: 1555:      x = my_sqrt (x);
        -: 1556:    }
        -: 1557:  /*
        -: 1558:     Initialize the series.
        -: 1559:   */
        -: 1560:  accumulated_value = numerator_value = (x - 1) / (x + 1);
        -: 1561:  temp = accumulated_value * accumulated_value;
        -: 1562:  /*
        -: 1563:     Calculate the series.
        -: 1564:   */
        -: 1565:  n = 3;
        -: 1566:  LOOP
        -: 1567:  {
        -: 1568:    numerator_value *= temp;
        -: 1569:    current_term = numerator_value / (double) n;
        -: 1570:    if (abs (accumulated_value) - abs (current_term) ==
        -: 1571:	abs (accumulated_value))
        -: 1572:      /*
        -: 1573:         Result does not change anymore, we have computed it with success.
        -: 1574:       */
        -: 1575:      break;
        -: 1576:    accumulated_value += current_term;
        -: 1577:    n += 2;
        -: 1578:  }
        -: 1579:
        -: 1580:  return (factor * accumulated_value);
        -: 1581:}
        -: 1582:
        -: 1583:
        -: 1584:
        -: 1585:double
        -: 1586:my_log10 (x)
        -: 1587:     double x;
        -: 1588:/*!
        -: 1589:   Computes the "logarithm base 10" of a given X by using the formula:
        -: 1590:
        -: 1591:     log   X := log  X / log  10
        -: 1592:        10         e        e
        -: 1593:*/
        -: 1594:{
        -: 1595:  if (x <= 0.0)
        -: 1596:    my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__, ((long) __LINE__) - 1L,
        -: 1597:	      "my_log10()<=", 0);
        -: 1598:
        -: 1599:  return (my_log (x) / 2.302585092994045684);
        -: 1600:}
        -: 1601:
        -: 1602:
        -: 1603:
        -: 1604:double
        -: 1605:my_sin (x)
        -: 1606:     double x;
        -: 1607:/*!
        -: 1608:   Computes the "sine" of a given X by using the series:
        -: 1609:
        -: 1610:     sine X :=   X
        -: 1611:               - (X^3) / 3!
        -: 1612:               + (X^5) / 5!
        -: 1613:               - (X^7) / 7!
        -: 1614:               +- ...
        -: 1615:               + (-1)^n * ((X^(2n+1)) / (2n+1)!)
        -: 1616:               + ... , r=inf
        -: 1617:
        -: 1618:   This function is partly based on the ideas found in the `libmath.b' file of
        -: 1619:     the GNU `bc-1.05a' package written by Philip A. Nelson <phil@cs.wwu.edu>,
        -: 1620:     which is copyrighted by the FSF.  So see it for more information!
        -: 1621:     It is adapted and `pretty-printed' to the requirements of Gcal.
        -: 1622:*/
        -: 1623:{
        -: 1624:  auto double sign = 1.0;
        -: 1625:  auto double current_term;
        -: 1626:  auto double numerator_value;
        -: 1627:  auto double accumulated_value;
        -: 1628:  auto double temp;
        -: 1629:  register int n;
        -: 1630:
        -: 1631:
        -: 1632:  /*
        -: 1633:     Get the sign of X.
        -: 1634:   */
        -: 1635:  if (x < 0.0)
        -: 1636:    {
        -: 1637:      x = -x;
        -: 1638:      sign = -sign;
        -: 1639:    }
        -: 1640:  /*
        -: 1641:     Pi / 4.
        -: 1642:   */
        -: 1643:  accumulated_value = 0.785398163397448309616;
        -: 1644:  /*
        -: 1645:     Precondition X.
        -: 1646:   */
        -: 1647:  numerator_value = (((Slint) (x / accumulated_value)) + 2) / 4;
        -: 1648:  x = x - 4.0 * numerator_value * accumulated_value;
        -: 1649:  if (((Slint) numerator_value) % 2)
        -: 1650:    x = -x;
        -: 1651:  /*
        -: 1652:     Initialize the series.
        -: 1653:   */
        -: 1654:  accumulated_value = current_term = x;
        -: 1655:  temp = -x * x;
        -: 1656:  /*
        -: 1657:     Calculate the series.
        -: 1658:   */
        -: 1659:  n = 3;
        -: 1660:  LOOP
        -: 1661:  {
        -: 1662:    current_term *= (temp / (double) (n * (n - 1)));
        -: 1663:    if (abs (accumulated_value) - abs (current_term) ==
        -: 1664:	abs (accumulated_value))
        -: 1665:      /*
        -: 1666:         Result does not change anymore, we have computed it with success.
        -: 1667:       */
        -: 1668:      break;
        -: 1669:    accumulated_value += current_term;
        -: 1670:    n += 2;
        -: 1671:  }
        -: 1672:
        -: 1673:  return (sign * accumulated_value);
        -: 1674:}
        -: 1675:
        -: 1676:
        -: 1677:
        -: 1678:double
        -: 1679:my_cos (x)
        -: 1680:     double x;
        -: 1681:/*!
        -: 1682:   Computes the "cosine" of a given X by using the formula:
        -: 1683:
        -: 1684:     cosine X := sine (X + Pi / 2)
        -: 1685:*/
        -: 1686:{
        -: 1687:  return (my_sin (x + MY_HALF_PI));
        -: 1688:}
        -: 1689:
        -: 1690:
        -: 1691:
        -: 1692:double
        -: 1693:my_tan (x)
        -: 1694:     double x;
        -: 1695:/*!
        -: 1696:   Computes the "tangent" of a given X by using the formula:
        -: 1697:
        -: 1698:     tangent X := sine X / cosine X
        -: 1699:*/
        -: 1700:{
        -: 1701:  auto double y = my_cos (x);
        -: 1702:
        -: 1703:
        -: 1704:  if (y == 0.0)
        -: 1705:    my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__, ((long) __LINE__) - 1L,
        -: 1706:	      "my_tan()=", 0);
        -: 1707:
        -: 1708:  return (my_sin (x) / my_cos (x));
        -: 1709:}
        -: 1710:
        -: 1711:
        -: 1712:
        -: 1713:double
        -: 1714:my_asin (x)
        -: 1715:     double x;
        -: 1716:/*!
        -: 1717:   Computes the "arc sine" of a given X by using the formula:
        -: 1718:
        -: 1719:     arc sine X := Pi / 2 - arc tangent (square root (1 - X * X) / X)
        -: 1720:
        -: 1721:   for X values greater than 0.7;
        -: 1722:   and for X values less equal 0.7 by using the formula:
        -: 1723:
        -: 1724:     arc sine X := arc tangent (X / sqare root (1 - X * X))
        -: 1725:*/
        -: 1726:{
        -: 1727:  auto double sign = 1.0;
        -: 1728:  auto double temp;
        -: 1729:
        -: 1730:
        -: 1731:  /*
        -: 1732:     Get the sign of X.
        -: 1733:   */
        -: 1734:  if (x < 0.0)
        -: 1735:    {
        -: 1736:      x = -x;
        -: 1737:      sign = -sign;
        -: 1738:    }
        -: 1739:  if (x > 1.0)
        -: 1740:    my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__, ((long) __LINE__) - 1L,
        -: 1741:	      "my_asin()>", 1);
        -: 1742:  temp = my_sqrt (1.0 - x * x);
        -: 1743:  if (x > 0.70)
        -: 1744:    temp = MY_HALF_PI - my_atan (temp / x);
        -: 1745:  else
        -: 1746:    temp = my_atan (x / temp);
        -: 1747:
        -: 1748:  return (sign * temp);
        -: 1749:}
        -: 1750:
        -: 1751:
        -: 1752:
        -: 1753:double
        -: 1754:my_acos (x)
        -: 1755:     double x;
        -: 1756:/*!
        -: 1757:   Computes the "arc cosine" of a given X by using the formula:
        -: 1758:
        -: 1759:     arc cosine := Pi / 2 - arc sine X
        -: 1760:*/
        -: 1761:{
        -: 1762:  if (x > 1.0 || x < -1.0)
        -: 1763:    my_error (ERR_INTERNAL_C_FUNC_FAILURE, __FILE__, ((long) __LINE__) - 2L,
        -: 1764:	      "abs(my_acos())>", 1);
        -: 1765:
        -: 1766:  return (MY_HALF_PI - my_asin (x));
        -: 1767:}
        -: 1768:
        -: 1769:
        -: 1770:
        -: 1771:double
        -: 1772:my_atan (x)
        -: 1773:     double x;
        -: 1774:/*!
        -: 1775:   Computes the "arc tangent" of a given X by using the formula:
        -: 1776:
        -: 1777:     arc tangent X := arc tangent c + arc tangent ((X - c) / (1 + X * c))
        -: 1778:
        -: 1779:   for a small `c' (0.2 here) and for X values greater than 0.2;
        -: 1780:   and for X values less than 0.2 by using the series:
        -: 1781:
        -: 1782:     arc tangent X :=   X
        -: 1783:                      - (X^3) / 3
        -: 1784:                      + (X^5) / 5
        -: 1785:                      - (X^7) / 7
        -: 1786:                      +- ...
        -: 1787:                      + (-1^n) * (X^(2n+1) / (2n+1))
        -: 1788:                      + ... , r=1
        -: 1789:
        -: 1790:   This function is partly based on the ideas found in the `libmath.b' file of
        -: 1791:     the GNU `bc-1.05a' package written by Philip A. Nelson <phil@cs.wwu.edu>,
        -: 1792:     which is copyrighted by the FSF.  So see it for more information!
        -: 1793:     It is adapted and `pretty-printed' to the requirements of Gcal.
        -: 1794:*/
        -: 1795:{
        -: 1796:  auto double known_atan_value = 0.0;
        -: 1797:  auto double number_of_known_atan = 0.0;
        -: 1798:  auto double sign = 1.0;
        -: 1799:  auto double current_term;
        -: 1800:  auto double numerator_value;
        -: 1801:  auto double accumulated_value;
        -: 1802:  auto double temp;
        -: 1803:  register int n;
        -: 1804:
        -: 1805:
        -: 1806:  /*
        -: 1807:     Get the sign of X.
        -: 1808:   */
        -: 1809:  if (x < 0.0)
        -: 1810:    {
        -: 1811:      x = -x;
        -: 1812:      sign = -sign;
        -: 1813:    }
        -: 1814:  /*
        -: 1815:     Calculate the "arc tangent" of a known number (0.20 here).
        -: 1816:   */
        -: 1817:  if (x > 0.20)
        -: 1818:    known_atan_value = 0.197395559849880758370;
        -: 1819:  /*
        -: 1820:     Precondition X.
        -: 1821:   */
        -: 1822:  while (x > 0.20)
        -: 1823:    {
        -: 1824:      number_of_known_atan += 1.0;
        -: 1825:      x = (x - 0.20) / (1.0 + x * 0.20);
        -: 1826:    }
        -: 1827:  /*
        -: 1828:     Initialize the series.
        -: 1829:   */
        -: 1830:  accumulated_value = numerator_value = x;
        -: 1831:  temp = -x * x;
        -: 1832:  /*
        -: 1833:     Calculate the series.
        -: 1834:   */
        -: 1835:  n = 3;
        -: 1836:  LOOP
        -: 1837:  {
        -: 1838:    numerator_value *= temp;
        -: 1839:    current_term = numerator_value / (double) n;
        -: 1840:    if (abs (accumulated_value) - abs (current_term) ==
        -: 1841:	abs (accumulated_value))
        -: 1842:      /*
        -: 1843:         Result does not change anymore, we have computed it with success.
        -: 1844:       */
        -: 1845:      break;
        -: 1846:    accumulated_value += current_term;
        -: 1847:    n += 2;
        -: 1848:  }
        -: 1849:
        -: 1850:  return (sign *
        -: 1851:	  (number_of_known_atan * known_atan_value + accumulated_value));
        -: 1852:}
        -: 1853:#endif /* !HAVE_LIBM */
